---
title: "Scripts for creating Nass parameters"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source (here::here("R/functions/R_Postgres.R"))
library (data.table)
library (sf)
library (tidyverse)
library (raster)
librarty (fasterize)

data.dir <- "G:\\!Workgrp\\Analysts\\!Project\\TSA_Projects\\active\\Nass_TSA\\2022\\andrew_deliverables\\Nass_almost_BaseCase_03_16\\Nass\\gisData\\grids\\"

#Create a provincial raster
layeraoi<-getSpatialQuery("SELECT * FROM study_area_compart limit 1")
prov.rast <- raster::raster(
  nrows = 15744, ncols = 17216, xmn = 159587.5, xmx = 1881187.5, ymn = 173787.5, ymx = 1748187.5, 
  crs = st_crs(layeraoi)$proj4string, resolution = c(100, 100), vals = 0)
```

## Nass Area of Interest
```{r Nass TSA}

nass.tsa <- st_make_valid (getSpatialQuery ("SELECT tsa_number, tsbnmbrdsc, wkb_geometry FROM public.fadm_tsa_polygon WHERE tsa_number = '43';"))
nass.tsa.supply.blocks <- st_make_valid (getSpatialQuery ("SELECT tsa_number, tsbnmbrdsc, wkb_geometry FROM public.fadm_tsa_polygon WHERE tsbnmbrdsc = 'Nass TSA Stewart Block' OR tsbnmbrdsc = 'Nass TSA Block E';"))

null.block <- st_difference(nass.tsa, st_union(st_geometry(st_intersection(nass.tsa, nass.tsa.supply.blocks))))
nass.tsa.supply.blocks <- rbind (nass.tsa.supply.blocks, null.block)

names(nass.tsa) [names(nass.tsa) == "tsa_number"] <- "tsa_name"
nass.tsa$tsa_name <- "Nass_TSA"

names(nass.tsa.supply.blocks) [names(nass.tsa.supply.blocks) == "tsbnmbrdsc"] <- "supply_block"
nass.tsa.supply.blocks$supply_block [nass.tsa.supply.blocks$supply_block == "Nass TSA Stewart Block"] <- "Stewart_Block"
nass.tsa.supply.blocks$supply_block [nass.tsa.supply.blocks$supply_block == "Nass TSA Block E"] <- "Block_E"
nass.tsa.supply.blocks$supply_block <- nass.tsa.supply.blocks$supply_block %>% replace_na ('null_block')

supply.blocks.vat <- as.data.table (unique (nass.tsa.supply.blocks$supply_block))
setnames (supply.blocks.vat, "supply_block") 
supply.blocks.vat [, value := seq_len(.N)]
nass.tsa.supply.blocks <- merge (nass.tsa.supply.blocks, supply.blocks.vat, by = "supply_block")

nass.tsa$tsa_value <- as.integer (1)
nass.tsa.vat <- as.data.table (unique (nass.tsa$tsa_name))
nass.tsa.vat [, value := seq_len(.N)]

#st_write (nass.tsa.supply.blocks,"nass_supply_blocks.shp")
# ogr2ogr -f PostgreSQL PG:"dbname=clus port=5432 user= password= host=" SCHEMA=comaprison_nass C:\Work\git\clus\R\Params\nass_supply_blocks.shp nass_supply_blocks  -a_srs EPSG:3005 -progress --config PG_USE_COPY YES -nlt PROMOTE_TO_MULTI -lco SCHEMA=comparison_nass

# Rasterize 
ras.nass.supply.blocks <-fasterize::fasterize (st_cast (nass.tsa.supply.blocks, "MULTIPOLYGON"), prov.rast, field = "value") 
ras.nass.all <-fasterize::fasterize (st_cast (nass.tsa, "MULTIPOLYGON"), prov.rast, field = "tsa_value") 

writeRaster (ras.nass.supply.blocks, "nass_supply_blocks.tif", overwrite = T)
writeRaster (ras.nass.all, "nass_all.tif", overwrite = T)

# write data
conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

setnames (supply.blocks.vat, c ("attribute", "value")) # Note use convention; always name these value and attribute
DBI::dbWriteTable(conn, c("comparison_nass", "vat_supply_blocks"), value = supply.blocks.vat, row.names = FALSE, overwrite = TRUE)
setnames (nass.tsa.vat, c ("attribute", "value")) # Note use convention; always name these value and attribute
DBI::dbWriteTable(conn, c("comparison_nass", "vat_tsa"), value = nass.tsa.vat, row.names = FALSE, overwrite = TRUE)

system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/Params/nass_supply_blocks.tif -t 100x100 comparison_nass.rast_supply_blocks | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/Params/nass_all.tif -t 100x100 comparison_nass.rast_tsa | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

dbDisconnect(conn)
```


## UWR

```{r uwr}
# only one conditional harvest UWR defined
# u-6-018
# For TSR, constraint is defined as 30% of productive forest area in zone >119 y.o.

# don't know what 'productive forest' is, so multiply that area by the UWR area and use total area in CLUS
prod.for <- raster::raster (paste0 (data.dir, "ProductiveForest.tif")) 
uwr <- raster::raster (paste0 (data.dir, "uwrZone.tif"))
uwr.prod <- uwr * prod.for
crs(uwr.prod) <- "+proj=aea +lat_0=45 +lon_0=-126 +lat_1=50 +lat_2=58.5 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs"
writeRaster(uwr.prod, file = "uwr_prod.tif", format = "GTiff", overwrite = TRUE)
system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/uwr_prod.tif -t 100x100 comparison_nass.rast_zone_uwr | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

#Create zone constraint table
zone_uwr <- data.table (zoneid = as.integer (0), type = 'ge', variable = 'age', threshold = as.numeric(119), reference_zone = 'comparison_nass.rast_zone_uwr', percentage = 30, ndt = as.integer (0), label = 'u-6-018', multi_condition = as.character (''), denom = as.character (''), start = as.integer (0), stop = as.integer (0))

conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

DBI::dbWriteTable(conn, c("comparison_nass", "zone_uwr"), value = zone_uwr, row.names = FALSE, overwrite = TRUE) 
dbExecute(conn, "ALTER TABLE comparison_nass.zone_uwr ALTER COLUMN denom TYPE VARCHAR;")
dbExecute (conn, paste0("ALTER TABLE comparison_nass.zone_uwr INHERIT comparison_nass.zone_constraints_nass"))

dbDisconnect(conn)

```
## VQO

```{r vqo}
# VQO's apply to productive forest and 'VQOold'

# vqoPvacL, vqoPvacM, vqoPvacH, vqoRvacL, vqoRvacM, vqoRvacH, vqoPRvacL, vqoPRvacM, vqoPRvacH, vqoMvacL, vqoMvacM, vqoMvacH



# don't know what 'productive forest' is, so multiply that area by the UWR area and use total area in CLUS
prod.for <- raster::raster (paste0 (data.dir, "ProductiveForest.tif")) 

```

