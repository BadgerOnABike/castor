---
title: "Central Group Partnership Agreement: Proposed Land Use Order Areas"
author: "Tyler Muhly"
date: "October 7, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(data.table)
library (here)
source (here ("R/functions/R_Postgres.R"))
library(tidyverse)
prov.rast <- raster::raster(
  nrows = 15744, ncols = 17216, xmn = 159587.5, xmx = 1881187.5, ymn = 173787.5, ymx = 1748187.5, 
  crs = st_crs(getSpatialQuery("Select * from bc_carib_poly_20090904 limit 1"))$proj4string, resolution = c(100, 100), vals = 0)
```

## Purpose
Here we develop rasters and constraint tables for proposed land use orders in the central group caribou herds. These areas and orders have been proposed to support caribou recovery planning and the partnership agreement.  

### Proposed Land Use Order Areas
The proposed areas were defined as: 
 - buffer areas within 40km of protected caribou habitat, including A2, B2, B3; and
 - areas that are within 40km of defined core caribou range (summer and winter) in the Narraway LPU.

As an alterantive scenario, it was proposed to use central group martix habitat instead of a 40 km buffer. 

In a GIS, we took the A2, B2 and B3 partnership agreement areas and buffered them by 40km. We then buffered the core Narraway critical habitat areas by 40km. We merged the partnership agreement areas, core critcal habitat, matrix habitat and buffered area into a single spatial dataset, where partnership agreement areas superseded core habtiat, which superseded matrix habtiat, which superseded the buffered area. Each of these 'zones' was maintained in the spatial data to allow for some flexibility in future analyses. 

### Proposed Land Use Order Constraint
The initial proposed constraint for all of these areas together is maximum 35% forest age less than 25 years old. As indicated above, we maintained seperate zones in case there becomes a desire to apply different consrtaints to each zone. Below are scripts to create spatial rasters that keep different configurations of these zones (i.e., all independent, all within the buffered area together, all within teh matrix area together). 

```{r, proposed LUO area, all areas}
luo_area <- getSpatialQuery("SELECT * from scenario_central_grp_proposed_luo;")

# zone integer
luo.vat <- data.table (st_drop_geometry (luo_area [, c ('zone')]))
luo.vat [, value:= seq_len(.N)] 
all_luo_area <- merge (luo_area, luo.vat, by.x = "zone", by.y = "zone")

# raster
ras.scenario_central_grp_proposed_luo <-fasterize::fasterize(all_luo_area, prov.rast, field = "value")
writeRaster(ras.scenario_central_grp_proposed_luo, "central_grp_proposed_luo.tif", overwrite = TRUE)
system ("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/central_grp_proposed_luo.tif -t 100x100 rast.central_grp_proposed_luo | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

#Create zone constraint table
zone_luo <- data.table (zoneid = 1:8, 
                        type = 'le', 
                        variable = 'age', 
                        threshold = 25, 
                        reference_zone = 'rast.central_grp_proposed_luo', 
                        percentage = 35, 
                        ndt = as.integer(0), 
                        multi_condition = '')

# commit tables to pg
conn <- DBI::dbConnect(dbDriver("PostgreSQL"), 
                       host=keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                       dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                       port='5432' ,
                       user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,
                       password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", "scenario_central_grp_proposed_luo_vat"), value= luo.vat, row.names = FALSE, overwrite = TRUE)
DBI::dbWriteTable(conn, c("public", "zone_scenario_central_grp_proposed_luo"), value= zone_luo, row.names = FALSE, overwrite = TRUE)
dbDisconnect(conn)

```

The following groups all zones together within the 40km buffer.
```{r, proposed LUO areas, all in buffer}
luo_area <- getSpatialQuery("SELECT * from scenario_central_grp_proposed_luo;")

# zone integer
luo.vat.40 <- luo.vat
luo.vat.40 [, value:= 1]   
luo_area_40 <- merge (luo_area, luo.vat.40, by.x = "zone", by.y = "zone") 

# raster
ras.scenario_central_grp_proposed_luo_buffer <-fasterize::fasterize (luo_area_40, prov.rast, field = "value") 
writeRaster(ras.scenario_central_grp_proposed_luo_buffer, "central_grp_proposed_luo_buffer.tif", overwrite = TRUE)
system ("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/central_grp_proposed_luo_buffer.tif -t 100x100 rast.central_grp_proposed_luo_buffer | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

#Create zone constraint table
zone_luo_buffer <- data.table (zoneid = 1, 
                                type = 'le', 
                                variable = 'age', 
                                threshold = 25, 
                                reference_zone = 'rast.central_grp_proposed_luo_buffer', 
                                percentage = 35, 
                                ndt = as.integer(0), 
                                multi_condition = '')

# commit tables to pg
conn <- DBI::dbConnect(dbDriver("PostgreSQL"), 
                       host=keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                       dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                       port='5432' ,
                       user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,
                       password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", "scenario_central_grp_proposed_luo_buffer_vat"), value= luo.vat.40, row.names = FALSE, overwrite = TRUE)
DBI::dbWriteTable(conn, c("public", "zone_scenario_central_grp_proposed_luo_buffer"), value= zone_luo_buffer, 
                          row.names = FALSE, overwrite = TRUE)
dbDisconnect(conn)

```

The following groups all zones together within the central group matrix habitat.
```{r, proposed LUO areas, all in matrix}
luo_area <- getSpatialQuery("SELECT * from scenario_central_grp_proposed_luo;")

# zone integer
luo.vat.matrix <- luo.vat
luo.vat.matrix <- luo.vat.matrix [ zone != 'buffer 40km']
luo.vat.matrix [, value:= 1]  
luo_area_matrix <- merge (luo_area, luo.vat.matrix, by.x = "zone", by.y = "zone") 

# raster
ras.scenario_central_grp_proposed_luo_matrix <-fasterize::fasterize (luo_area_matrix, prov.rast, field = "value") 
writeRaster(ras.scenario_central_grp_proposed_luo_matrix, "central_grp_proposed_luo_matrix.tif", overwrite = TRUE)

system ("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/central_grp_proposed_luo_matrix.tif -t 100x100 rast.central_grp_proposed_luo_matrix | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

#Create zone constraint table
zone_luo_matrix <- data.table (zoneid = 1, 
                                type = 'le', 
                                variable = 'age', 
                                threshold = 25, 
                                reference_zone = 'rast.central_grp_proposed_luo_matrix', 
                                percentage = 35, 
                                ndt = as.integer(0), 
                                multi_condition = '')

# commit tables to pg
conn <- DBI::dbConnect(dbDriver("PostgreSQL"), 
                       host=keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                       dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                       port='5432' ,
                       user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,
                       password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", "scenario_central_grp_proposed_luo_matrix_vat"), value= luo.vat.matrix, row.names = FALSE, overwrite = TRUE)
DBI::dbWriteTable(conn, c("public", "zone_scenario_central_grp_proposed_luo_matrix"), value= zone_luo_matrix, 
                          row.names = FALSE, overwrite = TRUE)
dbDisconnect(conn)

```






#UPDATE SCENARIO
- see belwo exmaple if need to update contraints
```{r, zone_update}
#STEP 1: Connect to the clusdb.sqlite database for the AOI
clusdb <- dbConnect(RSQLite::SQLite(), dbname = paste0(here::here(), "/R/SpaDES-modules/dataLoaderCLUS/Prince_George_TSA_clusdb.sqlite")) # connext to clusdb -- set the locations of the sqlite

#STEP 2: View the constraints available to a zone
zoneconstraints<-dbGetQuery(clusdb, "SELECT * from zoneConstraints") # Note: the reference_zone is the name of the raster in the rast schema. If there is no 'WHERE' clause this may return 1000's of zones

#STEP 3: Update the constraints available to a zone as specified in the scenario
dbExecute(clusdb, "UPDATE zoneconstraints set type = 'nh' where reference_zone = 'rast.zone_cond_partnership_agreement'") #This example will set all the zones in the partnership agreement to no harvest

#dbExecute(clusdb, "UPDATE zoneconstraints set percentage = 85 where reference_zone = 'rast.zone_cond_partnership_agreement' and percentage = 65")
#This example will set the zones in the partnership agreement that have constraints on the variable 'dist' to a 85% disturbance threshold

#STEP 4: Remove the connection to the database
dbDisconnect(clusdb)
```
