---
title: "fire_occurrence"
output: html_document
date: '2023-09-11'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source(here::here("R/functions/R_Postgres.R"))
library(data.table)
library(sf)
library(tidyverse)
```

In this script we model the occurrence of lightning cause wildfires. This includes the number of fires and where they occur. to do this we rely on the historical incidents data reported in the data catalog of BC. The number of fires within a 10 km grid are estimated along with various predictor variables that relate to landcover and climate.The landcover data comes from the VRI using the previous year of the fire as the estimate of the amount of landcover types within the 10 km voxel.

## Model
```{r}
data.lightning<-readRDS("data.lightning.rds")
library(glmmTMB)
library(DHARMa)
test<-data.lightning[flam.layer >0,][!is.na(CMI3yr),][,dCMI3yr:=CMI - CMI3yr][, coast:=0][frt==15, coast:=1][is.na(dec.layer), dec.layer:=0][is.na(mixed.layer), mixed.layer:=0][is.na(open.layer), open.layer:=0]

l12_nb_3yr <- glmmTMB(count ~ 1 + CMI + CMI3yr + (frt|FIRE_YEAR), offset = log(flam.layer), family = nbinom2, ziformula = ~0, data=test)

simulationOutput <- simulateResiduals(fittedModel = l12_nb_3yr)
plot(simulationOutput)

test$pred_mu<-data.table(mu= predict(l12_nb_3yr, newdata = test[, c("flam.layer", "CMI", "CMI3yr")][,FIRE_YEAR := NA][,frt := NA], type="response"))
ggplot2::ggplot(data=test[ FIRE_YEAR %in% c( 2012, 2016, 2017, 2018, 2020, 2022)], aes(x=x, y=y, color = pred_mu)) + facet_wrap(~FIRE_YEAR) + geom_point()
test[, sim:= rnbinom(n = 1, size = 0.251, mu =pred_mu )]
 
sim1=simulate(l12_nb_3yr, nsim = 1)
Simdat=test[!is.na(CMI3yr),]
Simdat$count=sim1[[1]]
Simdat=transform(Simdat,  
            type="simulated")
test$type = "observed"  
Dat=rbind(test[!is.na(CMI3yr),], Simdat) 
ggplot(Dat[, sum(count), by = c("FIRE_YEAR", "type")],  aes(x=FIRE_YEAR, y =V1, colour=type))+geom_line()
ggplot(Dat,  aes(x=CMI, y =as.factor(count), colour=type))+geom_boxplot() + facet_grid(~type)

library(sdmTMB)
spde <- make_mesh(test[!is.na(CMI3yr),c("x", "y")], xy_cols = c("x", "y"), cutoff = 10)

m0 <- sdmTMB(data = test, count ~ 1 + CMI + CMI3yr , offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR",  mesh = spde, spatial = FALSE, spatiotemporal = FALSE, reml=T)

m1 <- sdmTMB(data = test, count ~ 1 + CMI + dCMI3yr , offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR",  mesh = spde, spatial = T, spatiotemporal = FALSE, reml=T)

m2 <- sdmTMB(data = test, count ~ 1 + CMI + dCMI3yr + as.factor(coast) , offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR",  mesh = spde, spatial = T, spatiotemporal = FALSE)
# Adding FRT was only signifcant for the coast so made a indicator variable for the coast vs other.
#m2a <- sdmTMB(data = test[frt!=15,], count ~ 1 + CMI + dCMI3yr + as.factor(frt), offset = log(test[frt!=15,]$flam.layer), family = nbinom2(), time = "FIRE_YEAR",  mesh = spde2, spatial = T, spatiotemporal = FALSE)

#m2b <- sdmTMB(data = test[frt!=15,], count ~ 1 + CMI + dCMI3yr , offset = log(test[frt!=15,]$flam.layer), family = nbinom2(), time = "FIRE_YEAR",  mesh = spde2, spatial = T, spatiotemporal = FALSE)

##Vegetation typing
test<-test[,conif:=c1.layer + c2.layer + c3.layer+ c4.layer+c5.layer+ c7.layer][,lconif:=log(conif+1)]

m3 <- sdmTMB(count ~ 1 + CMI + dCMI3yr + as.factor(coast) + log(dec.layer+1) + log(slash.layer +1)+ +log(mixed.layer +1) + lconif, offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR", data = test, mesh = spde, spatial = T, spatiotemporal = FALSE)

m4 <- sdmTMB(count ~ 1 + CMI + dCMI3yr + as.factor(coast) + lconif, offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR", data = test, mesh = spde, spatial = T, spatiotemporal = FALSE)

m5 <- sdmTMB(count ~ 1 + CMI + dCMI3yr + as.factor(ndt) + lconif, offset = log(test$flam.layer), family = nbinom2(), time = "FIRE_YEAR", data = test[!is.na(ndt),], mesh = spde, spatial = T, spatiotemporal = FALSE)

saveRDS(m4, "C:/Users/klochhea/castor/R/fire_sim/number_of_ignitions/m4.rds")

```


## Diagnostics
```{r}
test$resids <- residuals(m4) # randomized quantile residuals
qqnorm(test$resids)
qqline(test$resids)

sim1<-simulate(m4, nsim=500)
#sim1<-simulate(m4, nsim=1000)
Simdat<-test
simdata<-rbindlist(lapply(seq(1,500,1), function(rep_sim){
  Simdat$count<-sim1[,rep_sim]
  Simdat=transform(Simdat,  
            type=paste0("simulated_rep",rep_sim))
}))

test$type = "observed"  
Dat=rbind(test, simdata) 
data_sim_ag<-Dat[, sum(count), by = c("FIRE_YEAR", "type", "coast")]
#data_sim_ag[type != 'observed', type := 'simulated']
ggplot()+
  geom_boxplot(data=data_sim_ag[type != 'observed'],  aes(x=as.factor(FIRE_YEAR), y =V1)) +
  geom_point(data=data_sim_ag[type == 'observed'],  aes(x=as.factor(FIRE_YEAR), y =V1, color = 'red')) +
  facet_wrap(~coast, scales = "free")

ggplot(Dat,  aes(x=CMI, y =as.factor(count), colour=type))+geom_boxplot() + facet_grid(~type)


data.count.pred<-predict(m4 )
data.count.pred$est2<-exp(data.count.pred$est + log(data.count.pred$flam.layer))

number<-data.count.pred[, .(nfires = sum(count)), by = 'FIRE_YEAR']
test_fo<-merge(data.count.pred[,.(pred = sum(est2)), by = "FIRE_YEAR"], number, by = "FIRE_YEAR")

ggplot2::ggplot(data=test_fo, aes(x = pred, y = nfires)) + geom_point() + geom_smooth(method = "lm", se = T) + geom_abline(slope=1, intercept=0, col = 'black')

nd <- data.frame(
    dCMI3yr = seq(min(test$dCMI3yr), 
      max(test$dCMI3yr), length.out = 100),  
    lconif = mean(test$lconif), CMI = mean(test$CMI), mixed.layer = mean(test$mixed.layer),
    FIRE_YEAR = 2020, coast =0, flam.layer = 1, x = mean(test$x), y = mean(test$y))

p <- predict(m4, newdata = nd, se_fit = T, re_form = T)
p$est2<- -15.4-0.0738*p$CMI -0.211*p$dCMI3yr -1.11*p$coast +0.228*p$lconif

ggplot(p, aes(dCMI3yr, exp(est), 
              ymin = exp(est - 1.96 * est_se), 
              ymax = exp(est + 1.96 * est_se))) +
    geom_line() + geom_ribbon(alpha = 0.4)


```


#### APPENDIX: Gaussian Markov Random Fields
```{r}
#Some functions to use later
# Matern correlation
cMatern <- function(h, nu, kappa) {
  ifelse(h > 0, besselK(h * kappa, nu) * (h * kappa)^nu / 
    (gamma(nu) * 2^(nu - 1)), 1)
}

#create some data such that its a single line of 250 points each 1/25 away from each other
loc <- 0:249 / 25 
#Calculate the adjacency matrix
mdist <- as.matrix(dist(loc))
d <- dim(goshawkNestingHabitat)
mdist <-as.matrix(dist(matrix(values(goshawkNestingHabitat,), d[1], d[2], byrow=TRUE)))

#parameters to show sensitivity
nu <- c(0.5, 1, 2.5, 3, 4.5)
range <- c(1,2,3,4)
params <- cbind(nu = rep(nu, length(range)), range = rep(range, each = length(nu)))

# Sample error five times - white noise gaussian standard normal ~ N(0, 1)
set.seed(123)
z <- matrix(rnorm(nrow(mdist) * 5), ncol = 5)

# Compute the correlated samples
# Scenarios (i.e., different set of parameters)
yy <- lapply(1:nrow(params), function(j) { 
  param <- c(params[j, 1], sqrt(8 * params[j, 1]) / params[j, 2], 
    params[j, 2])
  v <- cMatern(mdist, param[1], param[2])

  # fix the diagonal to avoid numerical issues
  diag(v) <- 1 + 1e-9 

  # Parameter scenario and computed sample
  return(list(params = param, y = crossprod(chol(v), z)))
})

#Conclusion: the nu parameter adds inflections, the range parameter add smoothness
```
