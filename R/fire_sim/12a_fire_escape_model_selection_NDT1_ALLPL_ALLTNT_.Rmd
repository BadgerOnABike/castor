---
title: "12a_fire_escape_model_selection_NDT1_ALLPL_ALLTNT"
author: "Cora Skaien"
date: "27/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Load relevant libraries
library(sf)
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
library(RPostgreSQL)
library(rpostgis)
library(dplyr)
library(lme4)
library(arm)
library(ggpubr)
library(mgcv)
library(nlme)
library(purrr)
library(tidyr)
library(caret)
library(pROC)
library(keyring)
library(ggcorrplot) 
library(kableExtra)
library(data.table)
library(DBI)
library(here)
library(AICcmodavg)
library(rje)
library(base)
library(car)
library(visreg)

source(here::here("R/functions/R_Postgres.R"))
```

<!--
Copyright 2021 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->

#=================================
#  Script Name: 12a_fire_escape_model_selection_NDT1_ALLPL_ALLTNT.R
#  Script Version: 1.0
#  Script Purpose: Model selection for escape by NDT.
#  Script Author: Cora Skaien, Ecological Modeling Specialist, Forest Analysis and Inventory Branch, B.C. Ministry of Forests, Lands, and Natural Resource Operations.
#=================================

Load in the prepped data.

```{r}
Escape_data_ALL <- st_read("C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\data\\Fire_escape_data_all2.gpkg")
head(Escape_data_ALL)

table(is.na(Escape_data_ALL$Cluster)) # wierd there are 13 points that have no Cluster assigned to them. I looked at these points in Qgis and all but one of them are in FRT =15.
Escape_data_ALL$Cluster[Escape_data_ALL$idno==238]<-13
Escape_data_ALL$Cluster[is.na(Escape_data_ALL$Cluster)]<-15

Escape_data_ALL$Cluster[Escape_data_ALL$Cluster==3]<-5
 table(Escape_data_ALL$Cluster)
 
Escape_data_ALL$mean_PPT04_PPT05_PPT06<-(Escape_data_ALL$PPT04 + Escape_data_ALL$PPT05 + Escape_data_ALL$PPT06)/3
Escape_data_ALL$mean_PPT05_PPT06_PPT07_PPT08  <-(Escape_data_ALL$PPT05 + Escape_data_ALL$PPT06 + Escape_data_ALL$PPT07 + Escape_data_ALL$PPT08)/4
Escape_data_ALL$mean_Tave05_Tave06_Tave07_Tave08<-(Escape_data_ALL$Tave05 + Escape_data_ALL$Tave06 + Escape_data_ALL$Tave07 + Escape_data_ALL$Tave08)/4
Escape_data_ALL$mean_Tave04_Tave05_Tave06<-(Escape_data_ALL$Tave04 + Escape_data_ALL$Tave05 + Escape_data_ALL$Tave06)/3

## Create empty vector
Escape_data_ALL$climate1<-0
head(Escape_data_ALL)

Escape_data_ALL$Cluster_numeric<-as.numeric(as.character(Escape_data_ALL$Cluster))

Escape_data_ALL<-Escape_data_ALL %>%
    mutate(climate1 = case_when(Cluster_numeric == 5 ~ PPT05, 
                                Cluster_numeric == 7 ~ temp_mnthbefore, 
                                Cluster_numeric == 9 ~ Tave05, 
                                Cluster_numeric == 10 ~ mean_Tave05_Tave06_Tave07_Tave08,
                                Cluster_numeric == 11 ~ Tave09, 
                                Cluster_numeric == 12 ~ mean_Tave04_Tave05_Tave06,
                                Cluster_numeric == 13 ~ Tmax09,
                                Cluster_numeric == 14 ~ temp_atfire,
                                Cluster_numeric == 15 ~ Tave04,
                                TRUE ~ NA_real_))

#Repeat for climate 2
Escape_data_ALL$climate2<-0

#Perform mutate to get the applicable variable for each row
Escape_data_ALL<-Escape_data_ALL %>%
    mutate(climate2 = case_when(Cluster_numeric == 7 ~ ppt_mnthbefore,
                                Cluster_numeric == 10 ~ mean_PPT05_PPT06_PPT07_PPT08,
                                Cluster_numeric == 12 ~ mean_PPT04_PPT05_PPT06,
                                Cluster_numeric == 14 ~ ppt_atfire,
                                Cluster_numeric == 15 ~ PPT04,TRUE ~ NA_real_))

head(Escape_data_ALL)


```

################ PART 1: Initial Model Selection for Subset Variables ################

We will make a loop that does something very similar to our last loop, but with the selected climate variable plus other variables of interest. For lightning caused fires with trees, the variables of interest include:

1. Climate variable(s) (PPT05 = climate1); note, also can use temperature at time of fire and precipitation at time of fire for escape (not for ignition because areas without a fire do not have a one month value)
2. slope
3. elevation
4. dist_infra (Distance to nearest infrastructure)
5. rd_dst_ (Distance to nearest road)
6. windspeed (wind_atfire)
7. Fire cause (fire_cs)
8. FWI_veg

Interactions of interest: two-way interactions between climate (1) and vegtype (5). 

##We will do each loop separately for each FRT zone given the large number of possible models for each zone.

First we will create the variable lists that contain all of our variables of interest.

```{r}
##Create variable lists to be used in the model loop.
variables_all<-c(climate1 = "climate1", climate2 = "climate2", slope = "slope", elevatn ="elevatn", infr_ds = "infr_ds", rd_dst_ = "rd_dst_", wind_atfire = "wind_atfire", tmax_2mtns = "tmax_2mtns", ppt_2mtns = "ppt_2mtns", FWI_veg = "FWI_veg", fire_cs ="fire_cs") 

vars.clim.vegtype2<-c("climate1", "FWI_veg")
vars.clim.vegtype2b<-c("climate1", "climate2", "FWI_veg")
vars.topo<-c("slope", "elevatn", "wind_atfire")
vars.infra<-c("infr_ds", "rd_dst_")
vars.oth2<-c("wind_atfire", "tmax_2mtns", "ppt_2mtns")


##Create interaction for climate and vegtype
inputs.me2 <- c(vars.clim.vegtype2)
inputs.me2b <- c(vars.clim.vegtype2b)
```

Now, we will generate two-way interactions for each of these lists. 

```{r}
#####1a. For those with two climate variables and vegtype
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints2 <- NULL
for (i in 1:(length(inputs.me2)-1)) {
  for (j in (i+1):length(inputs.me2)) {
     twoway.ints2 <- cbind(twoway.ints2, paste(inputs.me2[i], inputs.me2[j], sep=":"))
  }
}
twoway.ints2
length(twoway.ints2) #6

#Get variables on own
#complete list of models using non-climate vars
mods.me.tmp <- powerSet(vars.clim.vegtype2) 
#add climate vars to all of the above
mods.me.climate2 <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate2[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.climate2
mods.me.climate2<-mods.me.climate2[-1] #n = 15

#complete list of two-way interactions
mods.twoway2 <- powerSet(twoway.ints2)
length(mods.twoway2) #64
mods.twoway2[1]
mods.twoway2<-mods.twoway2[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added
mods.inter2 <- list()
counter <- 0
for (i in 1: length(mods.twoway2)) {
   s1 <- unique(unlist( strsplit(mods.twoway2[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.climate2)) {
      if (all(s1 %in% mods.me.climate2[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.climate2[[j]], mods.twoway2[[i]])
        mods.inter2[[counter]] <- both
      }
   }
}

length(mods.inter2) #97
#mods.inter2
mods.inter2


####1c. Climate variables but no vegtype
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints2b <- NULL
for (i in 1:(length(inputs.me2b)-1)) {
  for (j in (i+1):length(inputs.me2b)) {
     twoway.ints2b <- cbind(twoway.ints2b, paste(inputs.me2b[i], inputs.me2b[j], sep=":"))
  }
}
twoway.ints2b
length(twoway.ints2b) #3

#Get variables on own
#complete list of models using non-climate vars
mods.me.tmp <- powerSet(vars.clim.vegtype2b) 
#add climate vars to all of the above
mods.me.climate2b <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate2b[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.climate2b
mods.me.climate2b<-mods.me.climate2b[-1]

#complete list of two-way interactions
mods.twoway2b <- powerSet(twoway.ints2b)
length(mods.twoway2b) #8
mods.twoway2b
mods.twoway2b<-mods.twoway2b[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added
mods.inter2b <- list()
counter <- 0
for (i in 1: length(mods.twoway2b)) {
   s1 <- unique(unlist( strsplit(mods.twoway2b[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.climate2b)) {
      if (all(s1 %in% mods.me.climate2b[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.climate2b[[j]], mods.twoway2b[[i]])
        mods.inter2b[[counter]] <- both
      }
   }
}

length(mods.inter2b) #10
mods.inter2b
```


```{r}
#########2. Now for topography data, get all possible two-way interactions

#get the names of all possible two-way interactions
twoway.intsT <- NULL
for (i in 1:(length(vars.topo)-1)) {
  for (j in (i+1):length(vars.topo)) {
     twoway.intsT <- cbind(twoway.intsT, paste(vars.topo[i], vars.topo[j], sep=":"))
  }
}
twoway.intsT
length(twoway.intsT) #6


#complete list of models using non-climate vars (topo)
mods.me.tmp <- powerSet(vars.topo) 
#add climate vars to all of the above
mods.meT <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.meT[[i]] <- c(mods.me.tmp[[i]])
}

mods.meT
mods.meT<-mods.meT[-1]

#complete list of two-way interactions
mods.twowayT <- powerSet(twoway.intsT)
length(mods.twowayT) #32
mods.twowayT
mods.twowayT<-mods.twowayT[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added

mods.interT <- list()
counter <- 0
for (i in 1: length(mods.twowayT)) {
   s1 <- unique(unlist( strsplit(mods.twowayT[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meT)) {
      if (all(s1 %in% mods.meT[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.meT[[j]], mods.twowayT[[i]])
        mods.interT[[counter]] <- both
      }
   }
}

length(mods.interT) #56
#mods.interT
```


```{r}
#########4. Now for distance to infrastructure data, get all possible two-way interactions

#get the names of all possible two-way interactions
twoway.intsI <- NULL
for (i in 1:(length(vars.infra)-1)) {
  for (j in (i+1):length(vars.infra)) {
     twoway.intsI <- cbind(twoway.intsI, paste(vars.infra[i], vars.infra[j], sep=":"))
  }
}
twoway.intsI
length(twoway.intsI) #1

#complete list of models using non-climate vars (infra)
mods.me.tmp <- powerSet(vars.infra) 
#add climate vars to all of the above
mods.meI <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.meI[[i]] <- c(mods.me.tmp[[i]])
}

mods.meI
mods.meI<-mods.meI[-1]

#complete list of two-way interactions
mods.twowayI <- powerSet(twoway.intsI)
length(mods.twowayI) #2
#mods.twowayI

#Finding models in mods.me that accommodate/allow interaction terms 

mods.interI <- list()
counter <- 0
for (i in 1: length(mods.twowayI)) {
   s1 <- unique(unlist( strsplit(mods.twowayI[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meI)) {
      if (all(s1 %in% mods.meI[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.meI[[j]], mods.twowayI[[i]])
        mods.interI[[counter]] <- both
      }
   }
}

length(mods.interI) #4
mods.interI
```


```{r}
########5. Lastly for last list of other variables
#get the names of all possible two-way interactions
twoway.ints.O2 <- NULL
for (i in 1:(length(vars.oth2)-1)) {
  for (j in (i+1):length(vars.oth2)) {
     twoway.ints.O2 <- cbind(twoway.ints.O2, paste(vars.oth2[i], vars.oth2[j], sep=":"))
  }
}
twoway.ints.O2
length(twoway.ints.O2) #1

#complete list of models using non-climate vars (infra)
mods.me.tmp <- powerSet(vars.oth2) 
#add climate vars to all of the above
mods.me.O2 <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.O2[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.O2
mods.me.O2<-mods.me.O2[-1]

#complete list of two-way interactions
mods.twoway.O2 <- powerSet(twoway.ints.O2)
length(mods.twoway.O2) #2
mods.twoway.O2

#Finding models in mods.me that accommodate/allow interaction terms 
mods.inter.O2 <- list()
counter <- 0
for (i in 1: length(mods.twoway.O2)) {
   s1 <- unique(unlist( strsplit(mods.twoway.O2[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meI)) {
      if (all(s1 %in% mods.me.O2[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.O2[[j]], mods.twoway.O2[[i]])
        mods.inter.O2[[counter]] <- both
      }
   }
}

length(mods.inter.O2) #4
mods.inter.O2
```

Determine final models for testing.

```{r}
all.poss.mods.clim.vegtype2<-c(1, mods.me.climate2, mods.inter2)
all.poss.mods.clim.vegtype2 #113

all.poss.mods.clim.vegtype2b<-c(1, mods.me.climate2b, mods.inter2b)
all.poss.mods.clim.vegtype2b #18

all.poss.mods.topo<-c(1, mods.interT)
all.poss.mods.topo

all.poss.mods.infra<-c(1, mods.interI) 
all.poss.mods.infra

all.poss.mods.Oth2<-c(1, mods.inter.O2) 
all.poss.mods.Oth2
```


```{r}
#If need to determine which ones are character(0), try this:
biglist <- list(list("A","B","C"), "foo", "", character(0), integer(0))
lapply(biglist, function(x) {length(x) == 0L} ) 


##Check and rid of any duplicated models
duplicated(all.poss.mods.clim.vegtype2)
duplicated(all.poss.mods.clim.vegtype2b)
duplicated(all.poss.mods.topo)
duplicated(all.poss.mods.infra)
duplicated(all.poss.mods.Oth2)

```

Because of the large number of models with all variables included, we will test the climate and vegtype first, then the VRI variables, then the topography variables. Then we will test the top models together in additional combinations, with determining best AIC model from there. 


# climate1 and FWI_veg
```{r}
zones1<-c(5, 9, 11, 13) #Do one zone at a time
prop<-0.75
Escape_data_ALL$veg_escape<-paste(Escape_data_ALL$escape10, Escape_data_ALL$FWI_veg)

Escape_data_ALL2<-st_drop_geometry(Escape_data_ALL)

```

```{r}
###########  Climate Veg ############
#Create empty table
table.glm.climate.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.climate.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

####
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_ALL2 %>% dplyr::filter(Cluster ==zones1[h])

#for (i in 1: length(zones1)){
  print(paste((zones1[h]), g, sep=" -- "))
  
  model_dat<- dat2 %>% dplyr::select(escape10, veg_escape, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$veg_escape, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape10") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim$FRT<-zones1[h]
tab.sum.clim 

table.glm.climate.simple<-rbind(table.glm.climate.simple, tab.sum.clim)

}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.climate.simple)
table(table.glm.climate.simple$model) # 100 per model or 100 x number for FRT's

AIC_all_NDT1_escape_VRI<-table.glm.climate.simple

AIC_all_escape_summary_VRI<- AIC_all_NDT1_escape_VRI %>%
  group_by(FRT, model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid)) %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
            

head(AIC_all_escape_summary_VRI)

write.csv(AIC_all_escape_summary_VRI, "C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\tmp\\escape_climate_veg_models.csv")
```

#Now repeat for topography

```{r}
########### 2. all.poss.mods.clim.vegtype2b ############
#Create empty table
zones1<-c(7, 10, 12, 14, 15) #Do one zone at a time

table.glm.climate.simple2 <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.climate.simple2) <- c ("model", "edf", "aic", "auc.valid", "FRT")

####
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_ALL2 %>% dplyr::filter(Cluster ==zones1[h])

#for (i in 1: length(zones1)){
  print(paste((zones1[h]), g, sep=" -- "))
  
  model_dat<- dat2 %>% dplyr::select(escape10, veg_escape, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$veg_escape, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape10") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2b, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim$FRT<-zones1[h]
tab.sum.clim 

table.glm.climate.simple2<-rbind(table.glm.climate.simple2, tab.sum.clim)

}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.climate.simple2)
table(table.glm.climate.simple2$model) # 100 per model or 100 x number for FRT's

AIC_all_NDT1_escape_VRI<-table.glm.climate.simple2

AIC_all_escape_summary_VRI<- AIC_all_NDT1_escape_VRI %>%
  group_by(FRT, model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid)) %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
            

head(AIC_all_escape_summary_VRI)

write.csv(AIC_all_escape_summary_VRI, "C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\tmp\\escape_climate1_climate2_veg_models.csv")
```

#Now repeat for infrastructure

```{r}
########### 4. Distance to Infrastructure ############
#Create empty table
zones1<-c(5, 7, 9, 10, 11, 12, 13, 14, 15) #Do one zone at a time

table.glm.infra.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.infra.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

####
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_ALL2 %>% dplyr::filter(Cluster ==zones1[h])

#for (i in 1: length(zones1)){
  print(paste((zones1[h]), g, sep=" -- "))
  
  model_dat<- dat2 %>% dplyr::select(escape10, veg_escape, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$veg_escape, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape10") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.infra, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim$FRT<-zones1[h]
tab.sum.clim 

table.glm.infra.simple<-rbind(table.glm.infra.simple, tab.sum.clim)

}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.infra.simple)
table(table.glm.infra.simple$model) # 100 per model

AIC_all_NDT1_escape_infra<-table.glm.infra.simple

AIC_all_escape_summary_VRI<- AIC_all_NDT1_escape_infra %>%
  group_by(FRT, model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid)) %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
            

head(AIC_all_escape_summary_VRI)

write.csv(AIC_all_escape_summary_VRI, "C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\tmp\\escape_infra_road_dist_models.csv")
```

#Now repeat for topo

```{r}
########### 5. topo ############
#Create empty table
zones1<-c(5, 7, 9, 10, 11, 12, 13, 14, 15) #Do one zone at a time

table.glm.Tdif_wind.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.Tdif_wind.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

#
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_ALL2 %>% dplyr::filter(Cluster ==zones1[h])

#for (i in 1: length(zones1)){
  print(paste((zones1[h]), g, sep=" -- "))
  
  model_dat<- dat2 %>% dplyr::select(escape10, veg_escape, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$veg_escape, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape10") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim$FRT<-zones1[h]
tab.sum.clim 

table.glm.Tdif_wind.simple<-rbind(table.glm.Tdif_wind.simplez, tab.sum.clim)

}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.Tdif_wind.simple)
table(table.glm.Tdif_wind.simple$model) # 100 per model

AIC_all_NDT1_escape_t2dif_wind<-table.glm.Tdif_wind.simple

AIC_all_escape_summary_VRI<- AIC_all_NDT1_escape_t2dif_wind %>%
  group_by(FRT, model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid)) %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
            

head(AIC_all_escape_summary_VRI)

write.csv(AIC_all_escape_summary_VRI, "C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\tmp\\escape_topo_models.csv")

```

#Now repeat for topo

```{r}
########### 5. wind, temp and precip ############
#Create empty table
zones1<-c(5, 7, 9, 10, 11, 12, 13, 14, 15) #Do one zone at a time

table.glm.Temp_precip_wind.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.Temp_precip_wind.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

#
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_ALL2 %>% dplyr::filter(Cluster ==zones1[h])

#for (i in 1: length(zones1)){
  print(paste((zones1[h]), g, sep=" -- "))
  
  model_dat<- dat2 %>% dplyr::select(escape10, veg_escape, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$veg_escape, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape10") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.Oth2, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim$FRT<-zones1[h]
tab.sum.clim 

table.glm.Temp_precip_wind.simple<-rbind(table.glm.Temp_precip_wind.simple, tab.sum.clim)

}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.Temp_precip_wind.simple)
table(table.glm.Temp_precip_wind.simple$model) # 100 per model

AIC_all_NDT1_escape_t2dif_wind<-table.glm.Temp_precip_wind.simple

AIC_all_escape_summary_VRI<- AIC_all_NDT1_escape_t2dif_wind %>%
  group_by(FRT, model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid)) %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
            

head(AIC_all_escape_summary_VRI)

write.csv(AIC_all_escape_summary_VRI, "C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\tmp\\escape_temp_precip_wind_models.csv")

```


#Now combine the datatables and save to computer

```{r}
NDT1_all_models<-rbind(AIC_all_NDT1_escape_summary_climate2, AIC_all_NDT1_escape_summary_VRI2, AIC_all_NDT1_escape_summary_topo2, AIC_all_NDT1_escape_summary_infra2, AIC_all_NDT1_escape_summary_Tdif_wind2)
NDT1_all_models
NDT1_all_models$NDT<-"NDT1"

write.csv(NDT1_all_models, file="D:\\Fire\\fire_data\\raw_data\\NDT1_ALL_models_escape.csv")
```


################################ STAGE TWO ########################

#STAGE TWO: PUT TOGETHER MORE VARIABLES AND MANUALLY ASSESS
Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are. From the top models, we will re-create two-way interactions for the variables selected from each model, plus the other variables listed as needed to be included. We will assess each set to ensure only interactions that make sense are investigated ultimately, given that sample sizes will be an issues.

Top Variables common to most:
1. climate1 + climate2 + vegtype2
2. Slope + elevation + wind_atfire
3. Road dist

Additional Variables:
1. fire_cs (whether fire was lightning or person caused, or unknown)


#Next investigation
Because there would be far too many models to investigate including all variables and their interactions, we will start with the above and make educated guesses for what may need to be enhanced. We will seek the best model from the above informed progress.


#### FRT 5
```{r}
# top models fro FRT 5:
#climate1 + FWI_veg	
# slope + elevatn + slope:elevatn
# rd_dst_	
# wind_atfire

escape_frt5<- Escape_data_ALL2 %>% filter(Cluster==5)

table(is.na(escape_frt5$climate1))
table(is.na(escape_frt5$elevatn))
table(is.na(escape_frt5$FWI_veg))
table(is.na(escape_frt5$wind_atfire))
table(is.na(escape_frt5$rd_dst_))
table(is.na(escape_frt5$slope))
table(is.na(escape_frt5$fire_cs))
table(is.na(escape_frt5$escape10))

#Divide data into training and valid
prop<-0.75
  trainIndex <- createDataPartition(escape_frt5$veg_escape , p = prop,
                                    list = FALSE,
                                    times = 1)
   dat1 <- escape_frt5[ trainIndex,]
   Valid <- escape_frt5[-trainIndex,]

#Run model using dat1
model_ft5<-glm(escape10 ~ climate1 + FWI_veg + slope + elevatn + rd_dst_ + wind_atfire + slope:elevatn + fire_cs, family = binomial, data = dat1)

AIC(model_ft5) #908.6828

#Determine AUC of full model
mod.valid <- predict.glm(model_ft5, newdata=Valid, type="response")
   roc_obj1 <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj1)
   mod.auc #0.7059
   
Anova(model_ft5, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
#Anova(model.NDT1.E, type=3, singular.ok = TRUE)

#Remove least significant interaction
model_ft5b<-glm(escape10 ~ climate1 + FWI_veg + slope + elevatn + rd_dst_ + wind_atfire + fire_cs, family = binomial, data = dat1)

AIC(model_ft5b) #908.4004

#Determine AUC of full model
mod.valid <- predict.glm(model_ft5b, newdata=Valid, type="response")
   roc_obj2 <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj2)
   mod.auc #0.7114 
   
Anova(model_ft5b, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
#Anova(model.NDT1.E, type=3, singular.ok = TRUE)

#Remove least term
model_ft5c<-glm(escape10 ~ climate1 + FWI_veg + elevatn + rd_dst_ + wind_atfire + fire_cs, family = binomial, data = dat1)

AIC(model_ft5c) #906.4297

#Determine AUC of full model
mod.valid <- predict.glm(model_ft5c, newdata=Valid, type="response")
   roc_obj3 <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj3)
   mod.auc #0.7115 --> almost good
   
Anova(model_ft5c, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
#Anova(model.NDT1.E, type=3, singular.ok = TRUE)

#Remove least term
model_ft5d<-glm(escape10 ~ climate1 + FWI_veg + elevatn + rd_dst_ + fire_cs, family = binomial, data = dat1)

AIC(model_ft5d) #905.2707

#Determine AUC of full model
mod.valid <- predict.glm(model_ft5d, newdata=Valid, type="response")
   roc_obj4 <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj4)
   mod.auc #0.7127 --> almost good
   
Anova(model_ft5d, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
#Anova(model.NDT1.E, type=3, singular.ok = TRUE)

#Remove least term -> Nope stop one above is best!
model_ft5e<-glm(escape10 ~ climate1 + FWI_veg + elevatn + rd_dst_, family = binomial, data = dat1)

AIC(model_ft5e) #907.2665

#Determine AUC of full model
mod.valid <- predict.glm(model_ft5e, newdata=Valid, type="response")
   roc_obj5 <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj5)
   mod.auc #0.7053 --> almost good
   
Anova(model_ft5e, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
#Anova(model.NDT1.E, type=3, singular.ok = TRUE)

plot(roc_obj1, col="red")
plot(roc_obj2, col="blue", add=TRUE)
plot(roc_obj3, col="green", add=TRUE)
plot(roc_obj4, col="purple", add=TRUE)
#plot(roc_obj5, col="orange", add=TRUE)


#######################
### TOP MODEL
#######################
model_ft5d<-glm(escape10 ~ climate1 + as.factor(FWI_veg) + elevatn + rd_dst_ + as.factor(fire_cs), family = binomial, data = escape_frt5)

mod.valid <- predict.glm(model_ft5d, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape10"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.7283 

hist(escape_frt5$climate1)
hist(escape_frt5$elevatn)
hist(escape_frt5$rd_dst_)

table(escape_frt5$escape10) #0 = 948 and 1 = 267 not bad actually.
table(escape_frt5$FWI_veg)
```



```{r}


# model diagnostic plots
binnedplot (fitted(model_ft5d), 
            residuals(model_ft5d), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


escape_frt5$resids<-resid(model_ft5d)

binnedplot (escape_frt5$climate1, 
            escape_frt5$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (escape_frt5$elevatn, 
            escape_frt5$resids,  
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))
binnedplot (escape_frt5$rd_dst_, 
            escape_frt5$resids,  
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
library(visreg)
visreg(model_ft5d)
visreg(model.NDT1.E, "climate1", by="bclcs_level_2", overlay=TRUE)
visreg(model.NDT1.E, "climate1", by="bclcs_level_2")
visreg(model.NDT1.E, "climate1", by="Tdif_atfire")

visreg(model.NDT1.E, "climate2", by="elevation")
visreg(model.NDT1.E, "climate2", by="mdc_atfire")
visreg(model.NDT1.E, "climate2", by="Tdif_atfire")
#visreg2d(model.NDT1.E, "climate2", "elevation") #Another way to visualize

visreg(model.NDT1.E, "vegtype2", ylim=c(-40,40))

visreg(model.NDT1.E, "mdc_atfire", by="climate2")
visreg(model.NDT1.E, "Tdif_atfire", by="climate1")
visreg(model.NDT1.E, "Tdif_atfire", by="climate2")
visreg(model.NDT1.E, "Tdif_atfire", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E, "bclcs_level_2", by="climate1")
visreg(model.NDT1.E, "bclcs_level_2", by="climate1", ylim=c(-20,80))
visreg(model.NDT1.E, "bclcs_level_2", by="live_stand_volume_125")

visreg(model.NDT1.E, "live_stand_volume_125", by="bclcs_level_2", overlay=TRUE)

visreg(model.NDT1.E, "fire_cs", by="dist_infra")
visreg(model.NDT1.E, "fire_cs", by="roads_km")
visreg(model.NDT1.E, "fire_cs", by="elevation")
visreg(model.NDT1.E, "fire_cs", by="Tdif_atfire")

visreg(model.NDT1.E, "dist_infra", by="roads_km")
visreg(model.NDT1.E, "dist_infra", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E, "roads_km", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E, "roads_km", by="dist_infra")

visreg(model.NDT1.E, "slope", by="aspect")
visreg(model.NDT1.E, "aspect", by="slope")
visreg(model.NDT1.E, "elevation", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E, "elevation", by="climate2")

visreg(model.NDT1.E, "wind_atfire")

```

#Need to consider what to do with category L (in bclcs_level_2) as data often wonky. Remove entirely?
```{r}
table(NDT1_escape_t2$bclcs_level_2) #n = 4238

#Remove L from tree level
NDT1_escape_t2<-subset(NDT1_escape_t2, NDT1_escape_t2$bclcs_level_2!="L") #4017

#TB does not have many datapoints, but it is a very important category.
table(NDT1_escape_t2$vegtype2) #TM also low, but estimates ok. 
```
#Repeat above analysis with new bclcs_level_2 categories fixed
Note: when we remove category "L", we lose road surfaces and urban settings for vegtype.

```{r}
#Run Model again with this data; but uses all data here
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1, family = binomial, data = NDT1_escape_t2)

#Anova(model.NDT1.E, type=3)
Anova(model.NDT1.E, type=3, singular.ok = TRUE)

#Remove interaction volume with treed
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1, family = binomial, data = NDT1_escape_t2)

#Anova(model.NDT1.E, type=3)
Anova(model.NDT1.E, type=3, singular.ok = TRUE)

# model diagnostic plots
binnedplot (fitted(model.NDT1.E), 
            residuals(model.NDT1.E), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT1_escape_t2$resids<-resid(model.NDT1.E)

binnedplot (NDT1_escape_t2$live_stand_volume_125, 
            NDT1_escape_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_escape_t2$climate1, 
            NDT1_escape_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1

visreg(model.NDT1.E, "climate1", by="bclcs_level_2", overlay=TRUE)
visreg(model.NDT1.E, "climate1", by="Tdif_atfire")

visreg(model.NDT1.E, "climate2", by="elevation")
visreg(model.NDT1.E, "climate2", by="mdc_atfire")
visreg(model.NDT1.E, "climate2", by="Tdif_atfire")
#visreg2d(model.NDT1.E, "climate2", "elevation") #Another way to visualize

visreg(model.NDT1.E, "vegtype2", ylim=c(-20,20))

visreg(model.NDT1.E, "mdc_atfire", by="climate2")
visreg(model.NDT1.E, "Tdif_atfire", by="climate1")
visreg(model.NDT1.E, "Tdif_atfire", by="climate2")
visreg(model.NDT1.E, "Tdif_atfire", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E, "bclcs_level_2", by="climate1")
visreg(model.NDT1.E, "bclcs_level_2", by="live_stand_volume_125")

visreg(model.NDT1.E, "live_stand_volume_125")

visreg(model.NDT1.E, "fire_cs", by="dist_infra")
visreg(model.NDT1.E, "fire_cs", by="roads_km")
visreg(model.NDT1.E, "fire_cs", by="elevation")
visreg(model.NDT1.E, "fire_cs", by="Tdif_atfire")

visreg(model.NDT1.E, "dist_infra", by="roads_km")
visreg(model.NDT1.E, "dist_infra", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E, "roads_km", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E, "roads_km", by="dist_infra")

visreg(model.NDT1.E, "slope", by="aspect")
visreg(model.NDT1.E, "aspect", by="slope")
visreg(model.NDT1.E, "elevation", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E, "elevation", by="climate2")

visreg(model.NDT1.E, "wind_atfire")
```

We should repeat the above several times and take the mean of the coefficients.

```{r}
summary(model.NDT1.E)

#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1_ALL ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")
```

Let's run it 500 times to get good mean values.

```{r}

for (g in 1:500){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(NDT1_escape_t2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- NDT1_escape_t2[ trainIndex,]
   Valid <- NDT1_escape_t2[-trainIndex,]
   
#Model   
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E)[29] #coefficient 
top_mod_table_NDT1[1,34]<- coef(model.NDT1.E)[30] #coefficient 
top_mod_table_NDT1[1,35]<- mod.auc

top_mod_table_NDT1_ALL<-rbind(top_mod_table_NDT1_ALL, top_mod_table_NDT1)

}

```

Check.
```{r}
head(top_mod_table_NDT1_ALL)

```

#Save coefficient table

```{r}
write.csv(top_mod_table_NDT1_ALL, file="D:\\Fire\\fire_data\\raw_data\\top_mod_escape_NDT1_ALL.csv")
```

Get mean values.

```{r}
top_mod_table_NDT1_ALL_mean<-top_mod_table_NDT1_ALL %>% summarise_each(funs( mean( .,na.rm = TRUE)))
top_mod_table_NDT1_ALL_mean

top_mod_table_NDT1_ALL_mean[1,1]<-"lightning, person, unknown (ALL)"
top_mod_table_NDT1_ALL_mean[1,2]<-"NDT1"
top_mod_table_NDT1_ALL_mean[1,3]<-"ALL Treed and not treed"
top_mod_table_NDT1_ALL_mean[1,4]<-"escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1" 
top_mod_table_NDT1_ALL_mean
```
Save mean coefficient table.

```{r}
write.csv(top_mod_table_NDT1_ALL_mean, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_ALL_mean.csv")
```

Get SD.

```{r}
top_mod_table_NDT1_ALL_SD<-top_mod_table_NDT1_ALL %>% summarise_each(funs( sd( .,na.rm = TRUE)))
top_mod_table_NDT1_ALL_SD

top_mod_table_NDT1_ALL_SD[1,1]<-"lightning, person, unknown (ALL)"
top_mod_table_NDT1_ALL_SD[1,2]<-"NDT1"
top_mod_table_NDT1_ALL_SD[1,3]<-"ALL Treed and not treed"
top_mod_table_NDT1_ALL_SD[1,4]<-"escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1" 
top_mod_table_NDT1_ALL_SD
```

Save sd coefficient table.

```{r}
write.csv(top_mod_table_NDT1_ALL_SD, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_ALL_SD.csv")
```


####Part 2: Use Tmax_atfire and ppt_atfire
Remove NAs and run multiple times.

```{r}
#Remove NAs to ensure all same data used so we can compare AICs
NDT1_escape_t22<-escape_all_t_NDT1 %>% drop_na(Tmax_atfire, ppt_atfire, mdc_atfire, vegtype2, live_stand_volume_125, dist_infra, bclcs_level_2, slope, aspect, elevation, wind_atfire, Tdif_atfire, roads_km, fire_cs) #4238 observations
table(NDT1_escape_t22$vegtype2)
table(NDT1_escape_t22$bclcs_level_2)
NDT1_escape_t22<-subset(NDT1_escape_t22, NDT1_escape_t22$bclcs_level_2!="L")

#Run Model again with this data; but uses all data here
model.NDT1.E2<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire, family = binomial, data = NDT1_escape_t22)

#Anova(model.NDT1.E2, type=3)
Anova(model.NDT1.E2, type=3, singular.ok = TRUE) ##tmax*Tdif may not be needed

#Remoe interactions P > 0.20
model.NDT1.E2<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire, family = binomial, data = NDT1_escape_t22)

#Anova(model.NDT1.E2, type=3)
Anova(model.NDT1.E2, type=3, singular.ok = TRUE) ##tmax*Tdif may not be needed


# model diagnostic plots
binnedplot (fitted(model.NDT1.E2), 
            residuals(model.NDT1.E2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT1_escape_t22$resids<-resid(model.NDT1.E2)

binnedplot (NDT1_escape_t22$live_stand_volume_125, 
            NDT1_escape_t22$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_escape_t22$Tmax_atfire, 
            NDT1_escape_t22$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire

visreg(model.NDT1.E2, "Tmax_atfire", by="bclcs_level_2", overlay=TRUE)

visreg(model.NDT1.E2, "ppt_atfire", by="elevation")
visreg(model.NDT1.E2, "ppt_atfire", by="mdc_atfire")
visreg(model.NDT1.E2, "ppt_atfire", by="Tdif_atfire")
#visreg2d(model.NDT1.E2, "ppt_atfire", "elevation") #Another way to visualize

visreg(model.NDT1.E2, "vegtype2")
visreg(model.NDT1.E2, "vegtype2", ylim=c(-25,10))

visreg(model.NDT1.E2, "mdc_atfire", by="ppt_atfire")
visreg(model.NDT1.E2, "Tdif_atfire", by="ppt_atfire")
visreg(model.NDT1.E2, "Tdif_atfire", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E2, "bclcs_level_2", by="Tmax_atfire")
visreg(model.NDT1.E2, "bclcs_level_2", by="live_stand_volume_125")

visreg(model.NDT1.E2, "live_stand_volume_125")

visreg(model.NDT1.E2, "fire_cs", by="dist_infra")
visreg(model.NDT1.E2, "fire_cs", by="roads_km")
visreg(model.NDT1.E2, "fire_cs", by="elevation")
visreg(model.NDT1.E2, "fire_cs", by="Tdif_atfire")

visreg(model.NDT1.E2, "dist_infra", by="roads_km")
visreg(model.NDT1.E2, "dist_infra", by="fire_cs", overlay=TRUE)

visreg(model.NDT1.E2, "roads_km", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E2, "roads_km", by="dist_infra")

visreg(model.NDT1.E2, "slope", by="aspect")
visreg(model.NDT1.E2, "aspect", by="slope")
visreg(model.NDT1.E2, "elevation", by="fire_cs", overlay=TRUE)
visreg(model.NDT1.E2, "elevation", by="ppt_atfire")

visreg(model.NDT1.E2, "wind_atfire")

```

We should repeat the above several times and take the mean of the coefficients.

```{r}
summary(model.NDT1.E2)

#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL2 <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1_ALL2 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_Tmax_atfire", "coef_ppt_atfire", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")
```

Let's run it 500 times to get good mean values.

```{r}

for (g in 1:500){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(NDT1_escape_t22$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- NDT1_escape_t22[ trainIndex,]
   Valid <- NDT1_escape_t22[-trainIndex,]
   
#Model   
model.NDT1.E2<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E2, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_Tmax_atfire", "coef_ppt_atfire", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E2)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E2)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E2)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E2)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E2)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E2)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E2)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E2)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E2)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E2)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E2)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E2)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E2)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E2)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E2)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E2)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E2)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E2)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E2)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E2)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E2)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E2)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E2)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E2)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E2)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E2)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E2)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E2)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E2)[29] #coefficient 
top_mod_table_NDT1[1,34]<- mod.auc

top_mod_table_NDT1_ALL2<-rbind(top_mod_table_NDT1_ALL2, top_mod_table_NDT1)

}

```

Check.
```{r}
head(top_mod_table_NDT1_ALL2)

```

#Save coefficient table

```{r}
write.csv(top_mod_table_NDT1_ALL2, file="D:\\Fire\\fire_data\\raw_data\\top_mod_escape_NDT1_ALL_tmax.csv")
```

Get mean values.

```{r}
top_mod_table_NDT1_ALL2_mean<-top_mod_table_NDT1_ALL2 %>% summarise_each(funs( mean( .,na.rm = TRUE)))
top_mod_table_NDT1_ALL2_mean

top_mod_table_NDT1_ALL2_mean[1,1]<-"lightning, person, unknown (ALL)"
top_mod_table_NDT1_ALL2_mean[1,2]<-"NDT1"
top_mod_table_NDT1_ALL2_mean[1,3]<-"ALL Treed and not treed"
top_mod_table_NDT1_ALL2_mean[1,4]<-"escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire" 
top_mod_table_NDT1_ALL2_mean
```
Save mean coefficient table.

```{r}
write.csv(top_mod_table_NDT1_ALL2_mean, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_ALL2_mean_tmax.csv")
```

Get SD.

```{r}
top_mod_table_NDT1_ALL2_SD<-top_mod_table_NDT1_ALL2 %>% summarise_each(funs( sd( .,na.rm = TRUE)))
top_mod_table_NDT1_ALL2_SD

top_mod_table_NDT1_ALL2_SD[1,1]<-"lightning, person, unknown (ALL)"
top_mod_table_NDT1_ALL2_SD[1,2]<-"NDT1"
top_mod_table_NDT1_ALL2_SD[1,3]<-"ALL Treed and not treed"
top_mod_table_NDT1_ALL2_SD[1,4]<-"escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire" 
top_mod_table_NDT1_ALL2_SD
```

Save sd coefficient table.

```{r}
write.csv(top_mod_table_NDT1_ALL2_SD, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_ALL2_SD_tmax.csv")
```




############ Validation Type 2: Using recent Years as Validation Dataset ########


#Part 1: climate 1 and climate2

Create blank data table.

```{r}
#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL_v2 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1_ALL_v2 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")
```

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2018) #3500
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2017) #517

table(dat1$fire_yr)
table(Valid$fire_yr) #No 2020?
```


```{r}
#Model   
model.NDT1.E.v2<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E.v2, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E.v2)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E.v2)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E.v2)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E.v2)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E.v2)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E.v2)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E.v2)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E.v2)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E.v2)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E.v2)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E.v2)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E.v2)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E.v2)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E.v2)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E.v2)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E.v2)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E.v2)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E.v2)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E.v2)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E.v2)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E.v2)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E.v2)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E.v2)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E.v2)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E.v2)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E.v2)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E.v2)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E.v2)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E.v2)[29] #coefficient 
top_mod_table_NDT1[1,34]<- coef(model.NDT1.E.v2)[30] #coefficient 
top_mod_table_NDT1[1,35]<- mod.auc

top_mod_table_NDT1_ALL_v2<-rbind(top_mod_table_NDT1_ALL_v2, top_mod_table_NDT1)
```

View.
```{r}
head(top_mod_table_NDT1_ALL_v2) #AUC 0.65 this way
```
Divide by one year earlier given lack of 2020


```{r}
#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL_v2 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1_ALL_v2 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")
```

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2017) #3261
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2016) #756

table(dat1$fire_yr)
table(Valid$fire_yr) #No 2020?
```


```{r}
#Model   
model.NDT1.E.v2<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E.v2, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_climate2:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_climate2:elevation", "coef_climate1:Tdif_atfire", "coef_climate2:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_climate1:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate2:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*climate1" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E.v2)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E.v2)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E.v2)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E.v2)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E.v2)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E.v2)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E.v2)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E.v2)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E.v2)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E.v2)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E.v2)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E.v2)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E.v2)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E.v2)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E.v2)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E.v2)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E.v2)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E.v2)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E.v2)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E.v2)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E.v2)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E.v2)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E.v2)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E.v2)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E.v2)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E.v2)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E.v2)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E.v2)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E.v2)[29] #coefficient 
top_mod_table_NDT1[1,34]<- coef(model.NDT1.E.v2)[30] #coefficient 
top_mod_table_NDT1[1,35]<- mod.auc

top_mod_table_NDT1_ALL_v2<-rbind(top_mod_table_NDT1_ALL_v2, top_mod_table_NDT1)
```

View.
```{r}
head(top_mod_table_NDT1_ALL_v2) #New AUC 0.66, not much better, but not awful
```

#Part 2: Tmax and ppt at fire

Create blank data table.

```{r}
#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL2_v2 <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1_ALL2_v2 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")
```

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2018) #3500
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2017) #517

table(dat1$fire_yr)
table(Valid$fire_yr) #No 2020?
```


```{r}
#Model   
model.NDT1.E.v2<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E.v2, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E.v2)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E.v2)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E.v2)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E.v2)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E.v2)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E.v2)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E.v2)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E.v2)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E.v2)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E.v2)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E.v2)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E.v2)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E.v2)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E.v2)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E.v2)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E.v2)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E.v2)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E.v2)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E.v2)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E.v2)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E.v2)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E.v2)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E.v2)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E.v2)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E.v2)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E.v2)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E.v2)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E.v2)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E.v2)[29] #coefficient 
top_mod_table_NDT1[1,34]<- mod.auc

top_mod_table_NDT1_ALL2_v2<-rbind(top_mod_table_NDT1_ALL2_v2, top_mod_table_NDT1)
```

View.
```{r}
head(top_mod_table_NDT1_ALL2_v2) #AUC 0.65 this way
```
Divide by one year earlier given lack of 2020


```{r}
#Create a new blank table and get AUC too
top_mod_table_NDT1_ALL2_v2 <- data.frame (matrix (ncol = 35, nrow = 0))
colnames (top_mod_table_NDT1_ALL2_v2 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_Tmax_atfire:Tdif_atfire", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")
```

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2017) #3261
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2016) #756

table(dat1$fire_yr)
table(Valid$fire_yr) #No 2020?
```


```{r}
#Model   
model.NDT1.E.v2<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1.E.v2, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1 <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1 ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_live_stand_volume_125", "coef_bclcs_level_2T", "coef_slope", "coef_aspect", "coef_elevation","coef_wind_atfire", "coef_dist_infra", "coef_roads_km", "coef_Tdifatfire", "coef_fire_csPerson", "coef_ppt_atfire:mdc_atfire", "coef_slope:aspect", "coef_dist_infra:roads_km", "coef_ppt_atfire:elevation", "coef_ppt_atfire:Tdif_atfire", "coef_dist_infra:fire_csPerson", "coef_roads_km:fire_csPerson", "coef_elevation:fire_csPerson", "coef_Tdif_atfire:fire_csPerson", "coef_Tmax_atfire:bclcs_level_2T", "AUC")

##Add data for NDT1
top_mod_table_NDT1[1,1]<-"lightning, person, unknown"
top_mod_table_NDT1[1,2]<-"NDT1"
top_mod_table_NDT1[1,3]<-"Y andN"
top_mod_table_NDT1[1,4]<-"escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire  + elevation*ppt_atfire + Tdif_atfire*ppt_atfire + fire_cs + fire_cs*dist_infra + fire_cs*roads_km + fire_cs*elevation + fire_cs*Tdif_atfire + bclcs_level_2*Tmax_atfire" 
top_mod_table_NDT1[1,5]<- coef(model.NDT1.E.v2)[1] #Intercept
top_mod_table_NDT1[1,6]<- coef(model.NDT1.E.v2)[2] #
top_mod_table_NDT1[1,7]<- coef(model.NDT1.E.v2)[3] #
top_mod_table_NDT1[1,8]<- coef(model.NDT1.E.v2)[4] #coefficient 
top_mod_table_NDT1[1,9]<- coef(model.NDT1.E.v2)[5] #coefficient 
top_mod_table_NDT1[1,10]<- coef(model.NDT1.E.v2)[6] #coefficient
top_mod_table_NDT1[1,11]<- coef(model.NDT1.E.v2)[7] #
top_mod_table_NDT1[1,12]<- coef(model.NDT1.E.v2)[8] #coefficient 
top_mod_table_NDT1[1,13]<- coef(model.NDT1.E.v2)[9] #coefficient 
top_mod_table_NDT1[1,14]<- coef(model.NDT1.E.v2)[10] #coefficient
top_mod_table_NDT1[1,15]<- coef(model.NDT1.E.v2)[11] #coefficient
top_mod_table_NDT1[1,16]<- coef(model.NDT1.E.v2)[12] #coefficient
top_mod_table_NDT1[1,17]<- coef(model.NDT1.E.v2)[13] #coefficien
top_mod_table_NDT1[1,18]<- coef(model.NDT1.E.v2)[14] #coefficient 
top_mod_table_NDT1[1,19]<- coef(model.NDT1.E.v2)[15] #
top_mod_table_NDT1[1,20]<- coef(model.NDT1.E.v2)[16] #  
top_mod_table_NDT1[1,21]<- coef(model.NDT1.E.v2)[17] # 
top_mod_table_NDT1[1,22]<- coef(model.NDT1.E.v2)[18] #coefficient 
top_mod_table_NDT1[1,23]<- coef(model.NDT1.E.v2)[19] #coefficient 
top_mod_table_NDT1[1,24]<- coef(model.NDT1.E.v2)[20] #coefficient 
top_mod_table_NDT1[1,25]<- coef(model.NDT1.E.v2)[21] #coefficient 
top_mod_table_NDT1[1,26]<- coef(model.NDT1.E.v2)[22] #coefficient 
top_mod_table_NDT1[1,27]<- coef(model.NDT1.E.v2)[23] #coefficient 
top_mod_table_NDT1[1,28]<- coef(model.NDT1.E.v2)[24] #coefficient 
top_mod_table_NDT1[1,29]<- coef(model.NDT1.E.v2)[25] #coefficient 
top_mod_table_NDT1[1,30]<- coef(model.NDT1.E.v2)[26] #coefficient 
top_mod_table_NDT1[1,31]<- coef(model.NDT1.E.v2)[27] #coefficient 
top_mod_table_NDT1[1,32]<- coef(model.NDT1.E.v2)[28] #coefficient 
top_mod_table_NDT1[1,33]<- coef(model.NDT1.E.v2)[29] #coefficient 
top_mod_table_NDT1[1,34]<- mod.auc

top_mod_table_NDT1_ALL2_v2<-rbind(top_mod_table_NDT1_ALL2_v2, top_mod_table_NDT1)
```

View.
```{r}
head(top_mod_table_NDT1_ALL2_v2) #New AUC 0.65, not awful
```


#With above subsetted data, start process from beginning.

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2018) #3500
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2017) #517
```


```{r}
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + climate2:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate1  + elevation*climate2 + wind_atfire*climate1 + wind_atfire*climate2 + wind_atfire*vegtype2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2763.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.67
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + climate2:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate1  + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2750.5

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.68
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + climate2:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2747.1

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.68
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + climate2:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2744.3

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.68
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2742.9

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.68
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2741.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.69
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2741.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.69
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ climate1 + climate2 + vegtype2 + mdc_atfire + climate1:climate2 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + wind_atfire + Tdif_atfire + elevation*climate2 + Tdif_atfire*climate1 + Tdif_atfire*climate2 + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2739.98

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.69
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
```
Compare to Tmax_atfire and ppt_atfire

```{r}
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + wind_atfire*Tmax_atfire + wind_atfire*ppt_atfire + wind_atfire*vegtype2 + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2741.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.65
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2729.99

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.65
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2726.5

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.66
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2725.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.65
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2724.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.66
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2723.3

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.66
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + dist_infra + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2723.3

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.66
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"
```
Try with one year added to validation

```{r}
dat1 <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr<2017) #3261
Valid <- subset(NDT1_escape_t2, NDT1_escape_t2$fire_yr>2016) #756
```

```{r}
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire + wind_atfire*Tmax_atfire + wind_atfire*ppt_atfire + wind_atfire*vegtype2 + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2445.23

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + dist_infra:roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire  + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2435.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_age_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire  + Tdif_atfire*Tmax_atfire + Tdif_atfire*ppt_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2433.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + Tmax_atfire:ppt_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + slope + aspect + elevation + wind_atfire + slope:aspect + slope:elevation + dist_infra + roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire  + Tdif_atfire*Tmax_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2430.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + slope + aspect + elevation + wind_atfire + slope:aspect  + dist_infra + roads_km + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire  + Tdif_atfire*Tmax_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2427.1

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"

#Remove least sig
model.NDT1.E<-glm(escape ~ Tmax_atfire + ppt_atfire + vegtype2 + mdc_atfire + ppt_atfire:mdc_atfire + live_stand_volume_125 + bclcs_level_2  + slope + aspect + elevation + wind_atfire + slope:aspect  + dist_infra + wind_atfire + Tdif_atfire + elevation*Tmax_atfire  + elevation*ppt_atfire  + Tdif_atfire*Tmax_atfire + fire_cs, family = binomial, data = dat1)

AIC(model.NDT1.E) #2424.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1.E, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"escape"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.64
   
Anova(model.NDT1.E, type=3) #Lots of "glm.fit: fitted probabilities numerically 0 or 1 occurred"


```
Using the above with another year's worth of data, the AUC decreases; so use 2017-2019 as validation dataset instead.
