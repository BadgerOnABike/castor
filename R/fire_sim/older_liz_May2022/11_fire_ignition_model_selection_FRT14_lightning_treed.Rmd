---
title: "11_fire_ignition_model_selection_FRT14_lightning_treed"
author: "Cora Skaien and Elizabeth Kleynhans"
date: "16/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library (data.table)
library (DBI)
library (RPostgreSQL)
library (dplyr)
library (ggplot2)
library (here)
library(ggpubr)
library(arm)
library(tidyr)
library(AICcmodavg)
library(keyring)
library(caret)
library(pROC)
library(rje)
library(car)
library(visreg)

source(here::here("R/functions/R_Postgres.R"))
```

<!--
Copyright 2021 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->

#=================================
#  Script Name: 11_fire_ignition_model_selection_FRT10_lightning_treed.R
#  Script Version: 1.0
#  Script Purpose: Model selection, using various initial models to inform the final model selection.
#  Script Author: Cora Skaien, Ecological Modeling Specialist, Forest Analysis and Inventory Branch, B.C. Ministry of Forests, Lands, and Natural Resource Operations.
#=================================

#Load data back in if starting from here
Note: depending where your geometry column was located when saved as a csv (and turned into a dataframe), you may need to manually correct column headings on the csv file before loading back in. This has been performed for the below files.


```{r}
dat_lightning<- read.csv("C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\data\\Data_Lightning.csv")

dat_lightning_t<- dat_lightning %>% filter(bclc__2=="T")
head(dat_lightning_t)
dat_lightning_t$vegtype<-as.factor(dat_lightning_t$vegtype)

table(dat_lightning_t$vegtype)


```

######################### ANALYSES: TREED, LIGHTNING #########################

Now, we will make a loop that does something very similar to our last loop, but with the selected climate variable plus other variables of interest. For lightning caused fires with trees, the variables of interest include:

1. Climate variable(s)
2. Projected Height (proj_height_1)
3. projected age (proj_age_1)  
4. live_stand_volume_125
5. vegtype and possibly some indicator of density e.g. bclcs_level_5_2
8. elevation

Variables to be added after initial model selection for next round model selection:
1. bclcs_level_5_2 (land use) (to be added to final investigated model)

Interactions of interest: two-way interactions between climate (1) and vegtype (6); two-way interactions between topography measures (7-9); interactions between VRI variables.

This will be done separately for trees and non-treed areas. 

##We will do each loop separately for each FRT given the large number of possible models for each zone.

First we will create the variable lists that contain all of our variables of interest.

```{r}

##Create variable lists to be used in the model loop.
variables_all<-c(climate1 = "climate1", prj_h_1 = "prj_h_1", prj_g_1 = "prj_g_1", l___125 = "l___125", elevatn ="elevatn", vegtype = "vegtype", bclcs_level_5_2="bclcs_level_5_2") 

variables_all_c1<-c(climate1 = "climate1", prj_h_1 = "prj_h_1", prj_g_1 = "prj_g_1", l___125 = "l___125", elevatn ="elevatn", vegtype = "vegtype", bclcs_level_5_2="bclcs_level_5_2") 

vars.clim<-c("climate1")
vars.clim.vegtype<-c("climate1", "vegtype")
#vars.clim.vegtype2<-c("l___125","vegtype")

vars.oth<-c("prj_g_1", "prj_h_1", "l___125") 
vars.topo<-c("elevatn")

variables_all<-c("climate1","prj_h_1", "prj_g_1", "l___125", "dm_h_bc", "vegtype", "bclcs_level_5_2") 

Cols <- variables_all
n <- length(Cols)
id <- unlist(
        lapply(1:n,
              function(i)combn(1:n,i,simplify=FALSE)
        )
      ,recursive=FALSE)
Formulas <- sapply(id,function(i)
              paste("fire ~",paste(Cols[i],collapse="+"))
            )
mods.fit<-lapply(Formulas,function(i)
    glm(as.formula(i),family=binomial, data=dat_lightning_t))

form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)

###########




##Create interaction for climate and vegtype
inputs.me <- c(vars.clim.vegtype)
#inputs.me2 <- c(vars.clim.vegtype2)
```

Now, we will generate two-way interactions for each of these lists. 

```{r}

#####1a. For those with one climate variable
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints <- NULL
for (i in 1:(length(inputs.me)-1)) {
  for (j in (i+1):length(inputs.me)) {
     twoway.ints <- cbind(twoway.ints, paste(inputs.me[i], inputs.me[j], sep=":"))
  }
}
twoway.ints
length(twoway.ints)


#Get variables on own
#complete list of models using non-climate vars
mods.me.tmp <- powerSet(vars.clim.vegtype) 
#add climate vars to all of the above
mods.me.climate <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.climate


#Get variables on own
#complete list of models using non-climate vars
#mods.me.tmp <- powerSet(vars.clim.vegtype2b) 
#add climate vars to all of the above
mods.me.climate2b <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate2b[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.climate2b



#########2. Now for topography data, get all possible two-way interactions

#get the names of all possible two-way interactions
twoway.intsT <- NULL
for (i in 1:(length(vars.topo)-1)) {
  for (j in (i+1):length(vars.topo)) {
     twoway.intsT <- cbind(twoway.intsT, paste(vars.topo[i], vars.topo[j], sep=":"))
  }
}
twoway.intsT
length(twoway.intsT)

#complete list of models using non-climate vars (topo)
mods.me.tmp <- powerSet(vars.topo) 
#add climate vars to all of the above
mods.meT <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.meT[[i]] <- c(mods.me.tmp[[i]])
}


mods.meT

#complete list of two-way interactions
mods.twowayT <- powerSet(twoway.intsT)
length(mods.twowayT) #7
mods.twowayT

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added

mods.interT <- list()
counter <- 0
for (i in 1: length(mods.twowayT)) {
   s1 <- unique(unlist( strsplit(mods.twowayT[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meT)) {
      if (all(s1 %in% mods.meT[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.meT[[j]], mods.twowayT[[i]])
        mods.interT[[counter]] <- both
      }
   }
}

length(mods.interT)
#mods.interT
mods.interTb<-c(mods.interT)
#mods.interTb

####3.For other VRI data, get without interactions

#complete list of models using VRI - no interactions
mods.me.tmp <- powerSet(vars.oth) 
#add climate vars to all of the above
mods.me.oth <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.oth[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.oth


#the list of all possible model RHSs. 
#all.poss.mods <- c(1, vars.clim, twoway.ints, mods.me.oth, mods.me2, mods.inter2)
#all.poss.mods

all.poss.mods.clim.vegtype<-c(1, mods.me.climate, twoway.ints)
all.poss.mods.clim.vegtype 
all.poss.mods.clim.vegtype<-all.poss.mods.clim.vegtype [-2] #Use this line only if there is an odd character(0) added to list

all.poss.mods.VRI<-c(1, mods.me.oth)
all.poss.mods.VRI
all.poss.mods.VRI<-all.poss.mods.VRI[-2]
#all.poss.mods.topo<-c(1, mods.meT, mods.interT)
all.poss.mods.topo<-c(1, mods.interT)
all.poss.mods.topo
#all.poss.mods.topo<-all.poss.mods.topo[-10]
all.poss.mods.topo<-all.poss.mods.topo[-c(2,4)]

#If need to determine which ones are character(0), try this:
biglist <- list(list("A","B","C"), "foo", "", character(0), integer(0))
lapply(biglist, function(x) {length(x) == 0L} ) 


##Check and rid of any duplicated models
duplicated(all.poss.mods.clim.vegtype) #None duplicated
#duplicated(all.poss.mods.clim.vegtype2)
#duplicated(all.poss.mods.clim.vegtype2b)
duplicated(all.poss.mods.VRI)
duplicated(all.poss.mods.topo)
```




############### Part 1 of 4 Model Series: Lightning Caused Fires, Trees ##########

Because of the large number of models with all variables included, we will test the climate and vegtype first, then the VRI variables, then the topography variables. Then we will test the top models together, with determining best AIC model from there. Or perhaps we will just combine the top models for each together, and eliminate models if the intercept was the best predictor.

Select FRT: FRT13

```{r}
zones1<-c("13") #Do one zone at a time

prop<-0.75

#Create empty table
table.glm.climate.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.climate.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

dat_lightning_t$fire_veg<-paste(dat_lightning_t$fire, dat_lightning_t$vegtype)


########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- dat_lightning_t %>% dplyr::filter(frt ==zones1[h])

#for (i in 1: length(all.poss.mods.clim.vegtype2)){
#  print(paste((all.poss.mods.clim.vegtype2[i]), (zones1[h]), sep=" "))
  
for (i in 1: length(zones1)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(fire, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="fire") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.climate$FRT<-c("FRT13")
tab.sum.climate 

table.glm.climate.simple<-rbind(table.glm.climate.simple, tab.sum.climate)

}
}
}


```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.climate.simple)
table(table.glm.climate.simple$model) # 100 per model

AIC_lightning_NDT1_t_ignitereed_climate<-table.glm.climate.simple

AIC_lightning_NDT1_t_ignitereed_summary_climate<- AIC_lightning_NDT1_t_ignitereed_climate %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

AIC_lightning_NDT1_t_ignitereed_summary_climate2<- AIC_lightning_NDT1_t_ignitereed_summary_climate %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_NDT1_t_ignitereed_summary_climate2)
```

#Now repeat for VRI data

```{r}
########### 2. VRI ############
#Create empty table
table.glm.VRI.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.VRI.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

####
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- dat_lightning_t %>% dplyr::filter(frt ==zones1[h])

#for (i in 1: length(all.poss.mods.VRI)){
#  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
for (i in 1: length(zones1)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(fire, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="fire") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.VRI$FRT<-c("FRT10")
tab.sum.VRI 

table.glm.VRI.simple<-rbind(table.glm.VRI.simple, tab.sum.VRI)

}
}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.VRI.simple)
table(table.glm.VRI.simple$model) # 100 per model

AIC_lightning_NDT1_t_ignitereed_VRI<-table.glm.VRI.simple

AIC_lightning_NDT1_t_ignitereed_summary_VRI<- AIC_lightning_NDT1_t_ignitereed_VRI %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

AIC_lightning_NDT1_t_ignitereed_summary_VRI2<- AIC_lightning_NDT1_t_ignitereed_summary_VRI %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(as.data.frame(AIC_lightning_NDT1_t_ignitereed_summary_VRI2))

```

#Now repeat for topography

```{r}
########### 3. topo ############
#Create empty table
table.glm.topo.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.topo.simple) <- c ("model", "edf", "aic", "auc.valid", "FRT")

#
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- dat_lightning_t %>% dplyr::filter(frt ==zones1[h])

#for (i in 1: length(all.poss.mods.topo)){
#  print(paste((all.poss.mods.topo[i]), (zones1[h]), sep=" "))
  
for (i in 1: length(zones1)){
  print(paste((all.poss.mods.topo[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(fire, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="fire") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.topo$FRT<-c("FRT15")
tab.sum.topo 

table.glm.topo.simple<-rbind(table.glm.topo.simple, tab.sum.topo)

}
}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination.

```{r}
head(table.glm.topo.simple)
table(table.glm.topo.simple$model) # 100 per model

AIC_lightning_NDT1_t_ignitereed_topo<-table.glm.topo.simple

AIC_lightning_NDT1_t_ignitereed_summary_topo<- AIC_lightning_NDT1_t_ignitereed_topo %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

AIC_lightning_NDT1_t_ignitereed_summary_topo2<- AIC_lightning_NDT1_t_ignitereed_summary_topo %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_NDT1_t_ignitereed_summary_topo2)
```


#Now combine the datatables and save to computer

```{r}
FRT10_l_models_treed<-rbind(AIC_lightning_NDT1_t_ignitereed_summary_climate2, AIC_lightning_NDT1_t_ignitereed_summary_VRI2, AIC_lightning_NDT1_t_ignitereed_summary_topo2)
FRT10_l_models_treed
FRT10_l_models_treed$FRT<-"FRT11"

write.csv(FRT10_l_models_treed, file="C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\data\\Ignition_lightning_treed_model_results\\FRT5_lightning_models_treed.csv")
```




################################ STAGE TWO ########################

#STAGE TWO: PUT TOGETHER MORE VARIABLES
Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are. From the top models, we will re-create two-way interactions for the variables selected from each model, plus the other variables listed as needed to be included. We will assess each set to ensure only interactions that make sense are investigated ultimately, given that sample sizes will be an issues.

Top Models:
1. climate1
2. proj_height_1 + proj_age_1 + live_stand_volume_125
3. elevation

Variables:
1. bclcs_level_5_2 (land use) (to be added to final investigated model)

We want to include interactions between variables from within each list. This will make for many models, which may be hard to process in R.

```{r}
#This is not working. I think I need to use same approach as cora did as Im not sure how to get these columns into the right format for includn
 vars.all<-c("climate1", "vegtype", "prj_h_1", "prj_g_1", "l___125", "elevatn")
#complete list of models using VRI - no interactions
mods.me.tmp <- powerSet(vars.all) 

# not sure this next peice of code is neccessary
all.poss.mods <- list()
for (i in 1: length(mods.me.tmp)) {
   all.poss.mods[[i]] <- c(mods.me.tmp[[i]])
}

all.poss.mods<-all.poss.mods[-1]


table.glm.all <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.all) <- c ("model", "edf", "aic", "auc.valid", "FRT")

#
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- dat_lightning_t %>% dplyr::filter(frt ==zones1[h] )#& vegtype!="D") # had to remove disturbed locations because there are too few of them
  
#for (i in 1: length(all.poss.mods.topo)){
#  print(paste((all.poss.mods.topo[i]), (zones1[h]), sep=" "))
  
for (i in 1: length(zones1)){
  print(paste((all.poss.mods[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(fire, fire_veg, !!variables_all)
  model_dat<-drop_na(model_dat)

  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="fire") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.topo$FRT<-c("FRT11")
tab.sum.topo 

table.glm.all<-rbind(table.glm.all, tab.sum.topo)

}
}
}

```

```{r}
head(table.glm.all)
table(table.glm.all$model) # 100 per model

AIC_lightning_NDT1_t_ignitereed_topo<-table.glm.all

AIC_lightning_NDT1_t_ignitereed_summary_topo<- AIC_lightning_NDT1_t_ignitereed_topo %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

AIC_lightning_NDT1_t_ignitereed_summary_topo2<- AIC_lightning_NDT1_t_ignitereed_summary_topo %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

AIC_lightning_t <- AIC_lightning_NDT1_t_ignitereed_summary_topo2 %>%                 # Order table with dplyr
  as.data.frame() %>% 
  arrange((deltaAIC))
AIC_lightning_t     

```

Save.
```{r}
write.csv(AIC_lightning_t, file="C:\\Work\\caribou\\clus_data\\Fire\\Fire_sim_data\\out\\model_results_lightning_treed\\table.glm.FRT_15_ALL.csv")
```

```{r}

# model diagnostic plots
binnedplot (fitted(model.NDT1), 
            residuals(model.NDT1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


NDT1_t_ignite$resids<-resid(model.NDT1)

binnedplot (NDT1_t_ignite$live_stand_volume_125, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_t_ignite$climate1, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation
visreg(model.NDT1, "climate1", by="climate2")
visreg(model.NDT1, "climate1", by="proj_age_1")
visreg(model.NDT1, "climate1", by="proj_height_1")

visreg(model.NDT1, "climate2", by="climate1")
visreg(model.NDT1, "climate2", by="proj_age_1")

visreg(model.NDT1, "slope")
visreg(model.NDT1, "aspect_cos")
visreg(model.NDT1, "elevation")

visreg(model.NDT1, "live_stand_volume_125", by="vegtype2", overlay=TRUE, ylim=c(-10,10))

visreg(model.NDT1, "proj_age_1", by="climate2")
visreg(model.NDT1, "proj_age_1", by="climate1")
visreg(model.NDT1, "proj_age_1", by="proj_height_1")

visreg(model.NDT1, "proj_height_1", by="climate1")
visreg(model.NDT1, "proj_height_1", by="proj_age_1")

#dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2

visreg(model.NDT1, "dist_mun", by="bclcs_level_5_2", overlay=TRUE) #look into these extreme points
visreg(model.NDT1, "dist_dam")
visreg(model.NDT1, "dist_nat", by="bclcs_level_5_2", overlay=TRUE)
visreg(model.NDT1, "dist_mine")

visreg(model.NDT1, "bclcs_level_5_2", by="dist_nat")
visreg(model.NDT1, "bclcs_level_5_2", by="dist_mun")

```


We should repeat the above several times and take the mean of the coefficients.











Now repeat the process again many times to get variation.

```{r}
zones1<-"NDT1"

#Create empty table
table.glm.clim_VRI.NDT1_set1 <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.clim_VRI.NDT1_set1) <- c ("model", "edf", "aic", "auc.valid", "NDT")

#Subset data
dat2<- dat_lightning_t %>% dplyr::filter(ntrl_ds ==zones1[h])

 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, !!variables_clim_VRI_NDT1)
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]
```

Model needs to be run for each set of variables on the same subset of training and validation data to compare AICs.

```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_1, big.mod, df.train=dat1, df.test=Valid)
```

Extract the model terms.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set1<-rbind(table.glm.clim_VRI.NDT1_set1, tab.sum.clim_VRI)

table.glm.clim_VRI.NDT1_set1

```

#Repeat for set2
Make an empty table.

```{r}
#Create empty table
table.glm.clim_VRI.NDT1_set2 <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.clim_VRI.NDT1_set2) <- c ("model", "edf", "aic", "auc.valid", "NDT")
```

Run function for set 2.

```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_2, big.mod, df.train=dat1, df.test=Valid)
```

Save output.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set2<-rbind(table.glm.clim_VRI.NDT1_set2, tab.sum.clim_VRI)

table.glm.clim_VRI.NDT1_set2
```

Combine set 1 and set 2

```{r}
table.glm.clim_VRI.NDT1_set1_2<-rbind(table.glm.clim_VRI.NDT1_set1, table.glm.clim_VRI.NDT1_set2)
```

Run function for set 3.

```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_3, big.mod, df.train=dat1, df.test=Valid)
```

Extract output.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
#x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
#x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
#x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set_ALL2<-rbind(table.glm.clim_VRI.NDT1_set1_2, tab.sum.clim_VRI) #Should have 40,069 rows

```

Save.
```{r}
write.csv(table.glm.clim_VRI.NDT1_set_ALL2, file="D:\\Fire\\fire_data\\raw_data\\table.glm.clim_VRI.NDT1_ALL2.csv")
```

Combine the first 2 runs.

```{r}
table.glm.clim_VRI.NDT1_set_ALL1_2<-rbind(table.glm.clim_VRI.NDT1_set_ALL, table.glm.clim_VRI.NDT1_set_ALL2)
```

Save.
```{r}
write.csv(table.glm.clim_VRI.NDT1_set_ALL1_2, file="D:\\Fire\\fire_data\\raw_data\\table.glm.clim_VRI.NDT1_ALL1_2.csv")
```

Now repeat the process again many times to get variation. Likely, much of the environment will need to be cleared to be able to run. Remember to use gc() as well. Keep table.glm.clim_VRI.NDT1_set_ALL1_2 and all relevant model lists.

```{r}
zones1<-"NDT1"

#Create empty table
table.glm.clim_VRI.NDT1_set1 <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.clim_VRI.NDT1_set1) <- c ("model", "edf", "aic", "auc.valid", "NDT")

#Subset data
dat2<- dat_lightning_t %>% dplyr::filter(ntrl_ds ==zones1[h])

 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, !!variables_clim_VRI_NDT1)
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]
```

Model needs to be run for each set of variables on the same subset of training and validation data to compare AICs.

Below is not working well, so split in next round.
```{r}
all.poss.mods.clim_VRI_NDT1b_1_a<-all.poss.mods.clim_VRI_NDT1b_1[1:10000]
all.poss.mods.clim_VRI_NDT1b_1_b<-all.poss.mods.clim_VRI_NDT1b_1[10001:20000]
```


```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_1_a, big.mod, df.train=dat1, df.test=Valid)
```

Extract the model terms.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set1<-rbind(table.glm.clim_VRI.NDT1_set1, tab.sum.clim_VRI)

table.glm.clim_VRI.NDT1_set1

```

Repeat for second half.
```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_1_b, big.mod, df.train=dat1, df.test=Valid)
```

Extract the model terms.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set1<-rbind(table.glm.clim_VRI.NDT1_set1, tab.sum.clim_VRI) #combine with set1 already produced from first half

table.glm.clim_VRI.NDT1_set1

```


#Repeat for set2
Make an empty table.

```{r}
#Create empty table
table.glm.clim_VRI.NDT1_set2 <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.clim_VRI.NDT1_set2) <- c ("model", "edf", "aic", "auc.valid", "NDT")
```

Run function for set 2.

```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_2, big.mod, df.train=dat1, df.test=Valid)
```

Save output.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set2<-rbind(table.glm.clim_VRI.NDT1_set2, tab.sum.clim_VRI)

table.glm.clim_VRI.NDT1_set2
```

Combine set 1 and set 2

```{r}
table.glm.clim_VRI.NDT1_set1_2<-rbind(table.glm.clim_VRI.NDT1_set1, table.glm.clim_VRI.NDT1_set2)
```

Run function for set 3.

```{r}
mods.fit <- lapply(all.poss.mods.clim_VRI_NDT1b_3, big.mod, df.train=dat1, df.test=Valid)
```

Extract output.

```{r}
#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
#x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
#x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
#x4.1
#combining all as df
tab.sum.clim_VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.clim_VRI$NDT<-c("NDT1")
tab.sum.clim_VRI 

table.glm.clim_VRI.NDT1_set_ALL3<-rbind(table.glm.clim_VRI.NDT1_set1_2, tab.sum.clim_VRI) #Should have 40,069 rows

```

Save.
```{r}
write.csv(table.glm.clim_VRI.NDT1_set_ALL3, file="D:\\Fire\\fire_data\\raw_data\\table.glm.clim_VRI.NDT1_ALL3.csv")
```

Bring the prior data back in.

Save.
```{r}
table.glm.clim_VRI.NDT1_set_ALL1_2<-read.csv(file="D:\\Fire\\fire_data\\raw_data\\table.glm.clim_VRI.NDT1_ALL1_2.csv")
head(table.glm.clim_VRI.NDT1_set_ALL1_2)
table.glm.clim_VRI.NDT1_set_ALL1_2<-table.glm.clim_VRI.NDT1_set_ALL1_2[-1]
```

Combine.

```{r}
table.glm.clim_VRI.NDT1_set_ALL1_2_3<-rbind(table.glm.clim_VRI.NDT1_set_ALL1_2, table.glm.clim_VRI.NDT1_set_ALL3)
```

Now calculate meanAIC and delatAIC, and mean AUC.

```{r}
table.glm.clim_VRI.NDT1_set_ALL_summary<- table.glm.clim_VRI.NDT1_set_ALL1_2_3%>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

table.glm.clim_VRI.NDT1_set_ALL_summary_2<- table.glm.clim_VRI.NDT1_set_ALL_summary %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))
```

Save summary.

```{r}
write.csv(table.glm.clim_VRI.NDT1_set_ALL_summary_2, file = "D:\\Fire\\fire_data\\raw_data\\AIC_clim_VRI.NDT1_set_ALL_summary_2.csv")
```


#AUC values for prior models with subset of variables were between 0.59-0.68.

#Now repeat for all.poss.mods.infra_landuse_NDT1b
There are not nearly as many models to compare, so we should not need to divide the number of runs ups. Try running it all in one go of 100.

```{r}
########### 2. Distance to Infrastructure ############
#Create empty table
table.glm.infra.lu.simple <- data.frame (matrix (ncol = 5, nrow = 0))
colnames (table.glm.infra.lu.simple) <- c ("model", "edf", "aic", "auc.valid", "NDT")


#
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- dat_lightning_t %>% dplyr::filter(ntrl_ds ==zones1[h])

#for (i in 1: length(all.poss.mods.infra)){
#  print(paste((all.poss.mods.infra[i]), (zones1[h]), sep=" "))
  
for (i in 1: length(zones1)){
  print(paste((all.poss.mods.infra_landuse_NDT1b[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(fire_pres, fire_veg, !!variables_all_infra_landuse_NDT1)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="fire_pres") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.infra_landuse_NDT1b, big.mod, df.train=dat1, df.test=Valid)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#auc from validation data
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#combining all as df
tab.sum.infra.lu <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], auc.valid=x4.1)
tab.sum.infra.lu$NDT<-c("NDT1")
tab.sum.infra.lu 

table.glm.infra.lu.simple<-rbind(table.glm.infra.lu.simple, tab.sum.infra.lu)

}
}
}
```

Now that we have run the model 100 times, we want the average AIC and AUC for each variable combination. Also determine deltaAIC.

```{r}
head(table.glm.infra.lu.simple)
table(table.glm.infra.lu.simple$model) # 100 per model

AIC_lightning_NDT1_t_ignitereed_infra<-table.glm.infra.lu.simple

AIC_lightning_NDT1_t_ignitereed_summary_infra<- AIC_lightning_NDT1_t_ignitereed_infra %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic),
            meanAUC=mean(auc.valid),
            sdAUC=sd(auc.valid),
            )

AIC_lightning_NDT1_t_ignitereed_summary_infra2<- AIC_lightning_NDT1_t_ignitereed_summary_infra %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_NDT1_t_ignitereed_summary_infra2)
```

Save to computer.

```{r}
write.csv(AIC_lightning_NDT1_t_ignitereed_summary_infra2, file="D:\\Fire\\fire_data\\raw_data\\AIC_lightning_NDT1_t_ignitereed_summary_infra.csv")
```

Determine the top models.

#1. Climate and VRI
climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + live_stand_volume_125:proj_age_1

Lots of similar top models, with all of the same first 15 terms. We will use the top AIC and work with this one.

#2. Infrastructure 
dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2

This is the top model, with the next deltaAIC of 3.7, so this is the one.

#3. DEM
slope + aspect_cos + elevation + aspect_cos:elevation

This was the top DEM model prior. We will work with this.

#Next investigation
Because there would be far too many models to investigate including all variables and their interactions, we will start with the above and make educated guesses for what may need to be enhanced.

```{r}
dat_lightning_t_NDT1<-subset(dat_lightning_t, dat_lightning_t$ntrl_ds=="NDT1")

#Divide data into training and valid
prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(dat_lightning_t_NDT1$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- dat_lightning_t_NDT1[ trainIndex,]
   Valid <- dat_lightning_t_NDT1[-trainIndex,]

#Run model using dat1
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + live_stand_volume_125:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6160.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Begin removing least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6158.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1  + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6156.6

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.783 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1  + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6143.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6142.4

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6140.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least significant interaction
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6869--> BAD!

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#REVERT
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6140.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)


#Previous top model
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6146.98

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.7556 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Best model
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6140.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.75 --> good fit!
   
Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

```

Remove NAs and tun multiple times.

```{r}
#Remove NAs to ensure all same data used so we can compare AICs
NDT1_t_ignite<-dat_lightning_t_NDT1 %>% drop_na(climate1, climate2, proj_height_1, live_stand_volume_125, proj_age_1, dist_mun, dist_dam, dist_nat, dist_mine, vegtype2, bclcs_level_5_2, slope, aspect_cos, elevation)

#Run Model again with this data; but uses all data here
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = NDT1_t_ignite)

Anova(model.NDT1, type=3)
#Anova(model.NDT1, type=3, singular.ok = TRUE)

# model diagnostic plots
binnedplot (fitted(model.NDT1), 
            residuals(model.NDT1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


NDT1_t_ignite$resids<-resid(model.NDT1)

binnedplot (NDT1_t_ignite$live_stand_volume_125, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_t_ignite$climate1, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation
visreg(model.NDT1, "climate1", by="climate2")
visreg(model.NDT1, "climate1", by="proj_age_1")
visreg(model.NDT1, "climate1", by="proj_height_1")

visreg(model.NDT1, "climate2", by="climate1")
visreg(model.NDT1, "climate2", by="proj_age_1")

visreg(model.NDT1, "slope")
visreg(model.NDT1, "aspect_cos")
visreg(model.NDT1, "elevation")

visreg(model.NDT1, "live_stand_volume_125", by="vegtype2", overlay=TRUE, ylim=c(-10,10))

visreg(model.NDT1, "proj_age_1", by="climate2")
visreg(model.NDT1, "proj_age_1", by="climate1")
visreg(model.NDT1, "proj_age_1", by="proj_height_1")

visreg(model.NDT1, "proj_height_1", by="climate1")
visreg(model.NDT1, "proj_height_1", by="proj_age_1")

#dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2

visreg(model.NDT1, "dist_mun", by="bclcs_level_5_2", overlay=TRUE) #look into these extreme points
visreg(model.NDT1, "dist_dam")
visreg(model.NDT1, "dist_nat", by="bclcs_level_5_2", overlay=TRUE)
visreg(model.NDT1, "dist_mine")

visreg(model.NDT1, "bclcs_level_5_2", by="dist_nat")
visreg(model.NDT1, "bclcs_level_5_2", by="dist_mun")

```


We should repeat the above several times and take the mean of the coefficients.

```{r}
summary(model.NDT1)

#Create a new blank table and get AUC too
top_mod_table_NDT1_light_t_ALL <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1_light_t_ALL ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_proj_height_1", "coef_live_stand_volume_125", "coef_proj_age_1",  "coef_dist_mun", "coef_dist_dam", "coef_dist_nat", "coef_dist_mine", "coef_bclcs_level_5_2OP", "coef_bclcs_level_5_2SP", "coef_slope", "coef_aspect_cos", "coef_elevation", "coef_climate1:climate2 ", "coef_climate1:proj_height_1", "coef_climate1:proj_age_1", "coef_climate2:proj_age_1", "coef_proj_height_1:proj_age_1", "coef_dist_mun:bclcs_level_5_2OP", "coef_dist_mun:bclcs_level_5_2SP", "coef_dist_nat:bclcs_level_5_2OP", "coef_dist_nat:bclcs_level_5_2SP", "coef_dist_mine:bclcs_level_5_2OP", "coef_dist_mine:bclcs_level_5_2SP", "AUC")
```

Let's run it 500 times to get good mean values.

```{r}

for (g in 1:500){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(NDT1_t_ignite$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- NDT1_t_ignite[ trainIndex,]
   Valid <- NDT1_t_ignite[-trainIndex,]
   
#Model   
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1_light_t <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_NDT1_light_t ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_proj_height_1", "coef_live_stand_volume_125", "coef_proj_age_1",  "coef_dist_mun", "coef_dist_dam", "coef_dist_nat", "coef_dist_mine", "coef_bclcs_level_5_2OP", "coef_bclcs_level_5_2SP", "coef_slope", "coef_aspect_cos", "coef_elevation", "coef_climate1:climate2 ", "coef_climate1:proj_height_1", "coef_climate1:proj_age_1", "coef_climate2:proj_age_1", "coef_proj_height_1:proj_age_1", "coef_dist_mun:bclcs_level_5_2OP", "coef_dist_mun:bclcs_level_5_2SP", "coef_dist_nat:bclcs_level_5_2OP", "coef_dist_nat:bclcs_level_5_2SP", "coef_dist_mine:bclcs_level_5_2OP", "coef_dist_mine:bclcs_level_5_2SP", "AUC")

##Add data for NDT1
top_mod_table_NDT1_light_t[1,1]<-"lightning"
top_mod_table_NDT1_light_t[1,2]<-"NDT1"
top_mod_table_NDT1_light_t[1,3]<-"Y"
top_mod_table_NDT1_light_t[1,4]<-"fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t[1,5]<- coef(model.NDT1)[1] #Intercept
top_mod_table_NDT1_light_t[1,6]<- coef(model.NDT1)[2] #Climate variable 1
top_mod_table_NDT1_light_t[1,7]<- coef(model.NDT1)[3] #Climate variable 2
top_mod_table_NDT1_light_t[1,8]<- coef(model.NDT1)[4] #I
top_mod_table_NDT1_light_t[1,9]<- coef(model.NDT1)[5] #co
top_mod_table_NDT1_light_t[1,10]<- coef(model.NDT1)[6] #coe
top_mod_table_NDT1_light_t[1,11]<- coef(model.NDT1)[7] #c
top_mod_table_NDT1_light_t[1,12]<- coef(model.NDT1)[8] #
top_mod_table_NDT1_light_t[1,13]<- coef(model.NDT1)[9] #
top_mod_table_NDT1_light_t[1,14]<- coef(model.NDT1)[10] #pr
top_mod_table_NDT1_light_t[1,15]<- coef(model.NDT1)[11] #coeffic
top_mod_table_NDT1_light_t[1,16]<- coef(model.NDT1)[12] #coefficien
top_mod_table_NDT1_light_t[1,17]<- coef(model.NDT1)[13] #coefficien
top_mod_table_NDT1_light_t[1,18]<- coef(model.NDT1)[14] #coefficient 
top_mod_table_NDT1_light_t[1,19]<- coef(model.NDT1)[15] #coe
top_mod_table_NDT1_light_t[1,20]<- coef(model.NDT1)[16] #co
top_mod_table_NDT1_light_t[1,21]<- coef(model.NDT1)[17] #coe
top_mod_table_NDT1_light_t[1,22]<- coef(model.NDT1)[18] #c
top_mod_table_NDT1_light_t[1,23]<- coef(model.NDT1)[19] #co
top_mod_table_NDT1_light_t[1,24]<- coef(model.NDT1)[20] #
top_mod_table_NDT1_light_t[1,25]<- coef(model.NDT1)[21] #
top_mod_table_NDT1_light_t[1,26]<- coef(model.NDT1)[22] #co
top_mod_table_NDT1_light_t[1,27]<- coef(model.NDT1)[23] #c
top_mod_table_NDT1_light_t[1,28]<- coef(model.NDT1)[24] #c
top_mod_table_NDT1_light_t[1,29]<- coef(model.NDT1)[25] #co
top_mod_table_NDT1_light_t[1,30]<- coef(model.NDT1)[26] #
top_mod_table_NDT1_light_t[1,31]<- coef(model.NDT1)[27] #co
top_mod_table_NDT1_light_t[1,32]<- coef(model.NDT1)[28] #coe
top_mod_table_NDT1_light_t[1,33]<- coef(model.NDT1)[29] #c
top_mod_table_NDT1_light_t[1,34]<- mod.auc

top_mod_table_NDT1_light_t_ALL<-rbind(top_mod_table_NDT1_light_t_ALL, top_mod_table_NDT1_light_t)

}

```

Check.
```{r}
head(top_mod_table_NDT1_light_t_ALL)

```

#Save coefficient table

```{r}
write.csv(top_mod_table_NDT1_light_t_ALL, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_ALL.csv")
```

Get mean values.

```{r}
names(top_mod_table_NDT1_light_t_ALL)

top_mod_table_NDT1_light_t_Means<-top_mod_table_NDT1_light_t_ALL %>% summarise_each(funs( mean( .,na.rm = TRUE)))
top_mod_table_NDT1_light_t_Means

top_mod_table_NDT1_light_t_Means[1,1]<-"lightning"
top_mod_table_NDT1_light_t_Means[1,2]<-"NDT1"
top_mod_table_NDT1_light_t_Means[1,3]<-"Treed"
top_mod_table_NDT1_light_t_Means[1,4]<- "fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t_Means
```

Save table.

```{r}
write.csv(top_mod_table_NDT1_light_t_Means, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_Means.csv")
```

Standard deviation.

```{r}
top_mod_table_NDT1_light_t_SD<-top_mod_table_NDT1_light_t_ALL %>% summarise_each(funs( sd( .,na.rm = TRUE)))
top_mod_table_NDT1_light_t_SD

top_mod_table_NDT1_light_t_SD[1,1]<-"lightning"
top_mod_table_NDT1_light_t_SD[1,2]<-"NDT1"
top_mod_table_NDT1_light_t_SD[1,3]<-"Treed"
top_mod_table_NDT1_light_t_SD[1,4]<-"fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1  + climate2:proj_age_1  + proj_height_1:proj_age_1 + dist_mun + dist_dam + dist_nat + dist_mine + bclcs_level_5_2 + dist_mun:bclcs_level_5_2 + dist_nat:bclcs_level_5_2 + dist_mine:bclcs_level_5_2 + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t_SD
```

Save sd coefficient table.

```{r}
write.csv(top_mod_table_NDT1_light_t_SD, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_SD.csv")
```


#Try with reduced variables

```{r}
dat_lightning_t_NDT1<-subset(dat_lightning_t, dat_lightning_t$ntrl_ds=="NDT1")

#Divide data into training and valid
prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(dat_lightning_t_NDT1$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- dat_lightning_t_NDT1[ trainIndex,]
   Valid <- dat_lightning_t_NDT1[-trainIndex,]

#Run model using dat1
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + climate2:proj_age_1 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + live_stand_volume_125:proj_age_1 + dist_infra + dist_infra:roads_km + roads_km  + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6224.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + vegtype2:live_stand_volume_125 + vegtype2:proj_age_1 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6219.0

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:vegtype2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + vegtype2:live_stand_volume_125 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation + aspect_cos:elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6216.3

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:live_stand_volume_125 + climate1:proj_age_1 + climate2:live_stand_volume_125 + vegtype2:live_stand_volume_125 + proj_height_1:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6211.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1 + climate2:live_stand_volume_125 + vegtype2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6209.2

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:climate2 + climate1:proj_height_1 + climate1:proj_age_1 + climate2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6207.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)

#Remove least sig
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1 + climate2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = dat1)

AIC(model.NDT1) #6206.8

#Determine AUC of full model
mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)
   mod.auc #0.74 --> good fit!
   
#Anova(model.NDT1, type=3)
Anova(model.NDT1, type=3, singular.ok = TRUE)


```

Remove NAs and tun multiple times.

```{r}
#Remove NAs to ensure all same data used so we can compare AICs
NDT1_t_ignite<-dat_lightning_t_NDT1 %>% drop_na(climate1, climate2, proj_height_1, live_stand_volume_125, proj_age_1, dist_infra, vegtype2, slope, aspect_cos, elevation)

#Run Model again with this data; but uses all data here
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1 + climate2:live_stand_volume_125 + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = NDT1_t_ignite)

Anova(model.NDT1, type=3)
#Anova(model.NDT1, type=3, singular.ok = TRUE)

model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + roads_km  + slope + aspect_cos + elevation, family = binomial, data = NDT1_t_ignite)

Anova(model.NDT1, type=3)
AIC(model.NDT1) #8297.8
#Anova(model.NDT1, type=3, singular.ok = TRUE)

#Forgot to remove roads as this is ignition by lightning
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra  + slope + aspect_cos + elevation, family = binomial, data = NDT1_t_ignite)

Anova(model.NDT1, type=3)
AIC(model.NDT1) #8317.1 --> does increase AIC substantially when remove roads...

# model diagnostic plots
binnedplot (fitted(model.NDT1), 
            residuals(model.NDT1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


NDT1_t_ignite$resids<-resid(model.NDT1)

binnedplot (NDT1_t_ignite$live_stand_volume_125, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_t_ignite$climate1, 
            NDT1_t_ignite$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + slope + aspect_cos + elevation
visreg(model.NDT1, "climate1", by="proj_age_1")
visreg(model.NDT1, "climate1", by="proj_height_1")
visreg(model.NDT1, "climate2")

visreg(model.NDT1, "vegtype2")
visreg(model.NDT1, "vegtype2", ylim=c(-12,5))

visreg(model.NDT1, "slope")
visreg(model.NDT1, "aspect_cos")
visreg(model.NDT1, "elevation")

visreg(model.NDT1, "live_stand_volume_125")

visreg(model.NDT1, "proj_age_1", by="climate1")
visreg(model.NDT1, "proj_age_1", by="proj_height_1")

visreg(model.NDT1, "proj_height_1", by="climate1")
visreg(model.NDT1, "proj_height_1", by="proj_age_1")

visreg(model.NDT1, "dist_infra")

```



We should repeat the above several times and take the mean of the coefficients.

```{r}
summary(model.NDT1)

#Create a new blank table and get AUC too
top_mod_table_NDT1_light_t_ALL <- data.frame (matrix (ncol = 21, nrow = 0))
colnames (top_mod_table_NDT1_light_t_ALL ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_proj_height_1", "coef_live_stand_volume_125", "coef_proj_age_1",  "coef_dist_infra", "coef_slope", "coef_aspect_cos", "coef_elevation",  "coef_climate1:proj_height_1", "coef_climate1:proj_age_1",  "coef_proj_height_1:proj_age_1", "AUC")
```

Let's run it 500 times to get good mean values.

```{r}

for (g in 1:500){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(NDT1_t_ignite$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- NDT1_t_ignite[ trainIndex,]
   Valid <- NDT1_t_ignite[-trainIndex,]
   
#Model   
model.NDT1<-glm(fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + slope + aspect_cos + elevation, family = binomial, data = dat1) 

mod.valid <- predict.glm(model.NDT1, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"fire_pres"], mod.valid)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_NDT1_light_t <- data.frame (matrix (ncol = 21, nrow = 0))
colnames (top_mod_table_NDT1_light_t ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_proj_height_1", "coef_live_stand_volume_125", "coef_proj_age_1",  "coef_dist_infra", "coef_slope", "coef_aspect_cos", "coef_elevation",  "coef_climate1:proj_height_1", "coef_climate1:proj_age_1",  "coef_proj_height_1:proj_age_1", "AUC")

##Add data for NDT1
top_mod_table_NDT1_light_t[1,1]<-"lightning"
top_mod_table_NDT1_light_t[1,2]<-"NDT1"
top_mod_table_NDT1_light_t[1,3]<-"Y"
top_mod_table_NDT1_light_t[1,4]<-"fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t[1,5]<- coef(model.NDT1)[1] #Intercept
top_mod_table_NDT1_light_t[1,6]<- coef(model.NDT1)[2] #Climate variable 1
top_mod_table_NDT1_light_t[1,7]<- coef(model.NDT1)[3] #Climate variable 2
top_mod_table_NDT1_light_t[1,8]<- coef(model.NDT1)[4] #I
top_mod_table_NDT1_light_t[1,9]<- coef(model.NDT1)[5] #co
top_mod_table_NDT1_light_t[1,10]<- coef(model.NDT1)[6] #coe
top_mod_table_NDT1_light_t[1,11]<- coef(model.NDT1)[7] #c
top_mod_table_NDT1_light_t[1,12]<- coef(model.NDT1)[8] #
top_mod_table_NDT1_light_t[1,13]<- coef(model.NDT1)[9] #
top_mod_table_NDT1_light_t[1,14]<- coef(model.NDT1)[10] #pr
top_mod_table_NDT1_light_t[1,15]<- coef(model.NDT1)[11] #coeffic
top_mod_table_NDT1_light_t[1,16]<- coef(model.NDT1)[12] #coefficien
top_mod_table_NDT1_light_t[1,17]<- coef(model.NDT1)[13] #coefficien
top_mod_table_NDT1_light_t[1,18]<- coef(model.NDT1)[14] #coefficient 
top_mod_table_NDT1_light_t[1,19]<- coef(model.NDT1)[15] #coe
top_mod_table_NDT1_light_t[1,20]<- coef(model.NDT1)[16] #co
top_mod_table_NDT1_light_t[1,21]<- mod.auc

top_mod_table_NDT1_light_t_ALL<-rbind(top_mod_table_NDT1_light_t_ALL, top_mod_table_NDT1_light_t)

}

```

Check.
```{r}
head(top_mod_table_NDT1_light_t_ALL)

```

#Save coefficient table

```{r}
write.csv(top_mod_table_NDT1_light_t_ALL, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_ALL_Jan.csv")
```

Get mean values.

```{r}
names(top_mod_table_NDT1_light_t_ALL)

top_mod_table_NDT1_light_t_Means<-top_mod_table_NDT1_light_t_ALL %>% summarise_each(funs( mean( .,na.rm = TRUE)))
top_mod_table_NDT1_light_t_Means

top_mod_table_NDT1_light_t_Means[1,1]<-"lightning"
top_mod_table_NDT1_light_t_Means[1,2]<-"NDT1"
top_mod_table_NDT1_light_t_Means[1,3]<-"Treed"
top_mod_table_NDT1_light_t_Means[1,4]<- "fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t_Means
```

Save table.

```{r}
write.csv(top_mod_table_NDT1_light_t_Means, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_Means_Jan.csv")
```

Standard deviation.

```{r}
top_mod_table_NDT1_light_t_SD<-top_mod_table_NDT1_light_t_ALL %>% summarise_each(funs( sd( .,na.rm = TRUE)))
top_mod_table_NDT1_light_t_SD

top_mod_table_NDT1_light_t_SD[1,1]<-"lightning"
top_mod_table_NDT1_light_t_SD[1,2]<-"NDT1"
top_mod_table_NDT1_light_t_SD[1,3]<-"Treed"
top_mod_table_NDT1_light_t_SD[1,4]<-"fire_pres ~ climate1 + climate2 + vegtype2 + proj_height_1 + live_stand_volume_125 + proj_age_1 + climate1:proj_height_1 + climate1:proj_age_1  + proj_height_1:proj_age_1 + dist_infra + slope + aspect_cos + elevation" 
top_mod_table_NDT1_light_t_SD
```

Save sd coefficient table.

```{r}
write.csv(top_mod_table_NDT1_light_t_SD, file="D:\\Fire\\fire_data\\raw_data\\top_mod_table_NDT1_light_t_SD_Jan.csv")
```

