---
title: "fire_escape_model_fits_by_NDT_data_prep"
author: "Cora Skaien"
date: "25/07/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!--
Copyright 2021 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->

#=================================
#  Script Name: 12_fire_escape_model_fits_by_NDT_data_prep.R
#  Script Version: 1.0
#  Script Purpose: Data prep for other variables for escape models.
#  Script Author: Cora Skaien, Ecological Modeling Specialist, Forest Analysis and Inventory Branch, B.C. Ministry of Forests, Lands, and Natural Resource Operations.
#=================================

#Overview
Similar to the ignition_models_fit_by_NDT file, we will be selecting the top variables for models predicting whether or not fires escaped or not, defined currently as fires that have exceeded 1 ha in size. Note, this code could also apply to the cut off of 3 hectares and 10 hectares with simple modifications as the data is already prepared for these cutoffs.

```{r}
#Load relevant libraries
library(sf)
library(tidyverse)
library(ggplot2)
library (ggcorrplot)
library (RPostgreSQL)
library (rpostgis)
library (dplyr)
library (lme4)
library (arm)
library(ggpubr)
library(mgcv)
library(nlme)
library(purrr)
library(tidyr)
library(caret)
library(pROC)
library(keyring)
library(ggcorrplot) 
library (kableExtra)
library (data.table)
library (DBI)
library (RPostgreSQL)
library (dplyr)
library (ggplot2)
library (here)
library(AICcmodavg)
library(caret)
library(pROC)
library(rje)
library(base)
library(car)

source(here::here("R/functions/R_Postgres.R"))
```

Now we must bring in the data that we created at the end of 09_fire_escape_data_prep. These will be the same files as those used in 10_escape_climate_variable_selection.

```{r}
#Lightning-caused fires
Escape_data_lightning<-read.csv("D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_lightning_Oct.csv")
head(Escape_data_lightning)
table(Escape_data_lightning$bclcs_level_2)

#If continuing from last file (09_fire_escape_data_prep)
Escape_data_lightning<-dat_lightning_escape_2

#Person-caused fires
Escape_data_person<-read.csv("D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_person_Oct.csv")
head(Escape_data_person)

#If continuing from last file (09_fire_escape_data_prep)
Escape_data_person<-dat_person_escape_2

```

We will perform model separately for lightning and person caused fires, as well as for treed and not treed areas, resulting in 4 total models to be prepared for each NDT (similar to in ignition_models_fit_by_NDT). Note, however, that there are insufficient person-caused fires in NDT5 and this zone will not be modelled for this subset.

#Climate variable selection review
In the script "escape_climate_variable_selection.R", we performed an AIC and ROC analysis for each BEC zone including presence/available fire ignition points and a variety of climate variables. For this analysis, we split the data into a training and a validation data set where 75% of the data was used for training and 25% was used for validation. We then fit the model and extracted the AIC and AUC values. This was repeated 100 times and at the end we calculated the average AIC and AUC values. The climate variable that consistently resulted in the lowest average AIC value is used in this analysis. We will load tables for person and lightning caused is a summary of which climate variables fitted best for each BEC zone. 

Note: Some climate variables resulted in delta AIC values that were very similar and had much less than 2 points difference. Also, the variable with the smallest AIC value did not always have the best AUC value. Regardless of these two issues, we decided to take the climate variable with the smallest average AIC for simplicity. Results will be loaded in for each AIC table. These files were manipulated manually and then saved on to the drive before being uploaded (i.e., it is a simplified table from that generated in the last file, escape_climate_variable_selection; code for uploading not included prior).


```{r, AIC table, echo = F, message = F, eval = T}

climate_variables_lightning_escape<-read.csv("D:/Fire/fire_data/raw_data/ClimateBC_Data/escape_climate_lightning_topAIC.csv")
climate_variables_person_escape<-read.csv("D://Fire//fire_data//raw_data//ClimateBC_Data//escape_climate_person_topAIC.csv")

head(climate_variables_lightning_escape) 
head(climate_variables_person_escape) 

kable (climate_variables_lightning_escape,
       caption = "<b>Table 3. Top candidate climate variables for the escape models for lightning caused fires as selected through an AIC analysis for each BEC zone.<b>",
       digits = 2) %>%
  kable_styling (position = "left",
                 bootstrap_options = c("striped", "hover"),
                 fixed_thead = T,
                 full_width = F,
                 font_size = 11)

kable (climate_variables_person_escape,
       caption = "<b>Table 4. Top candidate climate variables for escape models for person caused fires as selected through an AIC analysis for each BEC zone.<b>",
       digits = 2) %>%
  kable_styling (position = "left",
                 bootstrap_options = c("striped", "hover"),
                 fixed_thead = T,
                 full_width = F,
                 font_size = 11)

```

When doing the below analyses, it was noticed that disturbed areas often get eliminated when NAs are removed from the final data used for the model. Here, we investigate what variables are missing.

```{r}
##Change all NA for this vegtype to 0
Escape_data_lightning <- within(Escape_data_lightning, live_stand_volume_125[is.na(live_stand_volume_125) & vegtype == 'D'] <- 0)
Escape_data_person <- within(Escape_data_person, live_stand_volume_125[is.na(live_stand_volume_125) & vegtype == 'D'] <- 0)
##Because there will be no effect of stand volume on disturbed veg type, an interaction between these two variables should be included when both are in the model.

```

```{r}
head(Escape_data_person)
```
Now we will create additional columns that have the climate1 and climate2 variables indicated as the top variables for climate. 

```{r}
names(Escape_data_lightning)
unique(Escape_data_lightning$ntrl_ds)
Escape_data_lightning$ntrl_ds<-as.factor(Escape_data_lightning$ntrl_ds)
Escape_data_lightning$ntrl_ds_numeric<-as.numeric(Escape_data_lightning$ntrl_ds)
table(Escape_data_lightning$ntrl_ds_numeric)

Escape_data_lightning$ntrl_ds_codes<-paste(Escape_data_lightning$ntrl_ds, Escape_data_lightning$ntrl_ds_numeric)
unique(Escape_data_lightning$ntrl_ds_codes)

## Create empty vector
Escape_data_lightning$climate1<-0
head(Escape_data_lightning)

Escape_data_lightning<-Escape_data_lightning %>%
    mutate(climate1 = case_when(ntrl_ds_numeric == 1 ~ tave09, # NDT1
                                ntrl_ds_numeric == 2 ~ mean_tmax07_tmax08_tmax09, #NDT2
                                ntrl_ds_numeric == 3 ~ tave09, #NDT3
                                ntrl_ds_numeric == 4 ~ mean_ppt05_ppt06_ppt07, # NDT4
                                ntrl_ds_numeric == 5 ~ tave09, # NDT5
                                TRUE ~ NA_real_))

#Repeat for climate 2
Escape_data_lightning$climate2<-0
Escape_data_lightning$ppt09<-as.numeric(Escape_data_lightning$ppt09)

#Perform mutate to get the applicable variable for each row
Escape_data_lightning<-Escape_data_lightning %>%
    mutate(climate2 = case_when(ntrl_ds_numeric == 1 ~ ppt09, # NDT1
                                #ntrl_ds_numeric == 2 ~ , #NDT2
                                ntrl_ds_numeric == 3 ~ ppt09, #NDT3
                                #ntrl_ds_numeric == 4 ~ ppt07, # NDT4
                                ntrl_ds_numeric == 5 ~ ppt09, # NDT5
                                TRUE ~ NA_real_))

head(Escape_data_lightning)

##Change vegtype to factor
Escape_data_lightning$vegtype<-as.factor(Escape_data_lightning$vegtype)

#create new column
Escape_data_lightning$fire_veg<-paste(Escape_data_lightning$fire_pres, Escape_data_lightning$vegtype)

```

Repeat for person-caused fires.

```{r}
names(Escape_data_person)
unique(Escape_data_person$ntrl_ds)
Escape_data_person$ntrl_ds<-as.factor(Escape_data_person$ntrl_ds)
Escape_data_person$ntrl_ds_numeric<-as.numeric(Escape_data_person$ntrl_ds)
table(Escape_data_person$ntrl_ds_numeric)

Escape_data_person$ntrl_ds_codes<-paste(Escape_data_person$ntrl_ds, Escape_data_person$ntrl_ds_numeric)
unique(Escape_data_person$ntrl_ds_codes)
#Compare codes to lightning
unique(dat_lightning_$ntrl_ds_codes) #they are the same

## Create empty vector
Escape_data_person$climate1<-0
head(Escape_data_person)

Escape_data_person<-Escape_data_person %>%
    mutate(climate1 = case_when(ntrl_ds_numeric == 1 ~ tave09, # NDT1
                                ntrl_ds_numeric == 2 ~ tave09, #NDT2
                                ntrl_ds_numeric == 3 ~ mean_tave08_tave09, #NDT3
                                ntrl_ds_numeric == 4 ~ mean_mdc06_mdc07, # NDT4
                                #ntrl_ds_numeric == 5 ~, # NDT5 Insufficient data for escaped fires for NDT5
                                TRUE ~ NA_real_))

#Repeat for climate 2
Escape_data_person$climate2<-0
Escape_data_person$ppt09<-as.numeric((Escape_data_person$ppt09))

#Perform mutate to get the applicable variable for each row
Escape_data_person<-Escape_data_person %>%
    mutate(climate2 = case_when(ntrl_ds_numeric == 1 ~ ppt09, # NDT1
                                #ntrl_ds_numeric == 2 ~ , #NDT2
                                #ntrl_ds_numeric == 3 ~ , #NDT3
                                #ntrl_ds_numeric == 4 ~ , # NDT4
                                #ntrl_ds_numeric == 5 ~ , # NDT5: Insufficient data
                                TRUE ~ NA_real_))

head(Escape_data_person)

##Change vegtype to factor
Escape_data_person$vegtype<-as.factor(Escape_data_person$vegtype)

##Create new variable for fire presence by vegtype
Escape_data_person$fire_veg<-paste(Escape_data_person$fire_pres, Escape_data_person$vegtype)
str(Escape_data_person$fire_veg)
str(Escape_data_person$fire_pres)

```

View plots.

```{r}
p <- ggplot(Escape_data_lightning, aes(aspect, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(aspect_cos, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect_cos") + ylab("Pr (escape)")
p
##Seems to be minimal relationship with aspect overall

p <- ggplot(Escape_data_lightning, aes(slope, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("slope") + ylab("Pr (escape)")
p
#positive association

ggplot(Escape_data_lightning, aes(x = slope)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(escape ~ .)
##Seeing distribution of escapes by slope makes me believe that slope is not a big factor for escapes despite seemingly positive trend prior.


#
p <- ggplot(Escape_data_lightning, aes(aspect_cos*slope, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect_cos*slope") + ylab("Pr (escape)")
p


p <- ggplot(Escape_data_lightning, aes(elevation, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("elevation") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(wind_atfire, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Wind Speed") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(mdc_atfire, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("MDC at fire") + ylab("Pr (escape)")
p
#Unexpectedly weak and negative relationship

```
Also check distance to roads as this may be related to fire-fighting capabilities and efforts.

```{r}
p <- ggplot(Escape_data_lightning, aes(roads_km, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Road Density (km/km2)") + ylab("Pr (escape)")
p

#Fairly weak relationship with a really long tail of more extreme values.
```

VRI.

```{r}
p <- ggplot(Escape_data_lightning, aes(proj_age_1, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("proj_age_1") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(proj_height_1, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("proj_height_1") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(live_stand_volume_125, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("live_stand_volume_125") + ylab("Pr (escape)")
p

```

Top climate variables.

```{r}
p <- ggplot(Escape_data_lightning, aes(tave09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("tave09") + ylab("Pr (escape)")
p #Opposite pattern as expected

p <- ggplot(Escape_data_lightning, aes(ppt09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("ppt09") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(mean_tave07_tave08_tave09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("mean_tave07_tave08_tave09") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(mean_ppt05_ppt06_ppt07, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("mean_ppt05_ppt06_ppt07") + ylab("Pr (escape)")
p
```

#Infrstructure.

```{r}
p <- ggplot(Escape_data_lightning, aes(dist_any, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Any Infrastructure") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(dist_mun, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Municipalities") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(dist_mine, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Mines") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(dist_nat, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Natural Power") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(dist_pow, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Power Lines") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_lightning, aes(dist_dam, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Distance to Dams") + ylab("Pr (escape)")
p
```


Repeat for person-caused fires.

```{r}
p <- ggplot(Escape_data_person, aes(aspect, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(aspect_cos, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect_cos") + ylab("Pr (escape)")
p
##Seems to be minimal relationship with aspect overall

p <- ggplot(Escape_data_person, aes(slope, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("slope") + ylab("Pr (escape)")
p
#positive association

ggplot(Escape_data_person, aes(x = slope)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(escape ~ .)
##Seeing distribution of escapes by slope makes me believe that slope is not a big factor for escapes despite seemingly positive trend prior.


#
p <- ggplot(Escape_data_person, aes(aspect_cos*slope, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect_cos*slope") + ylab("Pr (escape)")
p


p <- ggplot(Escape_data_person, aes(elevation, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("elevation") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(wind_atfire, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Wind Speed") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(mdc_atfire, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("MDC at fire") + ylab("Pr (escape)")
p #weak and negative relationship

p <- ggplot(Escape_data_person, aes(roads_km, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Road Density") + ylab("Pr (escape)")
p #as expected, not a huge relationship on probability of escape
```

Also check distance to roads asthis may be related to fire-fighting capabilities and efforts.

```{r}
p <- ggplot(Escape_data_person, aes(roads_km, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("Road Density (km/km2)") + ylab("Pr (escape)")
p

#Very weak relationship with a really long tail of more extreme values.
```

VRI.

```{r}
p <- ggplot(Escape_data_person, aes(proj_age_1, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("proj_age_1") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(proj_height_1, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("proj_height_1") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(live_stand_volume_125, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("live_stand_volume_125") + ylab("Pr (escape)")
p

```

Climate variables.

```{r}
p <- ggplot(Escape_data_person, aes(tave09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("tave09") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(ppt09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("ppt09") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(mean_tave08_tave09, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("mean_tave08_tave09") + ylab("Pr (escape)")
p

p <- ggplot(Escape_data_person, aes(mean_mdc06_mdc07, as.numeric(escape))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("mean_mdc06_mdc07") + ylab("Pr (escape)")
p

```

Make cos(aspect in degrees) to be the default aspect in case this did not carry over from previous code.

```{r}
##cos makes more sense for aspect, so make this the default in analyses
Escape_data_person$aspect_degrees<-Escape_data_person$aspect
Escape_data_person$aspect<-Escape_data_person$aspect_cos

Escape_data_lightning$aspect_degrees<-Escape_data_lightning$aspect
Escape_data_lightning$aspect<-Escape_data_lightning$aspect_cos

```

#Create new variable for partitioning the data
```{r}
Escape_data_lightning$veg_escape<-paste( Escape_data_lightning$vegtype2,  Escape_data_lightning$escape)
table(Escape_data_lightning$veg_escape)

Escape_data_person$veg_escape<-paste( Escape_data_person$vegtype2,  Escape_data_person$escape)
table(Escape_data_person$veg_escape)

```

#Save data here in case get disconnected from R

```{r}
write.csv(Escape_data_lightning, "D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\Lightning_data_escape_Oct.csv")

write.csv(Escape_data_person, "D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\Person_data_escape_Oct.csv")

#Load back in as needed
Escape_data_lightning<-read.csv("D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\Lightning_data_escape_Oct.csv")
head(Escape_data_lightning)

Escape_data_person<-read.csv("D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\Person_data_escape_Oct.csv")
head(Escape_data_person)
```

## Examining correlation between stand level variables

```{r}
# Examining the relationship between some stand level variables. Volume and height are fairly correlated (0.67) but age and volume are not (0.28) and neither are age and height (0.44). Because volume and height are very close to 0.7 in correlation I will leave out this combination of variables from my treed models. 

Escape_data_lightning_t<- Escape_data_lightning %>% dplyr::filter(bclcs_level_2=="T")
Escape_data_lightning_nt<- Escape_data_lightning %>% dplyr::filter(bclcs_level_2=="N")
Escape_data_lightning_l<- Escape_data_lightning %>% dplyr::filter(bclcs_level_2=="L")

table(Escape_data_lightning$vegtype)
table(Escape_data_lightning_t$vegtype) #either disturbed, open, treed broadleaf, treed conifer, or treed mixed broadleaf and conifer
table(Escape_data_lightning_nt$vegtype) #either disturbed, open or shrub

ggscatter(Escape_data_lightning_t, x = "live_stand_volume_125", y = "proj_age_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "live stand volume", ylab = "Stand age")

ggscatter(Escape_data_lightning_t, x = "live_stand_volume_125", y = "proj_height_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "live stand volume", ylab = "Stand height")

ggscatter(Escape_data_lightning_t, x = "proj_age_1", y = "proj_height_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "proj_age_1", ylab = "Stand height")


##Note that some no tree areas also have tree attributes. This is likely because the majority of the polygon has no trees, but part of the polygon might have trees which are given attributes.
hist(Escape_data_lightning_nt$proj_height_1)
hist(Escape_data_lightning_nt$proj_age_1)
hist(Escape_data_lightning_nt$live_stand_volume_125) #Pretty much all NAs. Can likely assume 0.
Escape_data_lightning_nt$proj_height_1 #Also many NAs. 
Escape_data_lightning_nt$proj_age_1 # Also many NAs. 

hist(Escape_data_lightning_l$proj_height_1)
hist(Escape_data_lightning_l$proj_age_1)
hist(Escape_data_lightning_l$live_stand_volume_125)
## This is ok. Still exclude from models, because majority of polygon will not be treed

head(Escape_data_lightning_t)

```

#Repeat for person caused fires
## Examining correlation between stand level variables
```{r}
# Examining the relationship between some stand level variables. Volume and height are fairly correlated (0.67) but age and volume are not (0.28) and neither are age and height (0.44). Because volume and height are very close to 0.7 in correlation I will leave out this combination of variables from my treed models. 

Escape_data_person_t<- Escape_data_person %>% dplyr::filter(bclcs_level_2=="T")
Escape_data_person_nt<- Escape_data_person %>% dplyr::filter(bclcs_level_2=="N")
Escape_data_person_l<- Escape_data_person %>% dplyr::filter(bclcs_level_2=="L")

table(Escape_data_person$vegtype)
table(Escape_data_person_t$vegtype) #either disturbed, open, treed broadleaf, treed conifer, or treed mixed broadleaf and conifer
table(Escape_data_person_nt$vegtype) #either disturbed, open or shrub

ggscatter(Escape_data_person_t, x = "live_stand_volume_125", y = "proj_age_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "live stand volume", ylab = "Stand age")

ggscatter(Escape_data_person_t, x = "live_stand_volume_125", y = "proj_height_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "live stand volume", ylab = "Stand height")

ggscatter(Escape_data_person_t, x = "proj_age_1", y = "proj_height_1", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "kendall",
          xlab = "proj_age_1", ylab = "Stand height")

##Note that some no tree areas also have tree attributes. This is likely because the majority of the polygon has no trees, but part of the polygon might have trees which are given attributes.
hist(Escape_data_person_nt$proj_height_1)
hist(Escape_data_person_nt$proj_age_1)
hist(Escape_data_person_nt$live_stand_volume_125) #Pretty much all NAs. Can likely assume 0.
Escape_data_person_nt$proj_height_1 #Also many NAs. 
Escape_data_person_nt$proj_age_1 # Also many NAs. 

hist(Escape_data_person_l$proj_height_1)
hist(Escape_data_person_l$proj_age_1)
hist(Escape_data_person_l$live_stand_volume_125)
## This is ok. Still exclude from models, because majority of polygon will not be treed

```

Save the prepped data

```{r}
write.csv(Escape_data_lightning_t, file="D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_lightning_trees_NDT_Oct.csv")

write.csv(Escape_data_lightning_nt, file="D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_lightning_notrees_NDT_Oct.csv")

write.csv(Escape_data_person_t, file="D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_person_trees_NDT_Oct.csv")

write.csv(Escape_data_person_nt, file="D:\\Fire\\fire_data\\raw_data\\ClimateBC_Data\\escape_data_person_notrees_NDT_Oct.csv")

```

############### COMPLETE: MOVE ON TO ANALYSES FOR EACH NDT #################













 
################ PART 2: Person Caused Fires ################

Now, we will make a loop that does something very similar to our last loop, but with the selected climate variable plus other variables of interest. For person caused fires with trees, the variables of interest include:

1. Climate variable(s)
2. Projected Height (proj_height_1)
3. projected age (proj_age_1)  
4. live_stand_volume_125
5. vegtype
6. slope
7. aspect (cos)
8. elevation
9. heatload
10. windspeed (wind_atfire)

Interactions of interest: two-way interactions between climate (1) and vegtype (5); two-way interactions between topography measures (6-8). Road density does not seem to be correlated with escape, but only with ignition, with person-caused fires - so no need to provide this here for the escape models.

This will be done separately for trees and non-treed areas. 

First, let's do this for treed areas (with the person-caused fires dataset).

##We will do each loop separately for each NDT zone given the large number of possible models for each zone.

First we will create the variable lists that contain all of our variables of interest. These should be the same as Part 1: Lightning Caused Fires.

```{r}
##Create variable lists to be used in the model loop.
variables_all<-c(climate1 = "climate1", climate2 = "climate2", proj_height_1 = "proj_height_1", proj_age_1 = "proj_age_1", live_stand_volume_125 = "live_stand_volume_125", slope = "slope", aspect = "aspect", elevation ="elevation", vegtype = "vegtype", wind_atfire = "wind_atfire", heatload="heatload") 

variables_all_c1<-c(climate1 = "climate1", proj_height_1 = "proj_height_1", proj_age_1 = "proj_age_1", live_stand_volume_125 = "live_stand_volume_125", slope = "slope", aspect = "aspect", elevation ="elevation", vegtype = "vegtype", wind_atfire = "wind_atfire", heatload="heatload") 


vars.clim<-c("climate1")
vars.clim.vegtype<-c("climate1", "vegtype")
vars.oth<-c("proj_height_1", "proj_age_1", "live_stand_volume_125") 
vars.topo<-c("slope", "aspect", "elevation")
vars.heatload<-c("heatload")
vars.wind<-c("wind_atfire")

#Also for later with 2 climate variables
vars.clim.vegtype2<-c("climate1", "climate2","vegtype")
vars.clim.vegtype2b<-c("climate1", "climate2")

##Create interaction for climate and vegtype
inputs.me <- c(vars.clim.vegtype)
inputs.me2 <- c(vars.clim.vegtype2)
inputs.me2b <- c(vars.clim.vegtype2b)
```

#Two-way interactions should be the same as Part 1: Lightning Caused Fires

Let's work with one NDT at a time. 

Because of the large number of models with all variables included, we will test the climate and vegtype first, then the VRI variables, then the topography variables. Then we will then combine the top models and add windspeed, and test AIC with and without windspeed. 

############### Part 3 of 4 Model Series: Person Caused Fires, Trees ##########

NDT 1 has 2 variables, NDT 2-5 have one

Select first NDT: NDT1

```{r}
zones1<-c("NDT1") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype2)){
  print(paste((all.poss.mods.clim.vegtype2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT1")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for VRI data

```{r}

########### 2. VRI ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.VRI)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1b <- unlist(sapply(mods.fit, '[', 1))
x1b
#Aic for models
x3b <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3b
#auc from validation data
x4b <- unlist(sapply(mods.fit, '[', 4))
x4b
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1b, edf=x3b[,1], aic=x3b[,2], auc.valid=x4b)
tab.sum.VRI$NDT<-c("NDT1")
tab.sum.VRI$delta.aic<- tab.sum.VRI$aic - (min(tab.sum.VRI$aic))
tab.sum.VRI 

```

#Now repeat for topography

#BElow has issues with heatload not always being present. Remove and try again.

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo$NDT<-c("NDT1")
tab.sum.topo$delta.aic<- tab.sum.topo$aic - (min(tab.sum.topo$aic))
tab.sum.topo

```

#Now combine the datatables and save to computer

```{r}
NDT1_l_models_escape<-rbind(tab.sum.climate, tab.sum.VRI, tab.sum.topo)
NDT1_l_models_escape

write.csv(NDT1_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT1_person_escape_models_treed.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT1_t<-Escape_data_person_t %>%
  filter(ntrl_ds=="NDT1")

NDT1_t2<-NDT1_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT1<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT1_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT1)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT1), 
            residuals(glm_best_NDT1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT1_t2$resids<-resid(glm_best_NDT1)

binnedplot (NDT1_t2$live_stand_volume_125, 
            NDT1_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_t2$climate1, 
            NDT1_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT1_t2$live_stand_volume_125,NDT1_t2$escape)
curve(invlogit(coef(glm_best_NDT1)[1] +coef(glm_best_NDT1)[2]*mean(NDT1_t2$climate1) + coef(glm_best_NDT1)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT1_t2$climate1,NDT1_t2$escape)
curve(invlogit(coef(glm_best_NDT1)[1] +coef(glm_best_NDT1)[2]*x + coef(glm_best_NDT1)[3]*mean(NDT1_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT1
top_mod_table[1,1]<-"NDT1"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT1)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT1)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT1)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT1)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT1)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT1)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT1)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT1)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT1)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT1)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT1)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT1)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT1)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT1 Model Selection Complete ###################

```
 
 
## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1

Select next NDT: NDT2

```{r}
zones1<-c("NDT2") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT2")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for VRI data

```{r}

########### 2. VRI ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.VRI)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1b <- unlist(sapply(mods.fit, '[', 1))
x1b
#Aic for models
x3b <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3b
#auc from validation data
x4b <- unlist(sapply(mods.fit, '[', 4))
x4b
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1b, edf=x3b[,1], aic=x3b[,2], auc.valid=x4b)
tab.sum.VRI$NDT<-c("NDT2")
tab.sum.VRI$delta.aic<- tab.sum.VRI$aic - (min(tab.sum.VRI$aic))
tab.sum.VRI 

```

#Now repeat for topography

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo$NDT<-c("NDT2")
tab.sum.topo$delta.aic<- tab.sum.topo$aic - (min(tab.sum.topo$aic))
tab.sum.topo

```

#Now combine the datatables and save to computer

```{r}
NDT2_l_models_escape<-rbind(tab.sum.climate, tab.sum.VRI, tab.sum.topo)
NDT2_l_models_escape

write.csv(NDT2_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT2_person_escape_models_treed.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT2_t<-Escape_data_person_t %>%
  filter(ntrl_ds=="NDT2")

NDT2_t2<-NDT2_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT2<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT2_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT2)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT2), 
            residuals(glm_best_NDT2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT2_t2$resids<-resid(glm_best_NDT2)

binnedplot (NDT2_t2$live_stand_volume_125, 
            NDT2_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT2_t2$climate1, 
            NDT2_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT2_t2$live_stand_volume_125,NDT2_t2$escape)
curve(invlogit(coef(glm_best_NDT2)[1] +coef(glm_best_NDT2)[2]*mean(NDT2_t2$climate1) + coef(glm_best_NDT2)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT2_t2$climate1,NDT2_t2$escape)
curve(invlogit(coef(glm_best_NDT2)[1] +coef(glm_best_NDT2)[2]*x + coef(glm_best_NDT2)[3]*mean(NDT2_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT2
top_mod_table[1,1]<-"NDT2"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT2)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT2)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT2)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT2)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT2)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT2)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT2)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT2)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT2)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT2)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT2)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT2)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT2)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT2 Model Selection Complete ###################

```
 
 
 
## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1, NDT2

Select next NDT: NDT3

```{r}
zones1<-c("NDT3") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT3")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for VRI data

```{r}

########### 2. VRI ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.VRI)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1b <- unlist(sapply(mods.fit, '[', 1))
x1b
#Aic for models
x3b <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3b
#auc from validation data
x4b <- unlist(sapply(mods.fit, '[', 4))
x4b
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1b, edf=x3b[,1], aic=x3b[,2], auc.valid=x4b)
tab.sum.VRI$NDT<-c("NDT3")
tab.sum.VRI$delta.aic<- tab.sum.VRI$aic - (min(tab.sum.VRI$aic))
tab.sum.VRI 

```

#Now repeat for topography

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo$NDT<-c("NDT3")
tab.sum.topo$delta.aic<- tab.sum.topo$aic - (min(tab.sum.topo$aic))
tab.sum.topo

```

#Now combine the datatables and save to computer

```{r}
NDT3_l_models_escape<-rbind(tab.sum.climate, tab.sum.VRI, tab.sum.topo)
NDT3_l_models_escape

write.csv(NDT3_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT3_person_escape_models_treed.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

```{r}
##### TOP MODEL####
NDT3_t<-Escape_data_person_t %>%
  filter(ntrl_ds=="NDT3")

NDT3_t2<-NDT3_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT3<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT3_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT3)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT3), 
            residuals(glm_best_NDT3), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT3_t2$resids<-resid(glm_best_NDT3)

binnedplot (NDT3_t2$live_stand_volume_125, 
            NDT3_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT3_t2$climate1, 
            NDT3_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT3_t2$live_stand_volume_125,NDT3_t2$escape)
curve(invlogit(coef(glm_best_NDT3)[1] +coef(glm_best_NDT3)[2]*mean(NDT3_t2$climate1) + coef(glm_best_NDT3)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT3_t2$climate1,NDT3_t2$escape)
curve(invlogit(coef(glm_best_NDT3)[1] +coef(glm_best_NDT3)[2]*x + coef(glm_best_NDT3)[3]*mean(NDT3_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT3
top_mod_table[1,1]<-"NDT3"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT3)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT3)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT3)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT3)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT3)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT3)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT3)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT3)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT3)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT3)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT3)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT3)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT3)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT3 Model Selection Complete ###################

```
 

## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1, 2 and 3

Select next NDT: NDT4

```{r}
zones1<-c("NDT4") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT4")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for VRI data

```{r}

########### 2. VRI ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.VRI)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1b <- unlist(sapply(mods.fit, '[', 1))
x1b
#Aic for models
x3b <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3b
#auc from validation data
x4b <- unlist(sapply(mods.fit, '[', 4))
x4b
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1b, edf=x3b[,1], aic=x3b[,2], auc.valid=x4b)
tab.sum.VRI$NDT<-c("NDT4")
tab.sum.VRI$delta.aic<- tab.sum.VRI$aic - (min(tab.sum.VRI$aic))
tab.sum.VRI 

```

#Now repeat for topography

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo$NDT<-c("NDT4")
tab.sum.topo$delta.aic<- tab.sum.topo$aic - (min(tab.sum.topo$aic))
tab.sum.topo

```

#Now combine the datatables and save to computer

```{r}
NDT4_l_models_escape<-rbind(tab.sum.climate, tab.sum.VRI, tab.sum.topo)
NDT4_l_models_escape

write.csv(NDT4_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT4_person_escape_models_treed.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT4_t<-Escape_data_person_t %>%
  filter(ntrl_ds=="NDT4")

NDT4_t2<-NDT4_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT4<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT4_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT4)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT4), 
            residuals(glm_best_NDT4), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT4_t2$resids<-resid(glm_best_NDT4)

binnedplot (NDT4_t2$live_stand_volume_125, 
            NDT4_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT4_t2$climate1, 
            NDT4_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT4_t2$live_stand_volume_125,NDT4_t2$escape)
curve(invlogit(coef(glm_best_NDT4)[1] +coef(glm_best_NDT4)[2]*mean(NDT4_t2$climate1) + coef(glm_best_NDT4)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT4_t2$climate1,NDT4_t2$escape)
curve(invlogit(coef(glm_best_NDT4)[1] +coef(glm_best_NDT4)[2]*x + coef(glm_best_NDT4)[3]*mean(NDT4_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT4
top_mod_table[1,1]<-"NDT4"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT4)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT4)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT4)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT4)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT4)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT4)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT4)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT4)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT4)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT4)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT4)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT4)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT4)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT4 Model Selection Complete ###################

```
 
 


## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1, NDT3

Select next NDT: NDT5

INSUFFICIENT NUMBERS. CANNOT DO. ZERO ESCAPED.

Problems because not two levels, likely in vegtype.
```{r}
Escape_data_person_t_NDT5<-subset(Escape_data_person_t, Escape_data_person_t$ntrl_ds=="NDT5")
head(Escape_data_person_t_NDT5)
table(Escape_data_person_t_NDT5$vegtype)
table(Escape_data_person_t_NDT5$escape)
table(Escape_data_person_t_NDT5$fire_veg)

```


```{r}
zones1<-c("NDT5") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT5")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for VRI data

```{r}

########### 2. VRI ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.VRI)){
  print(paste((all.poss.mods.VRI[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1b <- unlist(sapply(mods.fit, '[', 1))
x1b
#Aic for models
x3b <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3b
#auc from validation data
x4b <- unlist(sapply(mods.fit, '[', 4))
x4b
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1b, edf=x3b[,1], aic=x3b[,2], auc.valid=x4b)
tab.sum.VRI$NDT<-c("NDT5")
tab.sum.VRI$delta.aic<- tab.sum.VRI$aic - (min(tab.sum.VRI$aic))
tab.sum.VRI 

```

#Now repeat for topography

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_t %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo)){
  print(paste((all.poss.mods.topo[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo$NDT<-c("NDT5")
tab.sum.topo$delta.aic<- tab.sum.topo$aic - (min(tab.sum.topo$aic))
tab.sum.topo

```

#Now combine the datatables and save to computer

```{r}
NDT5_l_models_escape<-rbind(tab.sum.climate, tab.sum.VRI, tab.sum.topo)
NDT5_l_models_escape

write.csv(NDT5_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT5_person_escape_models_treed.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

```{r}
##### TOP MODEL####
NDT5_t<-Escape_data_person_t %>%
  filter(ntrl_ds=="NDT5")

NDT5_t2<-NDT5_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT5<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT5_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT5)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT5), 
            residuals(glm_best_NDT5), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT5_t2$resids<-resid(glm_best_NDT5)

binnedplot (NDT5_t2$live_stand_volume_125, 
            NDT5_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT5_t2$climate1, 
            NDT5_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT5_t2$live_stand_volume_125,NDT5_t2$escape)
curve(invlogit(coef(glm_best_NDT5)[1] +coef(glm_best_NDT5)[2]*mean(NDT5_t2$climate1) + coef(glm_best_NDT5)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT5_t2$climate1,NDT5_t2$escape)
curve(invlogit(coef(glm_best_NDT5)[1] +coef(glm_best_NDT5)[2]*x + coef(glm_best_NDT5)[3]*mean(NDT5_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT5
top_mod_table[1,1]<-"NDT5"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT5)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT5)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT5)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT5)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT5)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT5)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT5)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT5)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT5)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT5)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT5)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT5)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT5)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT5 Model Selection Complete ###################

```
 



############### Part 4 of 4 Model Series: person Caused Fires, No Trees ##########

For person caused fires with no trees, the variables of interest include:

1. Climate variable(s)
2. vegtype
3. slope
4. aspect (cos)
5. elevation
6. heatload
7. windspeed (wind_atfire)

Interactions of interest: two-way interactions between climate (1) and vegtype (2); two-way interactions between topography measures (3-5). 

If heatload did not load properly, then use this code and remove. Heatload has not been in a top model yet, so ok to remove.
```{r}
##Create variable lists to be used in the model loop.
variables_all<-c(climate1 = "climate1", climate2 = "climate2", proj_height_1 = "proj_height_1", proj_age_1 = "proj_age_1", live_stand_volume_125 = "live_stand_volume_125", slope = "slope", aspect = "aspect", elevation ="elevation", vegtype = "vegtype", wind_atfire = "wind_atfire") 

variables_all_c1<-c(climate1 = "climate1", proj_height_1 = "proj_height_1", proj_age_1 = "proj_age_1", live_stand_volume_125 = "live_stand_volume_125", slope = "slope", aspect = "aspect", elevation ="elevation", vegtype = "vegtype", wind_atfire = "wind_atfire") 
```


NDT 1 has 2 variables, NDT 2-5 have one

Select first NDT: NDT1

```{r}
zones1<-c("NDT1") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype2)){
  print(paste((all.poss.mods.clim.vegtype2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT1")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for topography

```{r}

########### 2. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo2 <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo2$NDT<-c("NDT1")
tab.sum.topo2$delta.aic<- tab.sum.topo2$aic - (min(tab.sum.topo2$aic))
tab.sum.topo2

```

#Now combine the datatables and save to computer

```{r}
NDT1_l_models_escape<-rbind(tab.sum.climate, tab.sum.topo2)
NDT1_l_models_escape

write.csv(NDT1_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT1_person_escape_models_notrees.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT1_t<-Escape_data_person_nt %>%
  filter(ntrl_ds=="NDT1")

NDT1_t2<-NDT1_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT1<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT1_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT1)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT1), 
            residuals(glm_best_NDT1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT1_t2$resids<-resid(glm_best_NDT1)

binnedplot (NDT1_t2$live_stand_volume_125, 
            NDT1_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT1_t2$climate1, 
            NDT1_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT1_t2$live_stand_volume_125,NDT1_t2$escape)
curve(invlogit(coef(glm_best_NDT1)[1] +coef(glm_best_NDT1)[2]*mean(NDT1_t2$climate1) + coef(glm_best_NDT1)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT1_t2$climate1,NDT1_t2$escape)
curve(invlogit(coef(glm_best_NDT1)[1] +coef(glm_best_NDT1)[2]*x + coef(glm_best_NDT1)[3]*mean(NDT1_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT1
top_mod_table[1,1]<-"NDT1"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT1)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT1)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT1)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT1)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT1)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT1)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT1)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT1)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT1)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT1)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT1)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT1)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT1)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT1 Model Selection Complete ###################

```
 
 
 
## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1

Select next NDT: NDT2

```{r}
zones1<-c("NDT2") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT2")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```


#Now repeat for topography

```{r}

########### 3. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo2 <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo2$NDT<-c("NDT2")
tab.sum.topo2$delta.aic<- tab.sum.topo2$aic - (min(tab.sum.topo2$aic))
tab.sum.topo2

```

#Now combine the datatables and save to computer

```{r}
NDT2_l_models_escape<-rbind(tab.sum.climate, tab.sum.topo2)
NDT2_l_models_escape

write.csv(NDT2_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT2_person_escape_models_notrees.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT2_t<-Escape_data_person_nt %>%
  filter(ntrl_ds=="NDT2")

NDT2_t2<-NDT2_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT2<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT2_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT2)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT2), 
            residuals(glm_best_NDT2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT2_t2$resids<-resid(glm_best_NDT2)

binnedplot (NDT2_t2$live_stand_volume_125, 
            NDT2_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT2_t2$climate1, 
            NDT2_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT2_t2$live_stand_volume_125,NDT2_t2$escape)
curve(invlogit(coef(glm_best_NDT2)[1] +coef(glm_best_NDT2)[2]*mean(NDT2_t2$climate1) + coef(glm_best_NDT2)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT2_t2$climate1,NDT2_t2$escape)
curve(invlogit(coef(glm_best_NDT2)[1] +coef(glm_best_NDT2)[2]*x + coef(glm_best_NDT2)[3]*mean(NDT2_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT2
top_mod_table[1,1]<-"NDT2"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT2)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT2)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT2)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT2)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT2)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT2)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT2)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT2)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT2)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT2)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT2)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT2)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT2)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT2 Model Selection Complete ###################

```
 
 
 
## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1, NDT2

Select next NDT: NDT3

```{r}
zones1<-c("NDT3") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT3")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for topography

```{r}

########### 2. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo2 <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo2$NDT<-c("NDT3")
tab.sum.topo2$delta.aic<- tab.sum.topo2$aic - (min(tab.sum.topo2$aic))
tab.sum.topo2

```

#Now combine the datatables and save to computer

```{r}
NDT3_l_models_escape<-rbind(tab.sum.climate, tab.sum.topo2)
NDT3_l_models_escape

write.csv(NDT3_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT3_person_escape_models_notrees.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

```{r}
##### TOP MODEL####
NDT3_t<-Escape_data_person_nt %>%
  filter(ntrl_ds=="NDT3")

NDT3_t2<-NDT3_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT3<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT3_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT3)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT3), 
            residuals(glm_best_NDT3), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT3_t2$resids<-resid(glm_best_NDT3)

binnedplot (NDT3_t2$live_stand_volume_125, 
            NDT3_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT3_t2$climate1, 
            NDT3_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT3_t2$live_stand_volume_125,NDT3_t2$escape)
curve(invlogit(coef(glm_best_NDT3)[1] +coef(glm_best_NDT3)[2]*mean(NDT3_t2$climate1) + coef(glm_best_NDT3)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT3_t2$climate1,NDT3_t2$escape)
curve(invlogit(coef(glm_best_NDT3)[1] +coef(glm_best_NDT3)[2]*x + coef(glm_best_NDT3)[3]*mean(NDT3_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT3
top_mod_table[1,1]<-"NDT3"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT3)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT3)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT3)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT3)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT3)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT3)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT3)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT3)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT3)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT3)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT3)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT3)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT3)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT3 Model Selection Complete ###################

```
 

## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1, 2 and 3

Select next NDT: NDT4

```{r}
zones1<-c("NDT4") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype)){
  print(paste((all.poss.mods.clim.vegtype[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT4")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```

#Now repeat for topography

```{r}

########### 2. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo2 <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo2$NDT<-c("NDT4")
tab.sum.topo2$delta.aic<- tab.sum.topo2$aic - (min(tab.sum.topo2$aic))
tab.sum.topo2

```

#Now combine the datatables and save to computer

```{r}
NDT4_l_models_escape<-rbind(tab.sum.climate, tab.sum.topo2)
NDT4_l_models_escape

write.csv(NDT4_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT4_person_escape_models_notrees.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

#REMEMBER TO ADD WIND_ATFIRE!

```{r}
##### TOP MODEL####
NDT4_t<-Escape_data_person_nt %>%
  filter(ntrl_ds=="NDT4")

NDT4_t2<-NDT4_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT4<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT4_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT4)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT4), 
            residuals(glm_best_NDT4), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT4_t2$resids<-resid(glm_best_NDT4)

binnedplot (NDT4_t2$live_stand_volume_125, 
            NDT4_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT4_t2$climate1, 
            NDT4_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT4_t2$live_stand_volume_125,NDT4_t2$escape)
curve(invlogit(coef(glm_best_NDT4)[1] +coef(glm_best_NDT4)[2]*mean(NDT4_t2$climate1) + coef(glm_best_NDT4)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT4_t2$climate1,NDT4_t2$escape)
curve(invlogit(coef(glm_best_NDT4)[1] +coef(glm_best_NDT4)[2]*x + coef(glm_best_NDT4)[3]*mean(NDT4_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT4
top_mod_table[1,1]<-"NDT4"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT4)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT4)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT4)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT4)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT4)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT4)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT4)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT4)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT4)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT4)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT4)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT4)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT4)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT4 Model Selection Complete ###################

```
 
 
## Next Natural Disturbance Type ##

NDT 1 has 2 variables, NDT 2-5 have one
Complete: NDT1 through 4

Select next NDT: NDT5

ALL ZEROS! NON SPREAD!
```{r}
Escape_data_person_nt_NDT5<-subset(Escape_data_person_nt, Escape_data_person_nt$ntrl_ds=="NDT5")
head(Escape_data_person_nt_NDT5)
table(Escape_data_person_nt_NDT5$escape)

```

CANNOT DO BELOW!

```{r}
zones1<-c("NDT5") #Do one zone at a time

filenames<-list()
prop<-0.75

########### 1. Climate and vegtype ############
for (g in 1:100){

for (h in 1:length(zones1)) {
  dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.clim.vegtype2b)){
  print(paste((all.poss.mods.clim.vegtype2b[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2b, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1 <- unlist(sapply(mods.fit, '[', 1))
x1
#Aic for models
x3 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3
#auc from validation data
x4 <- unlist(sapply(mods.fit, '[', 4))
x4
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1, edf=x3[,1], aic=x3[,2], auc.valid=x4)
tab.sum.climate$NDT<-c("NDT5")
tab.sum.climate$delta.aic<- tab.sum.climate$aic - (min(tab.sum.climate$aic))
tab.sum.climate 

```


#Now repeat for topography

```{r}

########### 2. Topography ############
for (g in 1:100){

for (h in 1:length(zones1)) {
 dat2<- Escape_data_person_nt %>% dplyr::filter(ntrl_ds ==zones1[h])

for (i in 1: length(all.poss.mods.topo2)){
  print(paste((all.poss.mods.topo2[i]), (zones1[h]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(escape, fire_veg, variables_all[i])
  model_dat<- dat2 %>% dplyr::select(escape, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod <- function(mods.in, df.train, df.test, dep.var="escape") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- glm(form, family=binomial, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   mod.valid <- predict.glm(mods.fit, newdata=df.test, type="response")
   roc_obj <- roc(df.test[,dep.var], mod.valid)
   mod.auc <- auc(roc_obj)
   return(list(rhs, mod.stuff, mod.aic, mod.auc))
   
}

mods.fit <- lapply(all.poss.mods.topo2, big.mod, df.train=dat1, df.test=Valid)

}
}
}


```

Now extract elements from the output .

```{r}
#terms in each model
x1c <- unlist(sapply(mods.fit, '[', 1))
x1c
#Aic for models
x3c <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3c
#auc from validation data
x4c <- unlist(sapply(mods.fit, '[', 4))
x4c
#combining all as df
tab.sum.topo2 <- cbind.data.frame(model=x1c, edf=x3c[,1], aic=x3c[,2], auc.valid=x4c)
tab.sum.topo2$NDT<-c("NDT5")
tab.sum.topo2$delta.aic<- tab.sum.topo2$aic - (min(tab.sum.topo2$aic))
tab.sum.topo2

```

#Now combine the datatables and save to computer

```{r}
NDT5_l_models_escape<-rbind(tab.sum.climate, tab.sum.topo2)
NDT5_l_models_escape

write.csv(NDT5_l_models_escape, file="D:\\Fire\\fire_data\\raw_data\\NDT5_person_escape_models_notrees.csv")
```

Now choose the top variables and create final model. The below code will need to be updated manually, depending on what the results of the above analyses are.

######## UPDATE BELOW #########

```{r}
##### TOP MODEL####
NDT5_t<-Escape_data_person_nt %>%
  filter(ntrl_ds=="NDT5")

NDT5_t2<-NDT5_t %>% drop_na(live_stand_volume_125, vegtype, climate1, climate2, proj_height_1)

glm_best_NDT5<- glm(escape ~ scale(climate1)*scale(climate2) +
             scale(live_stand_volume_125) +
               scale(proj_height_1) +
               vegtype, 
           data= NDT5_t2,
           family = binomial,
           na.action=na.omit)

summary(glm_best_NDT5)

# model diagnostic plots
binnedplot (fitted(glm_best_NDT5), 
            residuals(glm_best_NDT5), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


NDT5_t2$resids<-resid(glm_best_NDT5)

binnedplot (NDT5_t2$live_stand_volume_125, 
            NDT5_t2$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (NDT5_t2$climate1, 
            NDT5_t2$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

# Looking at effect of forest height at the average amount of rainfall in September
plot(NDT5_t2$live_stand_volume_125,NDT5_t2$escape)
curve(invlogit(coef(glm_best_NDT5)[1] +coef(glm_best_NDT5)[2]*mean(NDT5_t2$climate1) + coef(glm_best_NDT5)[3]*x), add=TRUE)

# looking at effect of climate1 at the average forest height.
plot(NDT5_t2$climate1,NDT5_t2$escape)
curve(invlogit(coef(glm_best_NDT5)[1] +coef(glm_best_NDT5)[2]*x + coef(glm_best_NDT5)[3]*mean(NDT5_t2$live_stand_volume_125)), add=TRUE)


# create model table (only do this once) and add the relevant data
top_mod_table <- data.frame (matrix (ncol = 16, nrow = 0))
colnames (top_mod_table) <- c ("ZONE", "TREED", "Model_terms", "intercept", "coef_climate_1", "coef_climate_2", "coef_climate_interaction", "coef_stand_height", "coef_live_stand_volume_125", "coef_proj_age", "coef_vegtypeD", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM")



##STILL NEED TO ADD DATA FOR TABLE

##Add data for NDT5
top_mod_table[1,1]<-"NDT5"
top_mod_table[1,2]<-"Y"
top_mod_table[1,3]<-"escape ~ ppt09 + proj_height_1" ######### UPDATE
top_mod_table[1,4]<- coef(glm_best_NDT5)[1] #Intercept
top_mod_table[1,5]<- coef(glm_best_NDT5)[2] #Climate variable 1
#top_mod_table[1,6]<- coef(glm_best_NDT5)[2] #Climate variable 2
#top_mod_table[1,7]<- coef(glm_best_NDT5)[3] #Interaction climate variables
#top_mod_table[1,8]<- coef(glm_best_NDT5)[3] #coef_stand_height
#top_mod_table[1,9]<- coef(glm_best_NDT5)[3] #live_stand_volume_125
#top_mod_table[1,10]<- coef(glm_best_NDT5)[4] #proj_age_1
#top_mod_table[1,11]<- coef(glm_best_NDT5)[4] #coefficient vegtypeD
#top_mod_table[1,12]<- coef(glm_best_NDT5)[4] #coefficient vegtypeOP
#top_mod_table[1,13]<- coef(glm_best_NDT5)[4] #coefficient vegtypeS
#top_mod_table[1,14]<- coef(glm_best_NDT5)[4] #coefficient vegtypeTB
#top_mod_table[1,15]<- coef(glm_best_NDT5)[4] #coefficient vegtypeTC
#top_mod_table[1,16]<- coef(glm_best_NDT5)[5] #coefficient vegtypeTM
top_mod_table ##Determine if better way to represent categories for vegtype, and if each climate variable should have its own column

########################## NDT5 Model Selection Complete ###################

```
 
