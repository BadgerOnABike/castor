---
title: "13a_fire_spread_size_model_selection_ALLNDT_ALLLANDP_TNT"
author: "Cora Skaien"
date: "01/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Load relevant libraries
library(sf)
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
library(RPostgreSQL)
library(rpostgis)
library(dplyr)
library(lme4)
library(arm)
library(ggpubr)
library(mgcv)
library(nlme)
library(purrr)
library(tidyr)
library(caret)
library(pROC)
library(keyring)
library(ggcorrplot) 
library(kableExtra)
library(data.table)
library(DBI)
library(here)
library(AICcmodavg)
library(rje)
library(base)
library(car)
library(visreg)
#library(aomisc) #Not available for this version of R

source(here::here("R/functions/R_Postgres.R"))
```

<!--
Copyright 2021 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->

#=================================
#  Script Name: 13a_fire_spread_size_model_selection_ALLNDT_ALLLANDP_TNT.R
#  Script Version: 1.0
#  Script Purpose: model selection for fire size (part of spread) by NDT.
#  Script Author: Cora Skaien, Ecological Modeling Specialist, Forest Analysis and Inventory Branch, B.C. Ministry of Forests, Lands, and Natural Resource Operations.
#=================================

#Objective
The objective of this file is to determine the best model for predicting fire size, given climate, topography, infrastructure, etc. Prior models were logistic regression (0/1) and used AUC to assess quality. Here, we will be working with continuous data and will assess model fit via R-squared, root mean squared error, and cross-validation. We will first attempt linear regressions, but may need to consider other distributions.

Note on cross-validation using test and validation data: "When comparing two models, the one that produces the lowest test sample RMSE is the preferred model.
the RMSE and the MAE are measured in the same scale as the outcome variable. Dividing the RMSE by the average value of the outcome variable will give you the prediction error rate, which should be as small as possible." (http://www.sthda.com/english/articles/38-regression-model-validation/157-cross-validation-essentials-in-r/#loading-required-r-packages)

#For fire size, plot observed vs model for both testing data and validation data set.

#Load in the prepped data.
```{r}
spread_data_ALL<-read.csv(file="D:\\Fire\\fire_data\\raw_data\\spread_data_ALL_Dec2021_CombinedNDT.csv")
head(spread_data_ALL)

```
Remove extra X.1... X.5 labels at start of data as necessary.

```{r}
spread_data_ALL<-spread_data_ALL[-1]
head(spread_data_ALL)
```

#Inspect the data
```{r}
min(spread_data_ALL$size_ha) # Minimum 1 ha: this is because we are only quantifying the spread and fire size of those that "spreadd" (> 1 ha)
hist(spread_data_ALL$size_ha) #Definitely not a normal distribution
hist(log(spread_data_ALL$size_ha)) #Still not a normal distribution; already have a LNsize_ha variable created prior

spread_data_ALL$ntrl_ds<-as.factor(spread_data_ALL$ntrl_ds)
table(spread_data_ALL$ntrl_ds) #Very few in NDT5 (n=23)
```

##Create variables for model selection
First we will create the variable lists that contain all of our variables of interest.

Best variables:
 1. mean_tmax06_tmax07_tmax08_tmax09
 2. tmax06xppt06

```{r}
##Create variable lists to be used in the model loop.
variables_all<-c(tmax06 = "tmax06", ppt06="ppt06", mean_tmax06_tmax07_tmax08_tmax09 = "mean_tmax06_tmax07_tmax08_tmax09",  mdc_atfire="mdc_atfire", mdc_atfire2="mdc_atfire2", proj_height_1 = "proj_height_1", proj_age_1 = "proj_age_1", live_stand_volume_125 = "live_stand_volume_125", slope = "slope", slope2 = "slope2", aspect = "aspect", elevation ="elevation", vegtype2 = "vegtype2",  dist_infra = "dist_infra", wind_atfire = "wind_atfire", roads_km="roads_km", Tdif_atfire="Tdif_atfire", bclcs_level_2 ="bclcs_level_2", fire_cs ="fire_cs") 

vars.clim.vegtype2<-c("tmax06", "ppt06", "mean_tmax06_tmax07_tmax08_tmax09","vegtype2", "mdc_atfire", "mdc_atfire2")
vars.oth<-c("proj_height_1", "proj_age_1", "live_stand_volume_125", "bclcs_level_2") 
vars.topo<-c("slope", "slope2", "aspect", "elevation", "wind_atfire")
vars.infra<-c("dist_infra", "roads_km")
vars.oth2<-c("wind_atfire", "Tdif_atfire")


##Create interaction for climate and vegtype

inputs.me2 <- c(vars.clim.vegtype2)

```

Now, we will generate two-way interactions for each of these lists. 

```{r}

#####1a. For those with two climate variables and vegtype
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints2 <- NULL
for (i in 1:(length(inputs.me2)-1)) {
  for (j in (i+1):length(inputs.me2)) {
     twoway.ints2 <- cbind(twoway.ints2, paste(inputs.me2[i], inputs.me2[j], sep=":"))
  }
}
twoway.ints2
length(twoway.ints2) #15

#Get variables on own
#complete list
mods.me.tmp <- powerSet(vars.clim.vegtype2) 
#add climate vars to all of the above
mods.me.climate2 <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate2[[i]] <- c(mods.me.tmp[[i]])
}

length(mods.me.climate2)
mods.me.climate2<-mods.me.climate2[-1] #n = 63

#complete list of two-way interactions
mods.twoway2 <- powerSet(twoway.ints2)
length(mods.twoway2) #32768
mods.twoway2[1]
mods.twoway2<-mods.twoway2[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added
mods.inter2 <- list()
counter <- 0
for (i in 1: length(mods.twoway2)) {
   s1 <- unique(unlist( strsplit(mods.twoway2[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.climate2)) {
      if (all(s1 %in% mods.me.climate2[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.climate2[[j]], mods.twoway2[[i]])
        mods.inter2[[counter]] <- both
      }
   }
}

length(mods.inter2) #40005
#mods.inter2


```
Separate the climate variables and repeat.

```{r}

vars.clim.vegtype2<-c("tmax06", "ppt06","vegtype2", "mdc_atfire", "mdc_atfire2")
inputs.me2 <- c(vars.clim.vegtype2)

#####1a. For those with two climate variables and vegtype
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints2 <- NULL
for (i in 1:(length(inputs.me2)-1)) {
  for (j in (i+1):length(inputs.me2)) {
     twoway.ints2 <- cbind(twoway.ints2, paste(inputs.me2[i], inputs.me2[j], sep=":"))
  }
}
twoway.ints2
length(twoway.ints2) #10

#Get variables on own
#complete list
mods.me.tmp <- powerSet(vars.clim.vegtype2) 
#add climate vars to all of the above
mods.me.climate2 <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate2[[i]] <- c(mods.me.tmp[[i]])
}

length(mods.me.climate2) 32
mods.me.climate2[1]
mods.me.climate2<-mods.me.climate2[-1] #n = 31

#complete list of two-way interactions
mods.twoway2 <- powerSet(twoway.ints2)
length(mods.twoway2) #1024
mods.twoway2[1]
mods.twoway2<-mods.twoway2[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added
mods.inter2 <- list()
counter <- 0
for (i in 1: length(mods.twoway2)) {
   s1 <- unique(unlist( strsplit(mods.twoway2[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.climate2)) {
      if (all(s1 %in% mods.me.climate2[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.climate2[[j]], mods.twoway2[[i]])
        mods.inter2[[counter]] <- both
      }
   }
}

length(mods.inter2) #1418
#mods.inter2
```

```{r}

vars.clim.vegtype<-c( "mean_tmax06_tmax07_tmax08_tmax09","vegtype2", "mdc_atfire", "mdc_atfire2")
inputs.me <- c(vars.clim.vegtype)

#####1a. For those with two climate variables and vegtype
#get the names of all possible two-way interactions for climate variable(s) and vegtype.
twoway.ints <- NULL
for (i in 1:(length(inputs.me)-1)) {
  for (j in (i+1):length(inputs.me)) {
     twoway.ints <- cbind(twoway.ints, paste(inputs.me[i], inputs.me[j], sep=":"))
  }
}
twoway.ints
length(twoway.ints) #6

#Get variables on own
#complete list
mods.me.tmp <- powerSet(vars.clim.vegtype) 
#add climate vars to all of the above
mods.me.climate <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.climate[[i]] <- c(mods.me.tmp[[i]])
}

length(mods.me.climate)
mods.me.climate<-mods.me.climate[-1] #n = 15

#complete list of two-way interactions
mods.twoway <- powerSet(twoway.ints)
length(mods.twoway) #64
mods.twoway[1]
mods.twoway<-mods.twoway[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added
mods.inter <- list()
counter <- 0
for (i in 1: length(mods.twoway)) {
   s1 <- unique(unlist( strsplit(mods.twoway[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.climate)) {
      if (all(s1 %in% mods.me.climate[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.climate[[j]], mods.twoway[[i]])
        mods.inter[[counter]] <- both
      }
   }
}

length(mods.inter) #97
#mods.inter2
```

```{r}
#########2. Now for topography data, get all possible two-way interactions

#get the names of all possible two-way interactions
twoway.intsT <- NULL
for (i in 1:(length(vars.topo)-1)) {
  for (j in (i+1):length(vars.topo)) {
     twoway.intsT <- cbind(twoway.intsT, paste(vars.topo[i], vars.topo[j], sep=":"))
  }
}
twoway.intsT
length(twoway.intsT) #10

#No reason to believe aspect*wind_atfire would have an effect, so remove
twoway.intsT<-twoway.intsT[-5]

#complete list of models using non-climate vars (topo)
mods.me.tmp <- powerSet(vars.topo) 
#add climate vars to all of the above
mods.meT <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.meT[[i]] <- c(mods.me.tmp[[i]])
}

mods.meT
mods.meT<-mods.meT[-1]

#complete list of two-way interactions
mods.twowayT <- powerSet(twoway.intsT)
length(mods.twowayT) #512
mods.twowayT
mods.twowayT<-mods.twowayT[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added

mods.interT <- list()
counter <- 0
for (i in 1: length(mods.twowayT)) {
   s1 <- unique(unlist( strsplit(mods.twowayT[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meT)) {
      if (all(s1 %in% mods.meT[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.meT[[j]], mods.twowayT[[i]])
        mods.interT[[counter]] <- both
      }
   }
}

length(mods.interT) #797
#mods.interT
```

```{r}
####3.For other VRI data, get without interactions

#complete list of models using VRI - no interactions
mods.me.tmp <- powerSet(vars.oth) 
#add climate vars to all of the above
mods.me.oth <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.oth[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.oth
mods.me.oth<-mods.me.oth[-1]

#get the names of all possible two-way interactions
twoway.intsOTH <- NULL
for (i in 1:(length(vars.oth)-1)) {
  for (j in (i+1):length(vars.oth)) {
     twoway.intsOTH <- cbind(twoway.intsOTH, paste(vars.oth[i], vars.oth[j], sep=":"))
  }
}
twoway.intsOTH
length(twoway.intsOTH) #6

#Do not want interactions between VRI variables
twoway.intsOTH<-twoway.intsOTH[c(3,5,6)]
twoway.intsOTH

#complete list of two-way interactions
mods.twowayOTH <- powerSet(twoway.intsOTH)
length(mods.twowayOTH) #8
mods.twowayOTH
mods.twowayOTH<-mods.twowayOTH[-1]

#Finding models in mods.me that accommodate/allow interaction terms in each mods.twoway to be added

mods.inter.OTH <- list()
counter <- 0
for (i in 1: length(mods.twowayOTH)) {
   s1 <- unique(unlist( strsplit(mods.twowayOTH[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.me.oth)) {
      if (all(s1 %in% mods.me.oth[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.oth[[j]], mods.twowayOTH[[i]])
        mods.inter.OTH[[counter]] <- both
      }
   }
}

length(mods.inter.OTH) #19
mods.inter.OTH


```

```{r}
#########4. Now for distance to infrastructure data, get all possible two-way interactions

#get the names of all possible two-way interactions
twoway.intsI <- NULL
for (i in 1:(length(vars.infra)-1)) {
  for (j in (i+1):length(vars.infra)) {
     twoway.intsI <- cbind(twoway.intsI, paste(vars.infra[i], vars.infra[j], sep=":"))
  }
}
twoway.intsI
length(twoway.intsI) #1

#complete list of models using non-climate vars (infra)
mods.me.tmp <- powerSet(vars.infra) 
#add climate vars to all of the above
mods.meI <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.meI[[i]] <- c(mods.me.tmp[[i]])
}

mods.meI
mods.meI<-mods.meI[-1]

#complete list of two-way interactions
mods.twowayI <- powerSet(twoway.intsI)
length(mods.twowayI) #2
#mods.twowayI

#Finding models in mods.me that accommodate/allow interaction terms 
mods.interI <- list()
counter <- 0
for (i in 1: length(mods.twowayI)) {
   s1 <- unique(unlist( strsplit(mods.twowayI[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meI)) {
      if (all(s1 %in% mods.meI[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.meI[[j]], mods.twowayI[[i]])
        mods.interI[[counter]] <- both
      }
   }
}

length(mods.interI) #4
mods.interI
```

```{r}
########5. Lastly for last list of other variables
#get the names of all possible two-way interactions
twoway.ints.O2 <- NULL
for (i in 1:(length(vars.oth2)-1)) {
  for (j in (i+1):length(vars.oth2)) {
     twoway.ints.O2 <- cbind(twoway.ints.O2, paste(vars.oth2[i], vars.oth2[j], sep=":"))
  }
}
twoway.ints.O2
length(twoway.ints.O2) #1

#complete list of models using non-climate vars (infra)
mods.me.tmp <- powerSet(vars.oth2) 
#add climate vars to all of the above
mods.me.O2 <- list()
for (i in 1: length(mods.me.tmp)) {
   mods.me.O2[[i]] <- c(mods.me.tmp[[i]])
}

mods.me.O2
mods.me.O2<-mods.me.O2[-1]

#complete list of two-way interactions
mods.twoway.O2 <- powerSet(twoway.ints.O2)
length(mods.twoway.O2) #2
mods.twowayI
mods.twowayI<-mods.twowayI[-1]

#Finding models in mods.me that accommodate/allow interaction terms 
mods.inter.O2 <- list()
counter <- 0
for (i in 1: length(mods.twoway.O2)) {
   s1 <- unique(unlist( strsplit(mods.twoway.O2[[i]], split=':', fixed=TRUE) ) )
   for (j in 1: length(mods.meI)) {
      if (all(s1 %in% mods.me.O2[[j]])==TRUE) {
        counter <- counter + 1
        both <-  c(mods.me.O2[[j]], mods.twoway.O2[[i]])
        mods.inter.O2[[counter]] <- both
      }
   }
}

length(mods.inter.O2) #4
mods.inter.O2
```

Determine final models for testing.

```{r}
all.poss.mods.clim.vegtype2<-c(1, mods.me.climate2, mods.inter2)
length(all.poss.mods.clim.vegtype2) #1450

all.poss.mods.clim.vegtype<-c(1, mods.me.climate, mods.inter)
length(all.poss.mods.clim.vegtype) #113

all.poss.mods.VRI<-c(1, mods.inter.OTH)
all.poss.mods.VRI #20

all.poss.mods.topo<-c(1, mods.interT)
length(all.poss.mods.topo) #798

all.poss.mods.infra<-c(1, mods.interI) 
all.poss.mods.infra #5

all.poss.mods.Oth2<-c(1, mods.inter.O2)
all.poss.mods.Oth2 #5
```


```{r}
#If need to determine which ones are character(0), try this:
biglist <- list(list("A","B","C"), "foo", "", character(0), integer(0))
lapply(biglist, function(x) {length(x) == 0L} ) 


##Check and rid of any duplicated models
duplicated(all.poss.mods.clim.vegtype2)
duplicated(all.poss.mods.clim.vegtype2b)
duplicated(all.poss.mods.VRI)
duplicated(all.poss.mods.topo)
duplicated(all.poss.mods.infra)
duplicated(all.poss.mods.Oth2)

```


############### Determine Top Models ##########
In this file, we will investigate all the data together. Note that different cxlimate variables came out as significant for climate1, so the below will not work as is. 

#1. Climate1, climate2 and vegtype2 PART 1

```{r}
prop<-0.75

#Create empty table
table.glm.climate.simple.spread <- data.frame (matrix (ncol = 9, nrow = 0))
colnames (table.glm.climate.simple.spread) <- c ("model", "edf", "aic", "Model.R2", "Adjusted.R2", "Valid.R2", "Valid.RMSE", "Valid.MAE", "NDT")

#Run model x100
for (g in 1:100){
  
  print(paste((all.poss.mods.clim.vegtype2[i]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(spread, fire_veg, variables_all[i])
  model_dat<- spread_data_ALL %>% dplyr::select(LNsize_ha, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod_lm <- function(mods.in, df.train, dep.var="LNsize_ha") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- lm(form, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   predictions <- mods.fit %>% predict(Valid)
   Model.R2 <- summary(mods.fit)$r.squared
   Valid.R2 <- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.RMSE <- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.MAE <- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Adjusted.R2<-summary(mods.fit)$adj.r.squared 
   return(list(rhs, mod.stuff, mod.aic, Model.R2, Valid.R2, Valid.RMSE, Valid.MAE, Adjusted.R2))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype2, big.mod_lm, df.train=dat1)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#Model.R2
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#Validation R2 
x5.1 <- unlist(sapply(mods.fit, '[', 5))
x5.1
#Validation RSME
x6.1 <- unlist(sapply(mods.fit, '[', 6))
x6.1
#Validation MAE
x7.1 <- unlist(sapply(mods.fit, '[', 7))
x7.1
#Adjusted R2
x8.1 <- unlist(sapply(mods.fit, '[', 8))
x8.1
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], Model.R2=x4.1, Adjusted.R2=x8.1, Valid.R2=x5.1, Valid.RMSE=x6.1, Valid.MAE=x7.1)
tab.sum.climate$NDT<-c("ALLNDT")
tab.sum.climate 

table.glm.climate.simple.spread<-rbind(table.glm.climate.simple.spread, tab.sum.climate)

}

```
Check data.
```{r}
head(table.glm.climate.simple.spread)
```

Now repeat for second climate variable set.
#1. Climate1, climate2 and vegtype2 PART 2

```{r}
prop<-0.75

#Run model x100
for (g in 1:100){
  
  print(paste((all.poss.mods.clim.vegtype[i]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(spread, fire_veg, variables_all[i])
  model_dat<- spread_data_ALL %>% dplyr::select(LNsize_ha, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod_lm <- function(mods.in, df.train, dep.var="LNsize_ha") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- lm(form, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   predictions <- mods.fit %>% predict(Valid)
   Model.R2 <- summary(mods.fit)$r.squared
   Valid.R2 <- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.RMSE <- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.MAE <- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Adjusted.R2<-summary(mods.fit)$adj.r.squared 
   return(list(rhs, mod.stuff, mod.aic, Model.R2, Valid.R2, Valid.RMSE, Valid.MAE, Adjusted.R2))
   
}

mods.fit <- lapply(all.poss.mods.clim.vegtype, big.mod_lm, df.train=dat1)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#Model.R2
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#Validation R2 
x5.1 <- unlist(sapply(mods.fit, '[', 5))
x5.1
#Validation RSME
x6.1 <- unlist(sapply(mods.fit, '[', 6))
x6.1
#Validation MAE
x7.1 <- unlist(sapply(mods.fit, '[', 7))
x7.1
#Adjusted R2
x8.1 <- unlist(sapply(mods.fit, '[', 8))
x8.1
#combining all as df
tab.sum.climate <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], Model.R2=x4.1, Adjusted.R2=x8.1, Valid.R2=x5.1, Valid.RMSE=x6.1, Valid.MAE=x7.1)
tab.sum.climate$NDT<-c("ALLNDT")
tab.sum.climate 

table.glm.climate.simple.spread<-rbind(table.glm.climate.simple.spread, tab.sum.climate)

}
```

Now that we have run both models 100 times, we want the average AIC and goodness of fit metrics for each variable combination.

```{r}
head(table.glm.climate.simple.spread)
table(table.glm.climate.simple.spread$model) # 100 per model

AIC_lightning_ALLNDT_spread_treed_climate<-table.glm.climate.simple.spread

AIC_lightning_ALLNDT_spread_treed_summary_climate<- AIC_lightning_ALLNDT_spread_treed_climate %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic, na.rm=TRUE),
            meanR2=mean(Model.R2, na.rm=TRUE),
            meanAdjustR2=mean(Adjusted.R2, na.rm=TRUE),
            sdR2=sd(Model.R2, na.rm=TRUE),
            meanR2valid=mean(Valid.R2, na.rm=TRUE),
            meanRSMEvalid=mean(Valid.RMSE, na.rm=TRUE),
            meanMAEvalid=mean(Valid.MAE, na.rm=TRUE)
            )

AIC_lightning_ALLNDT_spread_treed_summary_climate2<- AIC_lightning_ALLNDT_spread_treed_summary_climate %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_ALLNDT_spread_treed_summary_climate2)
```

#Now repeat for VRI data

```{r}
#Create empty table
table.glm.VRI.simple.spread <- data.frame (matrix (ncol = 9, nrow = 0))
colnames (table.glm.VRI.simple.spread) <- c ("model", "edf", "aic", "Model.R2", "Adjusted.R2", "Valid.R2", "Valid.RMSE", "Valid.MAE", "NDT")

#Run model x100
for (g in 1:100){
  
  print(paste((all.poss.mods.VRI[i]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(spread, fire_veg, variables_all[i])
  model_dat<- spread_data_ALL %>% dplyr::select(LNsize_ha, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod_lm <- function(mods.in, df.train, dep.var="LNsize_ha") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- lm(form, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   predictions <- mods.fit %>% predict(Valid)
   Model.R2 <- summary(mods.fit)$r.squared
   Valid.R2 <- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.RMSE <- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.MAE <- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Adjusted.R2<-summary(mods.fit)$adj.r.squared 
   return(list(rhs, mod.stuff, mod.aic, Model.R2, Valid.R2, Valid.RMSE, Valid.MAE, Adjusted.R2))
   
}

mods.fit <- lapply(all.poss.mods.VRI, big.mod_lm, df.train=dat1)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#Model.R2
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#Validation R2
x5.1 <- unlist(sapply(mods.fit, '[', 5))
x5.1
#Validation RSME
x6.1 <- unlist(sapply(mods.fit, '[', 6))
x6.1
#Validation MAE
x7.1 <- unlist(sapply(mods.fit, '[', 7))
x7.1
#Adjusted R2
x8.1 <- unlist(sapply(mods.fit, '[', 8))
x8.1
#combining all as df
tab.sum.VRI <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], Model.R2=x4.1, Adjusted.R2=x8.1, Valid.R2=x5.1, Valid.RMSE=x6.1, Valid.MAE=x7.1)
tab.sum.VRI$NDT<-c("ALLNDT")
tab.sum.VRI 

table.glm.VRI.simple.spread<-rbind(table.glm.VRI.simple.spread, tab.sum.VRI)

}

```
Check data.
```{r}
head(table.glm.VRI.simple.spread)
```
Now that we have run the model 100 times, we want the average AIC and goodness of fit metrics for each variable combination..

```{r}
head(table.glm.VRI.simple.spread)
table(table.glm.VRI.simple.spread$model) # 100 per model

AIC_lightning_ALLNDT_spread_treed_VRI<-table.glm.VRI.simple.spread

AIC_lightning_ALLNDT_spread_treed_summary_VRI<- AIC_lightning_ALLNDT_spread_treed_VRI %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic, na.rm=TRUE),
            meanR2=mean(Model.R2, na.rm=TRUE),
            meanAdjustR2=mean(Adjusted.R2, na.rm=TRUE),
            sdR2=sd(Model.R2, na.rm=TRUE),
            meanR2valid=mean(Valid.R2, na.rm=TRUE),
            meanRSMEvalid=mean(Valid.RMSE, na.rm=TRUE),
            meanMAEvalid=mean(Valid.MAE, na.rm=TRUE)
            )

AIC_lightning_ALLNDT_spread_treed_summary_VRI2<- AIC_lightning_ALLNDT_spread_treed_summary_VRI %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_ALLNDT_spread_treed_summary_VRI2)
```
#Now repeat for topography

```{r}
#Create empty table
table.glm.topo.simple.spread <- data.frame (matrix (ncol = 9, nrow = 0))
colnames (table.glm.topo.simple.spread) <- c ("model", "edf", "aic", "Model.R2", "Adjusted.R2", "Valid.R2", "Valid.RMSE", "Valid.MAE", "NDT")

#Run model x100
for (g in 1:100){
  
  print(paste((all.poss.mods.topo[i]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(spread, fire_veg, variables_all[i])
  model_dat<- spread_data_ALL %>% dplyr::select(LNsize_ha, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod_lm <- function(mods.in, df.train, dep.var="LNsize_ha") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- lm(form, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   predictions <- mods.fit %>% predict(Valid)
   Model.R2 <- summary(mods.fit)$r.squared
   Valid.R2 <- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.RMSE <- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.MAE <- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Adjusted.R2<-summary(mods.fit)$adj.r.squared 
   return(list(rhs, mod.stuff, mod.aic, Model.R2, Valid.R2, Valid.RMSE, Valid.MAE, Adjusted.R2))
   
}

mods.fit <- lapply(all.poss.mods.topo, big.mod_lm, df.train=dat1)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#Model.R2
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#Validation R2
x5.1 <- unlist(sapply(mods.fit, '[', 5))
x5.1
#Validation RSME
x6.1 <- unlist(sapply(mods.fit, '[', 6))
x6.1
#Validation MAE
x7.1 <- unlist(sapply(mods.fit, '[', 7))
x7.1
#Adjusted R2
x8.1 <- unlist(sapply(mods.fit, '[', 8))
x8.1
#combining all as df
tab.sum.topo <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], Model.R2=x4.1, Adjusted.R2=x8.1, Valid.R2=x5.1, Valid.RMSE=x6.1, Valid.MAE=x7.1)
tab.sum.topo$NDT<-c("ALLNDT")
tab.sum.topo 

table.glm.topo.simple.spread<-rbind(table.glm.topo.simple.spread, tab.sum.topo)

}

```
Check data.
```{r}
head(table.glm.topo.simple.spread)
```
Now that we have run the model 100 times, we want the average AIC and goodness of fit metrics for each variable combination..

```{r}
head(table.glm.topo.simple.spread)
table(table.glm.topo.simple.spread$model) # 100 per model

AIC_lightning_ALLNDT_spread_treed_topo<-table.glm.topo.simple.spread

AIC_lightning_ALLNDT_spread_treed_summary_topo<- AIC_lightning_ALLNDT_spread_treed_topo %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic, na.rm=TRUE),
            meanR2=mean(Model.R2, na.rm=TRUE),
            meanAdjustR2=mean(Adjusted.R2, na.rm=TRUE),
            sdR2=sd(Model.R2, na.rm=TRUE),
            meanR2valid=mean(Valid.R2, na.rm=TRUE),
            meanRSMEvalid=mean(Valid.RMSE, na.rm=TRUE),
            meanMAEvalid=mean(Valid.MAE, na.rm=TRUE)
            )

AIC_lightning_ALLNDT_spread_treed_summary_topo2<- AIC_lightning_ALLNDT_spread_treed_summary_topo %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_ALLNDT_spread_treed_summary_topo2)
```

#Now repeat for infrastructure

```{r}
#Create empty table
table.glm.infra.simple.spread <- data.frame (matrix (ncol = 9, nrow = 0))
colnames (table.glm.infra.simple.spread) <- c ("model", "edf", "aic", "Model.R2", "Adjusted.R2", "Valid.R2", "Valid.RMSE", "Valid.MAE", "NDT")

#Run model x100
for (g in 1:100){
  
  print(paste((all.poss.mods.infra[i]), sep=" "))
  
 # model_dat<- dat2 %>% dplyr::select(spread, fire_veg, variables_all[i])
  model_dat<- spread_data_ALL %>% dplyr::select(LNsize_ha, fire_veg, !!variables_all)
  # Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(model_dat$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- model_dat[ trainIndex,]
   Valid <- model_dat[-trainIndex,]

big.mod_lm <- function(mods.in, df.train, dep.var="LNsize_ha") {
   rhs <- paste(mods.in, collapse=" + ")
   form <- as.formula(paste(noquote(dep.var), " ~", rhs))
   mods.fit <- lm(form, data=df.train)
   mod.stuff <- summary(mods.fit)
   mod.aic <- extractAIC(mods.fit)
   predictions <- mods.fit %>% predict(Valid)
   Model.R2 <- summary(mods.fit)$r.squared
   Valid.R2 <- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.RMSE <- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Valid.MAE <- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
   Adjusted.R2<-summary(mods.fit)$adj.r.squared 
   return(list(rhs, mod.stuff, mod.aic, Model.R2, Valid.R2, Valid.RMSE, Valid.MAE, Adjusted.R2))
   
}

mods.fit <- lapply(all.poss.mods.infra, big.mod_lm, df.train=dat1)

#terms in each model
x1.1 <- unlist(sapply(mods.fit, '[', 1))
x1.1
#Aic for models
x3.1 <- matrix(unlist(sapply(mods.fit, '[', 3)), ncol=2, byrow=TRUE)
x3.1
#Model.R2
x4.1 <- unlist(sapply(mods.fit, '[', 4))
x4.1
#Validation R2
x5.1 <- unlist(sapply(mods.fit, '[', 5))
x5.1
#Validation RSME
x6.1 <- unlist(sapply(mods.fit, '[', 6))
x6.1
#Validation MAE
x7.1 <- unlist(sapply(mods.fit, '[', 7))
x7.1
#Adjusted R2
x8.1 <- unlist(sapply(mods.fit, '[', 8))
x8.1
#combining all as df
tab.sum.infra <- cbind.data.frame(model=x1.1, edf=x3.1[,1], aic=x3.1[,2], Model.R2=x4.1, Adjusted.R2=x8.1, Valid.R2=x5.1, Valid.RMSE=x6.1, Valid.MAE=x7.1)
tab.sum.infra$NDT<-c("ALLNDT")
tab.sum.infra 

table.glm.infra.simple.spread<-rbind(table.glm.infra.simple.spread, tab.sum.infra)

}

```
Check data.
```{r}
head(table.glm.infra.simple.spread)
```
Now that we have run the model 100 times, we want the average AIC and goodness of fit metrics for each variable combination..

```{r}
head(table.glm.infra.simple.spread)
table(table.glm.infra.simple.spread$model) # 100 per model 

AIC_lightning_ALLNDT_spread_treed_infra<-table.glm.infra.simple.spread

AIC_lightning_ALLNDT_spread_treed_summary_infra<- AIC_lightning_ALLNDT_spread_treed_infra %>%
  group_by(model) %>%
  summarise(meanAIC=mean(aic, na.rm=TRUE),
            meanR2=mean(Model.R2, na.rm=TRUE),
            meanAdjustR2=mean(Adjusted.R2, na.rm=TRUE),
            sdR2=sd(Model.R2, na.rm=TRUE),
            meanR2valid=mean(Valid.R2, na.rm=TRUE),
            meanRSMEvalid=mean(Valid.RMSE, na.rm=TRUE),
            meanMAEvalid=mean(Valid.MAE, na.rm=TRUE)
            )

AIC_lightning_ALLNDT_spread_treed_summary_infra2<- AIC_lightning_ALLNDT_spread_treed_summary_infra %>%
  mutate(deltaAIC=meanAIC-min(meanAIC))

head(AIC_lightning_ALLNDT_spread_treed_summary_infra2)
```

Combine together
```{r}
ALLNDT_l_treed_spread<-rbind(AIC_lightning_ALLNDT_spread_treed_summary_climate2, AIC_lightning_ALLNDT_spread_treed_summary_infra2, AIC_lightning_ALLNDT_spread_treed_summary_topo2, AIC_lightning_ALLNDT_spread_treed_summary_VRI2)

ALLNDT_l_treed_spread$NDT<-"ALLNDT"

head(ALLNDT_l_treed_spread)
```

Save data.
```{r}
write.csv(ALLNDT_l_treed_spread, file="D:\\Fire\\fire_data\\raw_data\\Firesize_ALLmodels_spread_Feb.csv")
```

##Determine Best Models.
For best models, we will look at R-square of the model, and then within the top R-square, we will assess which had lowest AIC.

1. mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2
2. dist_infra + roads_km
3. slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire
4. proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_height_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2

Note: R-square values were all very low, all <0.06, and adjusted Rsquare all < 0.06.

#Other variables to add:
1. NDT and interactions as needed given prior patterns observed
2. Fire cause (person and lightning)
3. Treed and not treed

##################### Begin Manual Exploration ##################
Begin manual exploration from here. We will use the above variables, plus additional interactions: wind_atfire + climate1:proj_height_1 + climate1:proj_age_1 + climate1:live_stand_volume_125 + climate1:elevation + climate1:wind_atfire + slope:wind_atfire + elevation:wind_atfire + vegtype2:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125

#Variables:
mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_height_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + wind_atfire + climate1:proj_height_1 + climate1:proj_age_1 + climate1:live_stand_volume_125 + climate1:elevation + climate1:wind_atfire + slope:wind_atfire + elevation:wind_atfire + vegtype2:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs +  ntrl_ds:bclcs_level_2 + ntrl_ds:vegtype2

Change all projected age, height and volume values of NA to 0 as an approximation.

```{r}
spread_data_ALL$proj_age_1[is.na(spread_data_ALL$proj_age_1)] <- 0
spread_data_ALL$proj_height_1[is.na(spread_data_ALL$proj_height_1)] <- 0
spread_data_ALL$live_stand_volume_125[is.na(spread_data_ALL$live_stand_volume_125)] <- 0
```


```{r}
prop<-0.75

#Partition data into training and validation
 trainIndex <- createDataPartition(spread_data_ALL$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- spread_data_ALL[ trainIndex,]
   Valid <- spread_data_ALL[-trainIndex,]
  
#Run model using dat1
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + proj_height_1:bclcs_level_2 + live_stand_volume_125:bclcs_level_2 + wind_atfire + vegtype2:proj_height_1 + vegtype2:proj_age_1 +  vegtype2:live_stand_volume_125 + vegtype2:elevation +  vegtype2:wind_atfire + slope:wind_atfire + elevation:wind_atfire + vegtype2:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs +  ntrl_ds:bclcs_level_2 + ntrl_ds:vegtype2, data = dat1)

AIC(model.ALLNDT) #17572.28
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.12
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove least sig
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + wind_atfire +  vegtype2:proj_height_1 +  vegtype2:proj_age_1 + vegtype2:elevation +  vegtype2:wind_atfire + elevation:wind_atfire + vegtype2:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs +  ntrl_ds:bclcs_level_2 + ntrl_ds:vegtype2, data = dat1)

AIC(model.ALLNDT) #17563.7
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.12
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove least sig
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1 + vegtype2:proj_age_1 + vegtype2:elevation +  elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs +  ntrl_ds:bclcs_level_2 + ntrl_ds:vegtype2, data = dat1)

AIC(model.ALLNDT) #17556.6
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.12
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove least sig
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1 + vegtype2:proj_age_1 + vegtype2:elevation + elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs +  ntrl_ds:bclcs_level_2, data = dat1)

AIC(model.ALLNDT) #17544.0
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.13
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.09
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.65

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove least sig
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + slope + slope2 + elevation + wind_atfire + slope:slope2 + slope2:elevation + elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1 +  vegtype2:proj_age_1 + vegtype2:elevation +  elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs, data = dat1)

AIC(model.ALLNDT) #17540
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.125
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.09
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.655

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove least sig
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + mdc_atfire:mdc_atfire2 + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1 + m vegtype2:proj_age_1 + vegtype2:elevation +  elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs, data = dat1)

AIC(model.ALLNDT) #17535.8
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.125
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.09
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.65

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Some other changes
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire2 + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + mean_tmax06_tmax07_tmax08_tmax09 + vegtype2:proj_height_1 + vegtype2:proj_age_1 + vegtype2:elevation +  elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs, data = dat1)

AIC(model.ALLNDT) #17539.2
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.122
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Some other changes
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mdc_atfire2 + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1 + vegtype2:proj_age_1 + vegtype2:elevation + elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs, data = dat1)

AIC(model.ALLNDT) #17539.2
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.121
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

#Remove mdcatfire2
model.ALLNDT<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1  + vegtype2:proj_age_1 + vegtype2:elevation + elevation:wind_atfire + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds  + fire_cs, data = dat1)

AIC(model.ALLNDT) #17537.3
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.121
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

summary(model.ALLNDT)
Anova(model.ALLNDT, type=3, singular.ok = TRUE)

```

Remove NAs and run multiple times.

```{r}
#Remove NAs to ensure all same data used so we can compare AICs
ALL_spread_size_NAremoved<-spread_data_ALL %>% drop_na(proj_height_1 , proj_age_1, live_stand_volume_125, bclcs_level_2, slope , aspect , climate1 , climate2, vegtype2, wind_atfire, elevation, Tdif_atfire)

#Run Model again with this data; but uses all data here
model.Spread<-lm(LNsize_ha ~  mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1  + vegtype2:proj_age_1 + vegtype2:elevation  + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds + fire_cs, data = ALL_spread_size_NAremoved)

#Anova(model.Spread, type=3)
Anova(model.Spread, type=3, singular.ok = TRUE)

# model diagnostic plots
binnedplot (fitted(model.Spread), 
            residuals(model.Spread), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))


ALLNDT_spread_size$resids<-resid(model.Spread)

binnedplot (ALLNDT_spread_size$live_stand_volume_125, 
            ALLNDT_spread_size$resids, 
            nclass = NULL, 
            xlab = "live stand volume", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

binnedplot (ALLNDT_spread_size$climate1, 
            ALLNDT_spread_size$resids, 
            nclass = NULL, 
            xlab = "", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm", i))

# Diagnostic plots look good

#Partial Residuals
#mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1  + vegtype2:proj_age_1 + vegtype2:elevation + Tdif_atfire + Tdif_atfire:wind_atfire + Tdif_atfire:live_stand_volume_125 + ntrl_ds + fire_cs

visreg(model.Spread, "mean_tmax06_tmax07_tmax08_tmax09", by="mdc_atfire")
visreg(model.Spread, "mdc_atfire", by="mean_tmax06_tmax07_tmax08_tmax09")

visreg(model.Spread, "dist_infra")
visreg(model.Spread, "roads_km")

visreg(model.Spread, "wind_atfire", by="elevation")
visreg(model.Spread, "wind_atfire", by="Tdif_atfire")
visreg(model.Spread, "elevation", by="wind_atfire")
visreg(model.Spread, "elevation", by="vegtype2")

visreg(model.Spread, "vegtype2", by="elevation")
visreg(model.Spread, "vegtype2", by="proj_height_1")
visreg(model.Spread, "vegtype2", by="proj_age_1")

visreg(model.Spread, "proj_height_1", by="vegtype2")
visreg(model.Spread, "proj_age_1", by="vegtype2")
visreg(model.Spread, "live_stand_volume_125", by="Tdif_atfire")
visreg(model.Spread, "live_stand_volume_125")

visreg(model.Spread, "Tdif_atfire", by="live_stand_volume_125")
visreg(model.Spread, "Tdif_atfire", by="wind_atfire")

visreg(model.Spread, "bclcs_level_2")
visreg(model.Spread, "ntrl_ds")
visreg(model.Spread, "fire_cs")
```


```{r}
#Tdif_by_volume interaction minimal; so remove
model.Spread<-lm(LNsize_ha ~  mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2 + vegtype2:proj_height_1  + vegtype2:proj_age_1 + vegtype2:elevation  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs, data = ALL_spread_size_NAremoved)

#Interactions of vegtype with elevation, height and age weird. Remove.
model.Spread<-lm(LNsize_ha ~  mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire + proj_height_1 + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs, data = ALL_spread_size_NAremoved)

Anova(model.Spread, type=3, singular.ok = TRUE)
AIC(model.Spread) #23255.26

#Remove height
model.Spread<-lm(LNsize_ha ~  mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire  + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs, data = ALL_spread_size_NAremoved)

Anova(model.Spread, type=3, singular.ok = TRUE)
AIC(model.Spread) #23253.3
summary(model.ALLNDT)$r.squared #0.15
summary(model.ALLNDT)$adj.r.squared #0.14

predictions <- model.ALLNDT %>% predict(Valid)
R2(predictions, Valid$LNsize_ha, na.rm=TRUE) #0.121
RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE) #2.10
MAE(predictions, Valid$LNsize_ha, na.rm=TRUE) #1.66

#Partial resids
visreg(model.Spread, "mean_tmax06_tmax07_tmax08_tmax09", by="mdc_atfire")
visreg(model.Spread, "mdc_atfire", by="mean_tmax06_tmax07_tmax08_tmax09")

visreg(model.Spread, "dist_infra")
visreg(model.Spread, "roads_km")

visreg(model.Spread, "wind_atfire", by="elevation")
visreg(model.Spread, "wind_atfire", by="Tdif_atfire")
visreg(model.Spread, "elevation", by="wind_atfire")

visreg(model.Spread, "vegtype2")

visreg(model.Spread, "proj_age_1")
visreg(model.Spread, "live_stand_volume_125")

visreg(model.Spread, "Tdif_atfire", by="wind_atfire")

visreg(model.Spread, "bclcs_level_2")
visreg(model.Spread, "ntrl_ds")
visreg(model.Spread, "fire_cs")

```
We should repeat the above several times and take the mean of the coefficients.

```{r}
summary(model.Spread)

#Create a new blank table and get AUC too
top_mod_table_ALLNDT_ALL <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_ALLNDT_ALL ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept","coef_mean_tmax06_tmax07_tmax08_tmax09", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_dist_infra", "coef_roads_km", "coef_elevation", "coef_wind_atfire",  "coef_proj_age_1", "coef_live_stand_volume_125", "coef_bclcs_level_2TRUE", "coef_Tdif_atfire", "coef_ntrl_dsNDT2", "coef_ntrl_dsNDT3", "coef_ntrl_dsNDT4", "coef_ntrl_dsNDT5", "coef_fire_csPerson", "coef_mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire", "coef_elevation:wind_atfire", "coef_wind_atfire:Tdif_atfire", "AIC", "Model.R2", "Valid.R2", "Valid.RSME", "Valid.MAE", "Adjusted.R2")

```

Let's run it 500 times to get good mean values.

```{r}

for (g in 1:500){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(spread_data_ALL$vegtype2, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- spread_data_ALL[ trainIndex,]
   Valid <- spread_data_ALL[-trainIndex,]
   
#Model   
model.Spread<-lm(LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire  + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs, data = dat1) 

predictions <- model.Spread %>% predict(Valid)

# create model table (only do this once) and add the relevant data
top_mod_table_ALLNDT_lightning_t <- data.frame (matrix (ncol = 34, nrow = 0))
colnames (top_mod_table_ALLNDT_lightning_t ) <- c ("CAUSE", "NDT", "TREED", "Model_terms", "intercept","coef_mean_tmax06_tmax07_tmax08_tmax09", "coef_vegtypeOP", "coef_vegtypeS", "coef_vegtypeTB", "coef_vegtypeTC", "coef_vegtypeTM", "coef_mdc_atfire", "coef_dist_infra", "coef_roads_km", "coef_elevation", "coef_wind_atfire",  "coef_proj_age_1", "coef_live_stand_volume_125", "coef_bclcs_level_2TRUE", "coef_Tdif_atfire", "coef_ntrl_dsNDT2", "coef_ntrl_dsNDT3", "coef_ntrl_dsNDT4", "coef_ntrl_dsNDT5", "coef_fire_csPerson", "coef_mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire", "coef_elevation:wind_atfire", "coef_wind_atfire:Tdif_atfire", "AIC", "Model.R2", "Valid.R2", "Valid.RSME", "Valid.MAE", "Adjusted.R2")

##Add data for ALLNDT
top_mod_table_ALLNDT_lightning_t[1,1]<-"lightning and person"
top_mod_table_ALLNDT_lightning_t[1,2]<-"ALL NDTs"
top_mod_table_ALLNDT_lightning_t[1,3]<-"All T and NT"
top_mod_table_ALLNDT_lightning_t[1,4]<-"LNsize_ha ~mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire  + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs" 
top_mod_table_ALLNDT_lightning_t[1,5]<- coef(model.Spread)[1] #Intercept
top_mod_table_ALLNDT_lightning_t[1,6]<- coef(model.Spread)[2] #C
top_mod_table_ALLNDT_lightning_t[1,7]<- coef(model.Spread)[3] #C
top_mod_table_ALLNDT_lightning_t[1,8]<- coef(model.Spread)[4] #co
top_mod_table_ALLNDT_lightning_t[1,9]<- coef(model.Spread)[5] #co
top_mod_table_ALLNDT_lightning_t[1,10]<- coef(model.Spread)[6] #c
top_mod_table_ALLNDT_lightning_t[1,11]<- coef(model.Spread)[7] #l
top_mod_table_ALLNDT_lightning_t[1,12]<- coef(model.Spread)[8] #co
top_mod_table_ALLNDT_lightning_t[1,13]<- coef(model.Spread)[9] #c
top_mod_table_ALLNDT_lightning_t[1,14]<- coef(model.Spread)[10] #coeff
top_mod_table_ALLNDT_lightning_t[1,15]<- coef(model.Spread)[11] #co
top_mod_table_ALLNDT_lightning_t[1,16]<- coef(model.Spread)[12] #coe
top_mod_table_ALLNDT_lightning_t[1,17]<- coef(model.Spread)[13] #co
top_mod_table_ALLNDT_lightning_t[1,18]<- coef(model.Spread)[14] #co
top_mod_table_ALLNDT_lightning_t[1,19]<- coef(model.Spread)[15] #
top_mod_table_ALLNDT_lightning_t[1,20]<- coef(model.Spread)[16] # cl
top_mod_table_ALLNDT_lightning_t[1,21]<- coef(model.Spread)[17] # c
top_mod_table_ALLNDT_lightning_t[1,22]<- coef(model.Spread)[18] #coefficien
top_mod_table_ALLNDT_lightning_t[1,23]<- coef(model.Spread)[19] #coefficien
top_mod_table_ALLNDT_lightning_t[1,24]<- coef(model.Spread)[20] #coefficien
top_mod_table_ALLNDT_lightning_t[1,25]<- coef(model.Spread)[21] #coefficien
top_mod_table_ALLNDT_lightning_t[1,26]<- coef(model.Spread)[22] #coefficien
top_mod_table_ALLNDT_lightning_t[1,27]<- coef(model.Spread)[23] #coefficien
top_mod_table_ALLNDT_lightning_t[1,28]<- coef(model.Spread)[24] #coefficien
top_mod_table_ALLNDT_lightning_t[1,29]<- AIC(model.Spread)
top_mod_table_ALLNDT_lightning_t[1,30]<- summary(model.Spread)$r.squared
top_mod_table_ALLNDT_lightning_t[1,31]<- R2(predictions, Valid$LNsize_ha, na.rm=TRUE)
top_mod_table_ALLNDT_lightning_t[1,32]<- RMSE(predictions, Valid$LNsize_ha, na.rm=TRUE)
top_mod_table_ALLNDT_lightning_t[1,33]<- MAE(predictions, Valid$LNsize_ha, na.rm=TRUE)
top_mod_table_ALLNDT_lightning_t[1,34]<- summary(model.Spread)$adj.r.squared

top_mod_table_ALLNDT_ALL<-rbind(top_mod_table_ALLNDT_ALL, top_mod_table_ALLNDT_lightning_t)

}

```

Check.
```{r}
head(top_mod_table_ALLNDT_ALL)

```

#Save coefficient table

```{r}
write.csv(top_mod_table_ALLNDT_ALL, file="D:\\Fire\\fire_data\\raw_data\\top_mod_model.ALLNDT.Spread_firesize.csv")
```


#Get Mean Values

```{r}
names(top_mod_table_ALLNDT_ALL)

top_mod_table_ALLNDT_model.Spread_means<-top_mod_table_ALLNDT_ALL %>% summarise_each(funs( mean( .,na.rm = TRUE)))
top_mod_table_ALLNDT_model.Spread_means

top_mod_table_ALLNDT_model.Spread_means[1,1]<-"lightning and person"
top_mod_table_ALLNDT_model.Spread_means[1,2]<-"ALL NDTs"
top_mod_table_ALLNDT_model.Spread_means[1,3]<-"Treed and Not Treed"
top_mod_table_ALLNDT_model.Spread_means[1,4]<- "LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire  + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs" 
top_mod_table_ALLNDT_model.Spread_means
```
Save table.

```{r}
write.csv(top_mod_table_ALLNDT_model.Spread_means, file="D:\\Fire\\fire_data\\raw_data\\top_mod_model.ALLNDT.Spread_firesize_Means.csv")
```

Standard deviation.

```{r}
top_mod_table_ALLNDT_model.Spread_sd<-top_mod_table_ALLNDT_ALL %>% summarise_each(funs( sd( .,na.rm = TRUE)))
top_mod_table_ALLNDT_model.Spread_sd

top_mod_table_ALLNDT_model.Spread_sd[1,1]<-"lightning and person"
top_mod_table_ALLNDT_model.Spread_sd[1,2]<-"All NDTs"
top_mod_table_ALLNDT_model.Spread_sd[1,3]<-"Treed and Not Treed"
top_mod_table_ALLNDT_model.Spread_sd[1,4]<-"LNsize_ha ~ mean_tmax06_tmax07_tmax08_tmax09 + vegtype2 + mdc_atfire + mean_tmax06_tmax07_tmax08_tmax09:mdc_atfire + dist_infra + roads_km + elevation + wind_atfire+ elevation:wind_atfire  + proj_age_1 + live_stand_volume_125 + bclcs_level_2  + Tdif_atfire + Tdif_atfire:wind_atfire + ntrl_ds + fire_cs" 
top_mod_table_ALLNDT_model.Spread_sd
```

Save sd coefficient table.

```{r}
write.csv(top_mod_table_ALLNDT_model.Spread_sd, file="D:\\Fire\\fire_data\\raw_data\\top_mod_model.ALLNDT.Spread_firesize_SD.csv")
```


#Compare to transformation of variables?
Note, that in previous explorations,nearly all relationships appeared linear. For the few that did not, already explored some quadratic terms.

