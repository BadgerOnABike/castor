---
title: "06_Fire_spread_model_fits_by_FRT_data_prep"
author: "Elizabeth Kleynhans and Cora Skaien"
contributor: "Peter Ott"
date: "20/04/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library (kableExtra)
library (data.table)
library (DBI)
library (RPostgreSQL)
library (dplyr)
library (ggplot2)
library (here)
library(ggpubr)
library(arm)
library(tidyr)
library(AICcmodavg)
library(keyring)
library(caret)
library(pROC)
library(rje)
library(sf)
library(car)

source(here::here("R/functions/R_Postgres.R"))
```

<!--
Copyright 2021 Province of British Columbia

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
-->


# Introduction

Here, we are running a glm for each separate fire regime type to develop a predictive equation so that we can extrapolate which cells are likely to burn and which are not into the future. The data that we include in these glms is vegetation, climate date, and human impact. The top climate variable for each fire regime type was determined in the script "05_spread_climate_variable_selection.R". 

Before running these glms I will plot the relationship between the climate variable and probability of spread. I should probably do partial plots because I also included lat and long in these models to try to account for autocorrelation. 




```{r eval=, message=FALSE, AIC table, echo=F}

climate_variable<-read.csv("C:/Work/caribou/castor_data/Fire/Fire_sim_data/data/climate_AIC_results_spread_summary_March2023.csv")

kable (climate_variable,
       caption = "<b>Table 1. Top candidate climate variables for fire spread as selected through an AIC analysis for each Fire Regime Type.<b>",
       digits = 2) %>%
  kable_styling (position = "left",
                 bootstrap_options = c("striped", "hover"),
                 fixed_thead = T,
                 full_width = F,
                 font_size = 11)
```

# Import the data

```{r}
fire_spread<-st_read("C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\spread\\Fire_spread_data_all_veg.gpkg")
head(fire_spread)
```


```{r}
fire_spread$tot_spring_PPT<-fire_spread$PPT04+ fire_spread$PPT05 + fire_spread$PPT06
fire_spread$spring_Tave<-(fire_spread$Tave04+ fire_spread$Tave05 + fire_spread$Tave06)/3
fire_spread$tot_spring_RH<-fire_spread$RH04+ fire_spread$RH05 + fire_spread$RH06


fire_spread$tot_summer_PPT<-fire_spread$PPT07+ fire_spread$PPT08 + fire_spread$PPT09
fire_spread$summer_Tmax<-(fire_spread$Tmax07+ fire_spread$Tmax08 + fire_spread$Tmax09)/3
fire_spread$summer_Tave<-(fire_spread$Tave07+ fire_spread$Tave08 + fire_spread$Tave09)/3

fire_spread$mean_RH05_RH06_RH07_RH08<-(fire_spread$RH05 +fire_spread$RH06 +fire_spread$RH07 + fire_spread$RH08)/4
fire_spread$mean_PPT05_PPT06_PPT07_PPT08<-(fire_spread$PPT05 + fire_spread$PPT06 + fire_spread$PPT07 + fire_spread$PPT08)/4
fire_spread$mean_Tave05_Tave06_Tave07_Tave08<- (fire_spread$Tave05 + fire_spread$Tave06 +fire_spread$Tave07 + fire_spread$Tave08)/4

fire_spread$mean_Tave05_Tave06_Tave07<- (fire_spread$Tave05 + fire_spread$Tave06 +fire_spread$Tave07)/3
fire_spread$mean_PPT05_PPT06_PPT07<-(fire_spread$PPT05 + fire_spread$PPT06 + fire_spread$PPT07)/3

```


#Create climate1 and climate2 columns

```{r}
#View top variable
names(fire_spread)
unique(fire_spread$frt) # FRT 3 should not be in this list
table(is.na(fire_spread$frt))
fire_spread$frt[fire_spread$frt==3]<-5

fire_spread$frt[is.na(fire_spread$frt) & fire_spread$bec_zone_code =="IDF"]<-14
fire_spread$frt[is.na(fire_spread$frt)]<-15

table (is.na(fire_spread$frt))

fire_spread2<-st_drop_geometry(fire_spread)
#fire_spread2<-fire_spread %>% drop_na(frt)
fire_spread2$frt<-as.numeric(fire_spread2$frt)

table(fire_spread2$frt)

## Create empty vector
fire_spread2$climate1<-"NA"
head(fire_spread2)

fire_spread2<-fire_spread2 %>%
    mutate(climate1 = case_when(
                            frt == "5" ~ Tmax07 ,
                            frt == "7" ~ summer_Tmax,
                            frt == "9" ~ spring_Tave,
                            frt == "10" ~ as.numeric(mean_RH05_RH06_RH07_RH08),
                            frt == "11" ~ as.numeric(RH08),
                            frt == "12" ~ mean_Tave05_Tave06_Tave07_Tave08,
                            frt == "13" ~ mean_Tave05_Tave06_Tave07_Tave08,
                            frt == "14" ~ mean_Tave05_Tave06_Tave07,
                            frt == "15" ~ Tave05 ,
                            TRUE ~ NA_real_))

#Repeat for climate 2
fire_spread2$climate2<-"NA"

fire_spread2<-fire_spread2 %>%
    mutate(climate2 = case_when(
                            frt == "5" ~ as.numeric(PPT07),
                            frt == "7" ~ as.numeric(tot_summer_PPT),
                            frt == "9" ~ as.numeric(tot_spring_PPT),
                            frt == "10" ~ as.numeric(mean_PPT05_PPT06_PPT07_PPT08) ,
                            frt == "11" ~ as.numeric(PPT08),
                            frt == "12" ~ as.numeric(mean_PPT05_PPT06_PPT07_PPT08),
                            frt == "13" ~ as.numeric(mean_PPT05_PPT06_PPT07_PPT08),
                            frt == "14" ~ as.numeric(mean_PPT05_PPT06_PPT07),
                            frt == "15" ~ as.numeric(PPT05),
                            TRUE ~ NA_real_))

head(fire_spread2)

##Change vegtype to factor
fire_spread2$FWI_veg<-as.factor(fire_spread2$FWI_veg)

#create new column
fire_spread2$fire_veg<-paste(fire_spread2$fire, fire_spread2$FWI_veg)

```

#Change Aspect to N,S,E,W
```{r}
library(rvest)
library(tidyverse)

url <- 'http://snowfence.umn.edu/Components/winddirectionanddegreeswithouttable3.htm'
page <- read_html(url)
directions_raw <- page %>% html_node('td table') %>% html_table(header = TRUE)

directions <- directions_raw %>% 
    set_names(~tolower(sub(' Direction', '', .x))) %>% 
    slice(-1) %>% 
    separate(degree, c('degree_min', 'degree_max'), sep = '\\s+-\\s+', convert = TRUE)

directions

fire_spread2 <- fire_spread2 %>% 
    mutate(aspect_cardinal = cut(
        aspect_ha_bc, 
        breaks = c(0, directions$degree_max, 360), 
        labels = c(directions$cardinal, 'N')
    ))

fire_spread2$aspect_cardinal2<-0
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="N"]<-"N"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="E"]<-"E"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="S"]<-"S"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="W"]<-"W"

fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NNE"]<-"N"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NNW"]<-"N"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NE" & fire_spread2$aspect_ha_bc<=45]<-"N"

fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NE" & fire_spread2$aspect_ha_bc>45]<-"E"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="ENE"]<-"E"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="ESE"]<-"E"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SE" & fire_spread2$aspect_ha_bc<=135]<-"E"

fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SE" & fire_spread2$aspect_ha_bc>135]<-"S"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SSE"]<-"S"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SSW"]<-"S"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SW" & fire_spread2$aspect_ha_bc<=225]<-"S"

fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="SW" & fire_spread2$aspect_ha_bc>225]<-"W"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="WSW"]<-"W"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="WNW"]<-"W"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NW" & fire_spread2$aspect_ha_bc<=315]<-"W"
fire_spread2$aspect_cardinal2[fire_spread2$aspect_cardinal=="NW" & fire_spread2$aspect_ha_bc>315]<-"N"

fire_spread2

table(fire_spread2$aspect_cardinal2, fire_spread2$pttype)
 fire_spread2[fire_spread2$aspect_cardinal2=="0",]
 fire_spread2<-fire_spread2 %>% drop_na(aspect_cardinal)



x<-fire_spread2 %>% filter(pttype==1)

hist(x$aspect_ha_bc)
```

#View plots.

```{r}
p <- ggplot(fire_spread2, aes(aspect_ha_bc, as.numeric(pttype))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("aspect") + ylab("Pr (ignition)")

p

#  positive association with slope

ggplot(fire_spread2, aes(x = slope_ha_bc)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)

##Seeing distribution of ignitions by slope makes me believe that slope is not a big factor for ignitions despite seemingly positive trend prior.
p <- ggplot(fire_spread2, aes(dem_ha_bc, as.numeric(pttype))) +
  geom_smooth(method="glm", formula=y~x,
              method.args=list(family="binomial"),
              alpha=0.3, size=1) +
  geom_point(position=position_jitter(height=0.03, width=0)) +
  xlab("elevation") + ylab("Pr (ignition)")
p # seems like there is probably no relationship with elevation

ggplot(fire_spread2, aes(x = dem_ha_bc)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)
```

# Fit models


# FRT 5 ####

```{r}
# Plot climate data results

# also consider making box plots of these climatic variables to see how they perform



frt5<-fire_spread2 %>% filter(frt==5)

ggplot(frt5, aes(x=factor(pttype), y=Tmax07))+
geom_boxplot()
ggplot(frt5, aes(x=factor(pttype), y=PPT07))+
geom_boxplot()
ggplot(frt5, aes(x=factor(pttype), y=tot_spring_RH))+
geom_boxplot()

# I dont like tahat fires typically occur at lower Tmax07 and RH07. But Im not sure how to get around this. The ppt07 data is strongly in the correct direction so maybe that makes it ok. Im not sure.


model1 <- glm (pttype ~ Tmax07 + PPT07 ,
               data=frt5,
               family = binomial (link = "logit"))
summary(model1)

library(visreg)
visreg(model1)
visreg(model1, scale="response", "Tmax07")
visreg(model1, scale="response", "PPT07")

library(GGally)

table(is.na(frt5$win_spg))

# give places with no wind info the mean value
frt5$win_spg2<-frt5$win_spg
frt5 %>% drop_na(win_spg) %>% summarize(mean(win_spg))
frt5$win_spg2[is.na(frt5$win_spg2)]<-3.105919

table(is.na(frt5$dem_ha_bc))
table(is.na(frt5$dist_roads))
table(is.na(frt5$dist_infr_m))
table(is.na(frt5$win_spg2))

frt5_2 <-frt5 %>% st_drop_geometry()

cor.test((frt5$Tmax07), (frt5$dem_ha_bc))
cor.test((frt5$PPT07), (frt5$dem_ha_bc))
cor.test((frt5$Tmax07), (frt5$PPT07))

# Using AIC Ill pick the model that is better with leaving some of these combinations out

table(frt5_2$FWI_veg, frt5_2$pttype)
frt5_2$FWI_veg[frt5_2$FWI_veg=="S-1"]<-"M-1/2"
frt5_2$FWI_veg[frt5_2$FWI_veg=="C-4"]<-"C-2"

frt5_2<-frt5_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt5_2<-frt5_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt5_2$FWI_veg, frt5_2$pttype)

cor.test(frt5_2$climate1, frt5_2$dem_ha_bc)
cor.test(frt5_2$climate2, frt5_2$dem_ha_bc)
cor.test(frt5_2$dem_ha_bc, as.numeric(frt5_2$slope_ha_bc))
cor.test(frt5_2$dist_roads_m, frt5_2$dist_infr_m)


model1 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_spg2 + slope_ha_bc + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
summary(model1) #65912
Anova(model1, type=3)

model1 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_spg2 + slope_ha_bc + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
# 65967

model1 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_spg2 + slope_ha_bc + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
#65838

model1 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_spg2 + slope_ha_bc + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))

# BEST
model1 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_spg2 + slope_ha_bc + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
summary(model1) 
Anova(model1, type=3)
visreg(model1)

binnedplot (fitted(model1), 
            residuals(model1), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))

frt5_2$log_infra<-log(frt5_2$dist_infr+1)

# Try dropping slope
model2 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + log_infra + win_spg2  + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
summary(model2) # ok that helps
binnedplot (fitted(model2), 
            residuals(model2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))
visreg(model2)

# from the plots log_infra is not acting as I think it should. Ill try kicking it out
model3 <- glm (pttype ~ Tmax07 + PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + win_spg2  + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
AIC(model3)
AIC(model2)
# What about dropping Temp
model4 <- glm (pttype ~ PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + log_infra + win_spg2  + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))

AIC(model4)
AIC(model2)

binnedplot (fitted(model4), 
            residuals(model4), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))
visreg(model4)


# ok Ill got with model 4 as my best. 

model2 <- glm (pttype ~ PPT07 + dem_ha_bc + as.factor(FWI_veg) + dist_roads_m + log_infra + win_spg2  + as.factor(aspect_cardinal2),
               data=frt5_2,
               family = binomial (link = "logit"))
binnedplot (fitted(model2), 
            residuals(model2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))

frt5_2$resids<-resid(model2)

binnedplot (frt5_2$PPT07, 
            frt5_2$resids, 
            nclass = NULL)

binnedplot (frt5_2$dem_ha_bc, 
            frt5_2$resids)

binnedplot (frt5_2$dist_roads_m, 
            frt5_2$resids, 
            nclass = NULL)

binnedplot (frt5_2$log_infra, 
            frt5_2$resids, 
            nclass = NULL)
binnedplot (frt5_2$win_spg2, 
            frt5_2$resids, 
            nclass = NULL)

```
# FRT 5 check model fit
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt5_2)

dat2_b<-frt5_2 %>% dplyr::select(pttype, PPT07, dem_ha_bc, dist_roads_m, log_infra, win_spg2 )
probabilities <- predict(model2, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear which is mostly true
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model2, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model2) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(PPT07, dem_ha_bc,dist_roads_m ,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model2)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
summary(model2)
frt5_2$aspect_cardinal2<-as.factor(frt5_2$aspect_cardinal2)
frt5_2$FWI_veg<-as.factor(frt5_2$FWI_veg)

model2 <- glm (pttype ~ PPT07 + dem_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m + log(dist_infr_m+1) + win_spg2,
               data=frt5_2,
               family = binomial (link = "logit"))

summary(model2)
table(frt5_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_FRT5_All <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_FRT5_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_PPT07", 
                                    "coef_elevation", 
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3", 
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-2",
                                    "coef_dist_roads",
                                    "coef_log_dist_infr",
                                    "coef_win_spg",
                                    "AUC")

frt5_2$fire_veg<-paste(frt5_2$pttype, frt5_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt5_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt5_2[ trainIndex,]
   Valid <- frt5_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ PPT07 + dem_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m + log(dist_infr_m+1) + win_spg2, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_FRT5_person <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_FRT5_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_PPT07", 
                                    "coef_elevation", 
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3", 
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-2",
                                    "coef_dist_roads",
                                    "coef_dist_infr",
                                    "coef_win_spg",
                                    "AUC")

##Add data for NDT1
top_mod_table_FRT5_person[1,1]<-"spread"
top_mod_table_FRT5_person[1,2]<-"frt5"
top_mod_table_FRT5_person[1,3]<-"pttype ~ PPT07 + elev + aspect + FWI_veg + dist_road + dist_infa + win_spg"
top_mod_table_FRT5_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_FRT5_person[1,5]<- coef(mod)[2] 
top_mod_table_FRT5_person[1,6]<- coef(mod)[3] 
top_mod_table_FRT5_person[1,7]<- coef(mod)[4] 
top_mod_table_FRT5_person[1,8]<- coef(mod)[5] 
top_mod_table_FRT5_person[1,9]<- coef(mod)[6] 
top_mod_table_FRT5_person[1,10]<- coef(mod)[7] 
top_mod_table_FRT5_person[1,11]<- coef(mod)[8] 
top_mod_table_FRT5_person[1,12]<- coef(mod)[9] 
top_mod_table_FRT5_person[1,13]<- coef(mod)[10] 
top_mod_table_FRT5_person[1,14]<- coef(mod)[11] 
top_mod_table_FRT5_person[1,15]<- coef(mod)[12] 
top_mod_table_FRT5_person[1,16]<- coef(mod)[13] 
top_mod_table_FRT5_person[1,17]<- coef(mod)[14] 
top_mod_table_FRT5_person[1,18]<- coef(mod)[15] 
top_mod_table_FRT5_person[1,19]<- coef(mod)[16] 
top_mod_table_FRT5_person[1,20]<- coef(mod)[17] 
top_mod_table_FRT5_person[1,21]<- coef(mod)[18] 
top_mod_table_FRT5_person[1,22]<- coef(mod)[19] 
top_mod_table_FRT5_person[1,23]<- mod.auc

top_mod_table_FRT5_All<-rbind(top_mod_table_FRT5_All, top_mod_table_FRT5_person)

}

```

Check.
```{r}
head(top_mod_table_FRT5_All)

```


Get mean values.

```{r}
names(top_mod_table_FRT5_All)
str(top_mod_table_FRT5_All)
stderror <- function(x) sd(x)/sqrt(length(x))

FRT5_summary_table_mean<- top_mod_table_FRT5_All %>% summarize_if(is.numeric,mean)


```

#Save table.

```{r}
write.csv(FRT5_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt5_spread.csv")
```


# FRT 7

```{r}
# Plot climate data results

# note that although more fires occur in spring than in summer, the area burned in summer is much more than in spring. So using summer climate variables makes sense I think.

frt7<-fire_spread2 %>% filter(frt==7)
model1 <- glm (pttype ~ climate1 + climate2 ,
               data=frt7,
               family = binomial (link = "logit"))
summary(model1)

library(visreg)
visreg(model1, scale="response", "climate1")
visreg(model1, scale="response", "climate2")
visreg(model1)


table(is.na(frt7$win_sum))
table(is.na(frt7$dem_ha_bc))
frt7 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt7$win_sum[is.na(frt7$win_sum)]<-3.062752

frt7_2 <-frt7 %>% st_drop_geometry()

table(frt7_2$FWI_veg, frt7_2$pttype)
frt7_2$FWI_veg[frt7_2$FWI_veg=="C-4"]<-"C-2"
frt7_2$FWI_veg[frt7_2$FWI_veg=="M-3"]<-"O-1a/b"

frt7_2<-frt7_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt7_2<-frt7_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt7_2$FWI_veg, frt7_2$pttype)

cor.test(frt7_2$climate1, frt7_2$dem_ha_bc)
cor.test(frt7_2$climate2, frt7_2$dem_ha_bc)
cor.test(frt7_2$dist_roads_m, frt7_2$dist_infr_m)


model1 <- glm (pttype ~ summer_Tmax + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum, data=frt7_2, family = binomial (link = "logit"))
summary(model1) #15282
Anova(model1, type=3)

model1a <- glm (pttype ~ summer_Tmax + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum, data=frt7_2, family = binomial (link = "logit")) #15270


model1b <- glm (pttype ~ summer_Tmax + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum, data=frt7_2, family = binomial (link = "logit")) #15300

model1c <- glm (pttype ~ summer_Tmax + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum, data=frt7_2, family = binomial (link = "logit")) #15310

# including dist to roads with log helps but does not seem tohelp for dist to infra

model2<-glm (pttype ~ summer_Tmax + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum, data=frt7_2, family = binomial (link = "logit")) #
AIC(model2)
summary(model2) #15269.58
Anova(model2, type=3)

visreg(model2)

model3<-glm (pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum, data=frt7_2, family = binomial (link = "logit"))
AIC(model3)#15269.89
Anova(model3, type=3)
visreg(model3)

frt7_2$log_dist_roads_m<-log(frt7_2$dist_roads_m+1)

model4<-glm (pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum, data=frt7_2, family = binomial (link = "logit"))
summary(model4) #15278
Anova(model4, type=3)
visreg(model4)

model5<-glm (pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m, data=frt7_2, family = binomial (link = "logit")) 
summary(model5) #15286
Anova(model4, type=3)
visreg(model4)


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model3), 
            residuals(model3), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt7_2$resids<-resid(model3)

binnedplot (as.numeric(frt7_2$tot_summer_PPT), 
            frt7_2$resids)

binnedplot (frt7_2$dem_ha_bc, 
            frt7_2$resids)

binnedplot (frt7_2$slope_ha_bc, 
            frt7_2$resids)

binnedplot (frt7_2$dist_roads_m, 
            frt7_2$resids, 
            nclass = NULL)

binnedplot (frt7_2$dist_infr_m, 
            frt7_2$resids, 
            nclass = NULL)

```

```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt7_2)

dat2_b<-frt7_2 %>% dplyr::select(pttype, summer_Tmax, tot_summer_PPT, dem_ha_bc, dist_roads_m, dist_infr_m )
probabilities <- predict(model1a, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear which is mostly true
```

Checking assumption of influential values
see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model3, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model3) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(summer_Tmax, tot_summer_PPT,  slope_ha_bc, dist_infr_m, .std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model3)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt7_2$FWI_veg<-as.factor(frt7_2$FWI_veg)

model1 <- glm (pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m,
               data=frt7_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt7_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt7_All <- data.frame (matrix (ncol = 22, nrow = 0))
colnames (top_mod_table_frt7_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_summer_Tmax", 
                                    "coef_tot_summer_PPT",
                                    "coef_slope", 
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_log_dist_roads",
                                    "coef_dist_infr",
                                    "AUC")

frt7_2$fire_veg<-paste(frt7_2$pttype, frt7_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt7_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt7_2[ trainIndex,]
   Valid <- frt7_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + FWI_veg + log_dist_roads_m + dist_infr_m, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt7_person <- data.frame (matrix (ncol = 22, nrow = 0))
colnames (top_mod_table_frt7_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_summer_Tmax", 
                                    "coef_tot_summer_PPT",
                                    "coef_slope", 
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_log_dist_roads",
                                    "coef_dist_infr",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt7_person[1,1]<-"spread"
top_mod_table_frt7_person[1,2]<-"frt7"
top_mod_table_frt7_person[1,3]<-"pttype ~ summer_Tmax + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + FWI_veg + log_dist_roads_m + dist_infr_m"
top_mod_table_frt7_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt7_person[1,5]<- coef(mod)[2] 
top_mod_table_frt7_person[1,6]<- coef(mod)[3] 
top_mod_table_frt7_person[1,7]<- coef(mod)[4] 
top_mod_table_frt7_person[1,8]<- coef(mod)[5] 
top_mod_table_frt7_person[1,9]<- coef(mod)[6] 
top_mod_table_frt7_person[1,10]<- coef(mod)[7] 
top_mod_table_frt7_person[1,11]<- coef(mod)[8] 
top_mod_table_frt7_person[1,12]<- coef(mod)[9] 
top_mod_table_frt7_person[1,13]<- coef(mod)[10] 
top_mod_table_frt7_person[1,14]<- coef(mod)[11] 
top_mod_table_frt7_person[1,15]<- coef(mod)[12] 
top_mod_table_frt7_person[1,16]<- coef(mod)[13] 
top_mod_table_frt7_person[1,17]<- coef(mod)[14] 
top_mod_table_frt7_person[1,18]<- coef(mod)[15] 
top_mod_table_frt7_person[1,19]<- coef(mod)[16] 
top_mod_table_frt7_person[1,20]<- coef(mod)[17] 
top_mod_table_frt7_person[1,21]<- coef(mod)[18] 
top_mod_table_frt7_person[1,22]<- mod.auc

top_mod_table_frt7_All<-rbind(top_mod_table_frt7_All, top_mod_table_frt7_person)

}

```

Check.
```{r}
head(top_mod_table_frt7_All)

```


Get mean values.

```{r}
names(top_mod_table_frt7_All)
str(top_mod_table_frt7_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt7_summary_table_mean<- top_mod_table_frt7_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt7_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt7_spread.csv")
```

################################
#FRT 9
################################

```{r}
# Plot climate data results

frt9<-fire_spread2 %>% filter(frt==9)
model1 <- glm (pttype ~ climate1 + climate2 ,
               data=frt9,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "climate1")
visreg(model1, scale="response", "climate2")

table(is.na(frt9$win_sum))

frt9 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt9$win_sum[is.na(frt9$win_sum)]<-3.898718


frt9_2 <-frt9 %>% st_drop_geometry()

table(frt9_2$FWI_veg, frt9_2$pttype)

frt9_2<-frt9_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt9_2<-frt9_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt9_2$FWI_veg, frt9_2$pttype)

# note tave_spring and elevation; and dist_road and dist_infra are > 0.7 correlated so must remove one of each of these.

model1 <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_spg, data=frt9_2,
               family = binomial (link = "logit"))
AIC(model1) #21754.66
summary(model1)
Anova(model1, type=3)

model1a <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_spg,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model1a) #21643.51

model1b <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_spg,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model1b) #21742.36

model1c <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_spg,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model1c) #21677.39



model1a <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_spg,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model1a) #21643.51
Anova(model1a)

# removing slope is better

model2 <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_spg,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model2) #21642.49
Anova(model2, type=3)

# remove wind

model3 <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m,
               data=frt9_2,
               family = binomial (link = "logit"))
AIC(model3) #21642.64
Anova(model3, type=3)


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model3), 
            residuals(model3), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt9_2$resids<-resid(model3)

binnedplot (frt9_2$tot_spring_PPT, 
            frt9_2$resids)

binnedplot (frt9_2$dem_ha_bc                     , 
            frt9_2$resids, 
            nclass = NULL)

binnedplot (frt9_2$dist_infr_m  , 
            frt9_2$resids, 
            nclass = NULL)

binnedplot (log(frt9_2$dist_roads_m+1), 
            frt9_2$resids, 
            nclass = NULL)

binnedplot (frt9_2$tot_spring_PPT, 
            frt9_2$resids, 
            nclass = NULL)


```

```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt9_2)

dat2_b<-frt9_2 %>% dplyr::select(pttype, spring_Tave, tot_spring_PPT,Latitude, Longitude, dist_roads_m, dist_infr_m )
probabilities <- predict(model1e, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear which is mostly true
```

Checking assumption of influential values
see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model3, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model3) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(spring_Tave, tot_spring_PPT,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model3)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt9_2$aspect_cardinal2<-as.factor(frt9_2$aspect_cardinal2)
frt9_2$FWI_veg<-as.factor(frt9_2$FWI_veg)
frt9_2$dist_roads_m_log<-log(frt9_2$dist_roads_m+1)

model1 <- glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m_log + dist_infr_m,
               data=frt9_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt9_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt9_All <- data.frame (matrix (ncol = 20, nrow = 0))
colnames (top_mod_table_frt9_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_spring_Tave", 
                                    "coef_tot_spring_PPT",
                                    "coef_elev",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_log_dist_roads",
                                    "coef_dist_infr_m",
                                    "AUC")

frt9_2$fire_veg<-paste(frt9_2$pttype, frt9_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt9_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt9_2[ trainIndex,]
   Valid <- frt9_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m_log + dist_infr_m, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt9_person <- data.frame (matrix (ncol = 20, nrow = 0))
colnames (top_mod_table_frt9_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_spring_Tave", 
                                    "coef_tot_spring_PPT",
                                    "coef_elev",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_log_dist_roads",
                                    "coef_dist_infr_m",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt9_person[1,1]<-"spread"
top_mod_table_frt9_person[1,2]<-"frt9"
top_mod_table_frt9_person[1,3]<-"pttype ~ spring_Tave + tot_spring_PPT + dem_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m_log + dist_infr_m"
top_mod_table_frt9_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt9_person[1,5]<- coef(mod)[2] 
top_mod_table_frt9_person[1,6]<- coef(mod)[3] 
top_mod_table_frt9_person[1,7]<- coef(mod)[4] 
top_mod_table_frt9_person[1,8]<- coef(mod)[5] 
top_mod_table_frt9_person[1,9]<- coef(mod)[6] 
top_mod_table_frt9_person[1,10]<- coef(mod)[7] 
top_mod_table_frt9_person[1,11]<- coef(mod)[8] 
top_mod_table_frt9_person[1,12]<- coef(mod)[9] 
top_mod_table_frt9_person[1,13]<- coef(mod)[10] 
top_mod_table_frt9_person[1,14]<- coef(mod)[11] 
top_mod_table_frt9_person[1,15]<- coef(mod)[12] 
top_mod_table_frt9_person[1,16]<- coef(mod)[13] 
top_mod_table_frt9_person[1,17]<- coef(mod)[14] 
top_mod_table_frt9_person[1,18]<- coef(mod)[15] 
top_mod_table_frt9_person[1,19]<- coef(mod)[16] 
top_mod_table_frt9_person[1,20]<- mod.auc

top_mod_table_frt9_All<-rbind(top_mod_table_frt9_All, top_mod_table_frt9_person)

}

```

Check.
```{r}
head(top_mod_table_frt9_All)

```


Get mean values.

```{r}
names(top_mod_table_frt9_All)
str(top_mod_table_frt9_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt9_summary_table_mean<- top_mod_table_frt9_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt9_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt9_spread.csv")
```

################################
#FRT 10
################################

```{r}
# Plot climate data results

frt10<-fire_spread2 %>% filter(frt==10)
model1 <- glm (pttype ~ climate1 + climate2 ,
               data=frt10,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "climate1")
visreg(model1, scale="response", "climate2")
visreg(model1, "climate1")

table(is.na(frt10$win_sum))
table(is.na(frt10$dem_ha_bc))

frt10 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt10$win_sum[is.na(frt10$win_sum)]<-3.063132

frt10_2 <-frt10 %>% st_drop_geometry()

table(frt10_2$FWI_veg, frt10_2$pttype)
frt10_2$FWI_veg[frt10_2$FWI_veg=="S-2"]<-"C-7"
#frt10_2$FWI_veg[frt10_2$FWI_veg=="M-3"]<-"O-1a/b"

frt10_2<-frt10_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt10_2<-frt10_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt10_2$FWI_veg, frt10_2$pttype)

cor.test(frt10_2$dem_ha_bc, frt10_2$climate2)
cor.test(frt10_2$dem_ha_bc, frt10_2$climate1)
cor.test(frt10_2$climate2, frt10_2$climate1)

# note climate1 and elevation; and longitude and elevation are > 0.7 correlated so must remove one of each of these... probably elevation since its causing issues

model1 <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
summary(model1) #40385

model1a <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
summary(model1a) #40386

model1b <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
summary(model1b) #40583

model1c <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
summary(model1c) #40621

# Does taking the logorithm of roads and infrastructure help?

model2<-glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
AIC(model2) #40385.34
Anova(model2, type=3)
visreg(model2)

model3<-glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m + win_sum, data=frt10_2,
               family = binomial (link = "logit"))
AIC(model3) #40389.56
Anova(model3, type=3)

model4<-glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m, data=frt10_2,
               family = binomial (link = "logit"))
AIC(model4) 
Anova(model4, type=3)
visreg(model4)

model5<-glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m, data=frt10_2,
               family = binomial (link = "logit"))
AIC(model5) 
Anova(model5, type=3)
visreg(model5)


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model5), 
            residuals(model5), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt10_2$resids<-resid(model5)

plot (as.numeric(frt10_2$climate1), 
            frt10_2$resids)

binnedplot (frt10_2$climate1                     , 
            frt10_2$resids, 
            nclass = NULL)

binnedplot (frt10_2$climate2  , 
            frt10_2$resids, 
            nclass = NULL)

binnedplot (frt10_2$dem_ha_bc, 
            frt10_2$resids, 
            nclass = NULL)

binnedplot (frt10_2$slope_ha_bc, 
            frt10_2$resids, 
            nclass = NULL)

binnedplot (frt10_2$dist_infr_m, 
            frt10_2$resids, 
            nclass = NULL)


```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt10_2)

dat2_b<-frt10_2 %>% dplyr::select(pttype, climate1, climate2,Latitude, Longitude, dist_roads_m, dist_infr_m )
probabilities <- predict(model1a, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model5, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model5) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(climate1, climate2,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model5)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt10_2$aspect_cardinal2<-as.factor(frt10_2$aspect_cardinal2)
frt10_2$FWI_veg<-as.factor(frt10_2$FWI_veg)

model1 <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_infr_m,
               data=frt10_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt10_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt10_All <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_frt10_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_climate1", 
                                    "coef_climate2",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_dist_infr",
                                    "AUC")

frt10_2$fire_veg<-paste(frt10_2$pttype, frt10_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt10_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt10_2[ trainIndex,]
   Valid <- frt10_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_infr_m, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt10_person <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_frt10_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_climate1", 
                                    "coef_climate2",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_dist_infr",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt10_person[1,1]<-"spread"
top_mod_table_frt10_person[1,2]<-"frt10"
top_mod_table_frt10_person[1,3]<-"climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_infr_m"
top_mod_table_frt10_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt10_person[1,5]<- coef(mod)[2] 
top_mod_table_frt10_person[1,6]<- coef(mod)[3] 
top_mod_table_frt10_person[1,7]<- coef(mod)[4] 
top_mod_table_frt10_person[1,8]<- coef(mod)[5] 
top_mod_table_frt10_person[1,9]<- coef(mod)[6] 
top_mod_table_frt10_person[1,10]<- coef(mod)[7] 
top_mod_table_frt10_person[1,11]<- coef(mod)[8] 
top_mod_table_frt10_person[1,12]<- coef(mod)[9] 
top_mod_table_frt10_person[1,13]<- coef(mod)[10] 
top_mod_table_frt10_person[1,14]<- coef(mod)[11] 
top_mod_table_frt10_person[1,15]<- coef(mod)[12] 
top_mod_table_frt10_person[1,16]<- coef(mod)[13] 
top_mod_table_frt10_person[1,17]<- coef(mod)[14] 
top_mod_table_frt10_person[1,18]<- coef(mod)[15] 
top_mod_table_frt10_person[1,19]<- coef(mod)[16] 
top_mod_table_frt10_person[1,20]<- coef(mod)[17] 
top_mod_table_frt10_person[1,21]<- coef(mod)[18] 
top_mod_table_frt10_person[1,22]<- coef(mod)[19] 
top_mod_table_frt10_person[1,23]<- mod.auc

top_mod_table_frt10_All<-rbind(top_mod_table_frt10_All, top_mod_table_frt10_person)

}

```

Check.
```{r}
head(top_mod_table_frt10_All)

```


Get mean values.

```{r}
names(top_mod_table_frt10_All)
str(top_mod_table_frt10_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt10_summary_table_mean<- top_mod_table_frt10_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt10_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt10_spread.csv")
```


################################
#FRT 11
################################

```{r}
# Plot climate data results

frt9_11<-fire_spread2 %>% filter(frt %in% c(9,11))

ggplot(frt9_11, aes(x=as.factor(pttype), y=spring_Tave, fill=as.factor(frt))) +
geom_boxplot()

ggplot(frt9_11, aes(x=as.factor(pttype), y=tot_spring_PPT, fill=as.factor(frt))) +
geom_boxplot()

ggplot(frt9_11, aes(x=as.factor(pttype), y=RH08, fill=as.factor(frt))) +
geom_boxplot()

ggplot(frt11, aes(x=as.factor(pttype), y=PPT08, fill=as.factor(frt))) +
geom_boxplot()



frt11<-fire_spread2 %>% filter(frt==11)
model1 <- glm (pttype ~ PPT08 ,
               data=frt11,
               family = binomial (link = "logit"))
summary(model1)
visreg(model1)
visreg(model1, scale="response", "PPT08")

table(is.na(frt11$win_sum))
table(is.na(frt11$dem_ha_bc))
table(is.na(frt11$slope_ha_bc))

frt11_2 <-frt11 %>% st_drop_geometry()

table(frt11_2$FWI_veg, frt11_2$pttype)

frt11_2<-frt11_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt11_2<-frt11_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt11_2$FWI_veg, frt11_2$pttype)

# Nothing is very correlated 

model1 <- glm (pttype ~ PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))
summary(model1) #59349
Anova(model1, type=3)

model2 <- glm (pttype ~ PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))
summary(model2) #59548
Anova(model2, type=3)

model3 <- glm (pttype ~ PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))
summary(model3) #59351
Anova(model3, type=3)

# remove least significant terms
model1 <- glm (pttype ~ PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))

summary(model3) #59349
Anova(model3, type=3)

model2 <- glm (pttype ~ PPT08 + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))

summary(model2) #59347
Anova(model2, type=3)

model3 <- glm (pttype ~ PPT08 + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))

summary(model3) #59351
Anova(model3, type=3)


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model2), 
            residuals(model2), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt11_2$resids<-resid(model3)

binnedplot (as.numeric(frt11_2$PPT08), 
            frt11_2$resids)

binnedplot (frt11_2$slope_ha_bc, 
            frt11_2$resids, 
            nclass = NULL)

binnedplot (frt11_2$dist_roads_m  , 
            frt11_2$resids, 
            nclass = NULL)

binnedplot (frt11_2$dist_roads_m, 
            frt11_2$resids, 
            nclass = NULL)

binnedplot (frt11_2$dist_infr_m, 
            frt11_2$resids, 
            nclass = NULL)

binnedplot (frt11_2$win_sum, 
            frt11_2$resids, 
            nclass = NULL)

```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt11_2)

dat2_b<-frt11_2 %>% dplyr::select(pttype, climate1, climate2,Latitude, Longitude, dist_roads_m )
probabilities <- predict(model3, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model2, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model2) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(PPT08,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model2)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt11_2$aspect_cardinal2<-as.factor(frt11_2$aspect_cardinal2)
frt11_2$FWI_veg<-as.factor(frt11_2$FWI_veg)

model1 <- glm (pttype ~ PPT08 + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m + dist_infr_m + win_sum,
               data=frt11_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt11_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt11_All <- data.frame (matrix (ncol = 21, nrow = 0))
colnames (top_mod_table_frt11_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_PPT08", 
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_dist_roads",
                                    "coef_dist_infr",
                                    "coef_wind_summer",
                                    "AUC")

frt11_2$fire_veg<-paste(frt11_2$pttype, frt11_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt11_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt11_2[ trainIndex,]
   Valid <- frt11_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ PPT08 + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m + dist_infr_m + win_sum, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt11_person <- data.frame (matrix (ncol = 21, nrow = 0))
colnames (top_mod_table_frt11_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_PPT08", 
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_dist_roads",
                                    "coef_dist_infr",
                                    "coef_wind_summer",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt11_person[1,1]<-"spread"
top_mod_table_frt11_person[1,2]<-"frt11"
top_mod_table_frt11_person[1,3]<-"pttype ~ PPT08 + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_roads_m + dist_infr_m + win_sum"
top_mod_table_frt11_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt11_person[1,5]<- coef(mod)[2] 
top_mod_table_frt11_person[1,6]<- coef(mod)[3] 
top_mod_table_frt11_person[1,7]<- coef(mod)[4] 
top_mod_table_frt11_person[1,8]<- coef(mod)[5] 
top_mod_table_frt11_person[1,9]<- coef(mod)[6] 
top_mod_table_frt11_person[1,10]<- coef(mod)[7] 
top_mod_table_frt11_person[1,11]<- coef(mod)[8] 
top_mod_table_frt11_person[1,12]<- coef(mod)[9] 
top_mod_table_frt11_person[1,13]<- coef(mod)[10] 
top_mod_table_frt11_person[1,14]<- coef(mod)[11] 
top_mod_table_frt11_person[1,15]<- coef(mod)[12] 
top_mod_table_frt11_person[1,16]<- coef(mod)[13] 
top_mod_table_frt11_person[1,17]<- coef(mod)[14] 
top_mod_table_frt11_person[1,18]<- coef(mod)[15] 
top_mod_table_frt11_person[1,19]<- coef(mod)[16] 
top_mod_table_frt11_person[1,20]<- coef(mod)[17] 
top_mod_table_frt11_person[1,21]<- mod.auc

top_mod_table_frt11_All<-rbind(top_mod_table_frt11_All, top_mod_table_frt11_person)

}

```

Check.
```{r}
head(top_mod_table_frt11_All)

```


Get mean values.

```{r}
names(top_mod_table_frt11_All)
str(top_mod_table_frt11_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt11_summary_table_mean<- top_mod_table_frt11_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt11_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt11_spread.csv")
```


################################
#FRT 12
################################

```{r}
# Plot climate data results

frt12<-fire_spread2 %>% filter(frt==12)
# climate 1 was mean_Tave05_Tave06_Tave07_Tave08 and climate 2 was mean_PPT05_PPT06_PPT07_PPT08 but climate 1 does not really seem to have any trend see box plot below, so I may just use climate 2
ggplot(frt12, aes(x=as.factor(pttype), y=mean_PPT05_PPT06_PPT07_PPT08, fill=as.factor(frt))) +
geom_boxplot()

ggplot(frt12, aes(x=as.factor(pttype), y=mean_Tave05_Tave06_Tave07_Tave08, fill=as.factor(frt))) +
geom_boxplot()


model1 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08,
               data=frt12,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "mean_PPT05_PPT06_PPT07_PPT08")

table(is.na(frt12$win_sum))
table(is.na(frt12$slope_ha_bc))

frt12_2 <-frt12 %>% st_drop_geometry()

table(frt12_2$FWI_veg, frt12_2$pttype)
frt12_2$FWI_veg[frt12_2$FWI_veg=="S-3"]<-"C-7"


frt12_2<-frt12_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt12_2<-frt12_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt12_2$FWI_veg, frt12_2$pttype)

cor.test(frt12_2$climate2, frt12_2$dem_ha_bc)
cor.test(frt12_2$dist_roads_m, frt12_2$dist_infr_m)
cor.test(frt12_2$dem_ha_bc, frt12_2$slope_ha_bc)


model1 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model1) #181762
Anova(model1, type=3)

model2 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model2) #180726
Anova(model2, type=3)

model3 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model3) #180227
Anova(model3, type=3)

model4 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model4) #179403
Anova(model4, type=3)
# Tking the logorithm of roads and infrastructure really helps

frt12_2$log_roads<-log(frt12_2$dist_roads_m+1)
frt12_2$log_infra<-log(frt12_2$dist_infr_m+1)

# now removing insiginificant terms
model5 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(FWI_veg) + log_roads + log_infra + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model5) #179401
visreg(model5)

model6 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + log(dem_ha_bc) + slope_ha_bc + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))
summary(model6) #179060
Anova(model5)




# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model6), 
            residuals(model5), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt12_2$resids<-resid(model5)

binnedplot (as.numeric(frt12_2$climate2), 
            frt12_2$resids)

binnedplot (log(frt12_2$dem_ha_bc )                    , 
            frt12_2$resids, 
            nclass = NULL)

binnedplot (frt12_2$slope_ha_bc  , 
            frt12_2$resids, 
            nclass = NULL)

binnedplot (log(frt12_2$dist_roads_m+1), 
            frt12_2$resids, 
            nclass = NULL)

binnedplot (log(frt12_2$dist_infr_m+1), 
            frt12_2$resids, 
            nclass = NULL)


```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt12_2)

dat2_b<-frt12_2 %>% dplyr::select(pttype, mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc )
probabilities <- predict(model5, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model5, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model5) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(mean_PPT05_PPT06_PPT07_PPT08,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model5)

cor.test(frt12_2$climate1, frt12_2$Latitude)
cor.test(frt12_2$climate1, frt12_2$dem_ha_bc)
cor.test(frt12_2$Latitude, frt12_2$dem_ha_bc)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


## RUN BELOW

```{r}
frt12_2$FWI_veg<-as.factor(frt12_2$FWI_veg)

model1 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(FWI_veg) + log_roads + log_infra + win_sum,
               data=frt12_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt12_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt12_All <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_frt12_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_mean_PPT05_PPT06_PPT07_PPT08 ",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-4",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_log_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

frt12_2$fire_veg<-paste(frt12_2$pttype, frt12_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt12_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt12_2[ trainIndex,]
   Valid <- frt12_2[-trainIndex,]
   
#Model   
mod<-glm(pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(FWI_veg) + log_roads + log_infra + win_sum, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt12_person <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_frt12_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_mean_PPT05_PPT06_PPT07_PPT08 ",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_FWI_veg_C-2", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-4",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_log_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt12_person[1,1]<-"spread"
top_mod_table_frt12_person[1,2]<-"frt12"
top_mod_table_frt12_person[1,3]<-"mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + FWI_veg + log_roads + log_infra + win_sum"
top_mod_table_frt12_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt12_person[1,5]<- coef(mod)[2] 
top_mod_table_frt12_person[1,6]<- coef(mod)[3] 
top_mod_table_frt12_person[1,7]<- coef(mod)[4] 
top_mod_table_frt12_person[1,8]<- coef(mod)[5] 
top_mod_table_frt12_person[1,9]<- coef(mod)[6] 
top_mod_table_frt12_person[1,10]<- coef(mod)[7] 
top_mod_table_frt12_person[1,11]<- coef(mod)[8] 
top_mod_table_frt12_person[1,12]<- coef(mod)[9] 
top_mod_table_frt12_person[1,13]<- coef(mod)[10] 
top_mod_table_frt12_person[1,14]<- coef(mod)[11] 
top_mod_table_frt12_person[1,15]<- coef(mod)[12] 
top_mod_table_frt12_person[1,16]<- coef(mod)[13] 
top_mod_table_frt12_person[1,17]<- coef(mod)[14] 
top_mod_table_frt12_person[1,18]<- coef(mod)[15] 
top_mod_table_frt12_person[1,19]<- coef(mod)[16] 
top_mod_table_frt12_person[1,20]<- coef(mod)[17] 
top_mod_table_frt12_person[1,21]<- coef(mod)[18] 
top_mod_table_frt12_person[1,22]<- coef(mod)[19] 
top_mod_table_frt12_person[1,23]<- mod.auc

top_mod_table_frt12_All<-rbind(top_mod_table_frt12_All, top_mod_table_frt12_person)

}

```

Check.
```{r}
head(top_mod_table_frt12_All)

```


Get mean values.

```{r}
names(top_mod_table_frt12_All)
str(top_mod_table_frt12_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt12_summary_table_mean<- top_mod_table_frt12_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt12_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt12_spread.csv")
```

################################
#FRT 13
################################

```{r}
# Plot climate data results

frt13<-fire_spread2 %>% filter(frt==13)
model1 <- glm (pttype ~ climate1 + climate2 ,
               data=frt13,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "climate1")
visreg(model1, scale="response", "climate2")
visreg(model1)

ggplot(frt13, aes(x = climate1)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)

ggplot(frt13, aes(x = as.factor(pttype), y=climate1)) +
  geom_boxplot()
ggplot(frt13, aes(x = as.factor(pttype), y=climate2)) +
  geom_boxplot()

ggplot(frt13, aes(x = climate2)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)

table(is.na(frt13$win_sum))
table(is.na(frt13$Tmax07))

frt13 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt13$win_sum[is.na(frt13$win_sum)]<-2.745897

frt13_2 <-frt13 %>% st_drop_geometry()

table(frt13_2$FWI_veg, frt13_2$pttype)
frt13_2$FWI_veg[frt13_2$FWI_veg=="C-1"]<-"C-3"
frt13_2$FWI_veg[frt13_2$FWI_veg=="C-4"]<-"C-2"


frt13_2<-frt13_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt13_2<-frt13_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt13_2$FWI_veg, frt13_2$pttype)

require (ggcorrplot)
dist.cut.corr <- (frt13_2 [, c("climate1", "climate2", "dem_ha_bc", "Latitude", "Longitude", "slope_ha_bc", "win_sum", "dist_infr_m", "dist_roads_m")])
corr <- round (cor (dist.cut.corr), 3)
p.mat <- round (cor_pmat (dist.cut.corr), 2)
ggcorrplot (corr, type = "lower", lab = TRUE, tl.cex = 10,  lab_size = 3)
# Note climate 1 and dem are correlated. This is good. Ill toss out climate 1 because its not behaving as I expect

model1 <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model1) #187039
Anova(model1, type=3)

model2 <- glm (pttype ~ climate1 + climate2 + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model2) #187100
Anova(model2, type=3)

model3<-glm (pttype ~ climate2 + slope_ha_bc + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model3) #187164
Anova(model3, type=3)

# Although the model with climate 1 is better I rather stick with elevation # Now check log roads and infrastructure.

model4 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model4) #186868
Anova(model1, type=3)

model5 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model5)#186681

model6 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model6)#186433
Anova(model6, type=3)

# looks like slope is not significant so Ill remove it
frt13_2$log_dist_infr<-log(frt13_2$dist_infr_m+1)
frt13_2$log_dist_road<-log(frt13_2$dist_roads_m+1)

model7 <- glm (pttype ~ Latitude + mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + log_dist_road + log_dist_infr + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))
summary(model7)#186434
Anova(model7, type=3)
visreg(model7)


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model7), 
            residuals(model7), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt13_2$resids<-resid(model6)

binnedplot (frt13_2$dem_ha_bc, 
            frt13_2$resids)

binnedplot (as.numeric(frt13_2$climate2), 
            frt13_2$resids)

binnedplot (frt13_2$dist_roads_m, 
            frt13_2$resids, 
            nclass = NULL)

binnedplot (log(frt13_2$dist_roads_m+1), 
            frt13_2$resids, 
            nclass = NULL)

binnedplot (log(frt13_2$dist_infr_m+1), 
            frt13_2$resids, 
            nclass = NULL)

binnedplot (frt13_2$slope_ha_bc, 
            frt13_2$resids, 
            nclass = NULL)



```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt13_2)

dat2_b<-frt13_2 %>% dplyr::select(climate2, dem_ha_bc,dist_roads_m, dist_infr_m )
probabilities <- predict(model3, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model7, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model6) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(dem_ha_bc, mean_PPT05_PPT06_PPT07_PPT08,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model7)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt13_2$aspect_cardinal2<-as.factor(frt13_2$aspect_cardinal2)
frt13_2$FWI_veg<-as.factor(frt13_2$FWI_veg)

model1 <- glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m +1)+ log(dist_infr_m+1) + win_sum,
               data=frt13_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt13_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt13_All <- data.frame (matrix (ncol = 24, nrow = 0))
colnames (top_mod_table_frt13_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_mean_PPT05_PPT06_PPT07_PPT08 ",
                                    "coef_elevation",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_FWI_veg_S-3",
                                    "coef_log_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

frt13_2$fire_veg<-paste(frt13_2$pttype, frt13_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt13_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt13_2[ trainIndex,]
   Valid <- frt13_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m +1)+ log(dist_infr_m+1) + win_sum, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt13_person <- data.frame (matrix (ncol = 24, nrow = 0))
colnames (top_mod_table_frt13_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept", 
                                    "coef_mean_PPT05_PPT06_PPT07_PPT08 ",
                                    "coef_elevation",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_M-3",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_FWI_veg_S-2",
                                    "coef_FWI_veg_S-3",
                                    "coef_log_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt13_person[1,1]<-"spread"
top_mod_table_frt13_person[1,2]<-"frt13"
top_mod_table_frt13_person[1,3]<-"pttype ~ mean_PPT05_PPT06_PPT07_PPT08 + dem_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_roads_m +1)+ log(dist_infr_m+1) + win_sum"
top_mod_table_frt13_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt13_person[1,5]<- coef(mod)[2] 
top_mod_table_frt13_person[1,6]<- coef(mod)[3] 
top_mod_table_frt13_person[1,7]<- coef(mod)[4] 
top_mod_table_frt13_person[1,8]<- coef(mod)[5] 
top_mod_table_frt13_person[1,9]<- coef(mod)[6] 
top_mod_table_frt13_person[1,10]<- coef(mod)[7] 
top_mod_table_frt13_person[1,11]<- coef(mod)[8] 
top_mod_table_frt13_person[1,12]<- coef(mod)[9] 
top_mod_table_frt13_person[1,13]<- coef(mod)[10] 
top_mod_table_frt13_person[1,14]<- coef(mod)[11] 
top_mod_table_frt13_person[1,15]<- coef(mod)[12] 
top_mod_table_frt13_person[1,16]<- coef(mod)[13] 
top_mod_table_frt13_person[1,17]<- coef(mod)[14] 
top_mod_table_frt13_person[1,18]<- coef(mod)[15] 
top_mod_table_frt13_person[1,19]<- coef(mod)[16] 
top_mod_table_frt13_person[1,20]<- coef(mod)[17] 
top_mod_table_frt13_person[1,21]<- coef(mod)[18] 
top_mod_table_frt13_person[1,22]<- coef(mod)[19] 
top_mod_table_frt13_person[1,23]<- coef(mod)[20]
top_mod_table_frt13_person[1,24]<- mod.auc

top_mod_table_frt13_All<-rbind(top_mod_table_frt13_All, top_mod_table_frt13_person)

}

```

Check.
```{r}
head(top_mod_table_frt13_All)

```


Get mean values.

```{r}
names(top_mod_table_frt13_All)
str(top_mod_table_frt13_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt13_summary_table_mean<- top_mod_table_frt13_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt13_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt13_spread.csv")
```


################################
#FRT 14
################################

```{r}
# Plot climate data results

frt14<-fire_spread2 %>% filter(frt==14)
model1 <- glm (pttype ~ climate1 + climate2 ,
               data=frt14,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "climate1")
visreg(model1, scale="response", "climate2")
visreg(model1, "climate1")

ggplot(frt14, aes(x = climate1)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)
ggplot(frt14, aes(x = climate2)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)


ggplot(frt14, aes(x = as.factor(pttype), y=climate1)) +
  geom_boxplot()
ggplot(frt14, aes(x = as.factor(pttype), y=climate2)) +
  geom_boxplot()

table(is.na(frt14$win_sum))
table(is.na(frt14$dem_ha_bc))

frt14 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt14$win_sum[is.na(frt14$win_sum)]<-2.154197

frt14_2 <-frt14 %>% st_drop_geometry()

table(frt14_2$FWI_veg, frt14_2$pttype)
frt14_2$FWI_veg[frt14_2$FWI_veg=="M-3"]<-"O-1a/b"
frt14_2$FWI_veg[frt14_2$FWI_veg=="S-2"]<-"C-7"
#frt14_2$FWI_veg[frt14_2$FWI_veg=="S-3"]<-"M-1/2"


frt14_2<-frt14_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt14_2<-frt14_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt14_2$FWI_veg, frt14_2$pttype)

require (ggcorrplot)
dist.cut.corr <- (frt14_2 [, c("climate1", "climate2", "dem_ha_bc", "Latitude", "Longitude", "slope_ha_bc", "win_sum","win_spg", "dist_infr_m", "dist_roads_m")])
corr <- round (cor (dist.cut.corr), 3)
p.mat <- round (cor_pmat (dist.cut.corr), 2)
ggcorrplot (corr, type = "lower", lab = TRUE, tl.cex = 10,  lab_size = 3)
# Note climate 1 and dem are hightly correlated. -0.8 Ill only use dem because the relationship with climate1 is not in the direction I would expect.

model1 <- glm (pttype ~ climate1 + climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
summary(model1) #124154
Anova(model1, type=3)

model2 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model2) #124413.4

model3 <- glm (pttype ~ climate1 + climate2 + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model3) #126787.9
# remove climate1 is better than dem


model4 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + log(dist_roads_m+1) + dist_infr_m + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model4) #124274

model5 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model5) #123559.9

model6 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + log(dist_roads_m+1) + log(dist_infr_m+1) + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model6) #123855.1

# tahking log of  distance to infrastructure only helps


model5 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))
AIC(model5) #123559.9
Anova(model5)

# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model5), 
            residuals(model5), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt14_2$resids<-resid(model5)

binnedplot (frt14_2$dem_ha_bc, 
            frt14_2$resids)

binnedplot (as.numeric(frt14_2$climate2), 
            frt14_2$resids)

binnedplot (log(frt14_2$dist_roads_m+1), 
            frt14_2$resids, 
            nclass = NULL)


binnedplot (log(frt14_2$dist_infr_m+1), 
            frt14_2$resids, 
            nclass = NULL)


```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt14_2)

dat2_b<-frt14_2 %>% dplyr::select(pttype, climate1, climate2, dist_roads_m, dist_infr_m )
probabilities <- predict(model3, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model5, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model5) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(dem_ha_bc, climate2,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model5)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt14_2$aspect_cardinal2<-as.factor(frt14_2$aspect_cardinal2)
frt14_2$FWI_veg<-as.factor(frt14_2$FWI_veg)

model1 <- glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum,
               data=frt14_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt14_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt14_All <- data.frame (matrix (ncol = 22, nrow = 0))
colnames (top_mod_table_frt14_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_climate2",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

frt14_2$fire_veg<-paste(frt14_2$pttype, frt14_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt14_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt14_2[ trainIndex,]
   Valid <- frt14_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ climate2 + dem_ha_bc + slope_ha_bc + as.factor(aspect_cardinal2) + as.factor(FWI_veg) + dist_roads_m + log(dist_infr_m+1) + win_sum, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt14_person <- data.frame (matrix (ncol = 23, nrow = 0))
colnames (top_mod_table_frt14_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms", 
                                    "intercept",
                                    "coef_climate2",
                                    "coef_elevation",
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W", 
                                    "coef_FWI_veg_C-3",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-1",
                                    "coef_dist_roads",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt14_person[1,1]<-"spread"
top_mod_table_frt14_person[1,2]<-"frt14"
top_mod_table_frt14_person[1,3]<-"pttype ~ climate2 + dem_ha_bc + slope + aspect_cardinal + FWI_veg + log(dist_roads_m +1) + log(dist_infr_m+1) + win_sum"
top_mod_table_frt14_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt14_person[1,5]<- coef(mod)[2] 
top_mod_table_frt14_person[1,6]<- coef(mod)[3] 
top_mod_table_frt14_person[1,7]<- coef(mod)[4] 
top_mod_table_frt14_person[1,8]<- coef(mod)[5] 
top_mod_table_frt14_person[1,9]<- coef(mod)[6] 
top_mod_table_frt14_person[1,10]<- coef(mod)[7] 
top_mod_table_frt14_person[1,11]<- coef(mod)[8] 
top_mod_table_frt14_person[1,12]<- coef(mod)[9] 
top_mod_table_frt14_person[1,13]<- coef(mod)[10] 
top_mod_table_frt14_person[1,14]<- coef(mod)[11] 
top_mod_table_frt14_person[1,15]<- coef(mod)[12] 
top_mod_table_frt14_person[1,16]<- coef(mod)[13] 
top_mod_table_frt14_person[1,17]<- coef(mod)[14] 
top_mod_table_frt14_person[1,18]<- coef(mod)[15] 
top_mod_table_frt14_person[1,19]<- coef(mod)[16] 
top_mod_table_frt14_person[1,20]<- coef(mod)[17] 
top_mod_table_frt14_person[1,21]<- coef(mod)[18] 
top_mod_table_frt14_person[1,22]<- mod.auc

top_mod_table_frt14_All<-rbind(top_mod_table_frt14_All, top_mod_table_frt14_person)

}

```

Check.
```{r}
head(top_mod_table_frt14_All)
top_mod_table_frt14_All<- top_mod_table_frt14_All %>% select (CAUSE:AUC)

```


Get mean values.

```{r}
names(top_mod_table_frt14_All)
str(top_mod_table_frt14_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt14_summary_table_mean<- top_mod_table_frt14_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt14_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt14_spread.csv")
```


################################
#FRT 15
################################

```{r}
# Plot climate data results

frt15<-fire_spread2 %>% filter(frt==15)
model1 <- glm (pttype ~ summer_Tave + tot_summer_PPT ,
               data=frt15,
               family = binomial (link = "logit"))
summary(model1)

visreg(model1, scale="response", "summer_Tave")
visreg(model1, scale="response", "tot_summer_PPT")

ggplot(frt15, aes(x = summer_Tave)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)
ggplot(frt15, aes(x = as.factor(pttype), y=summer_Tave)) +
  geom_boxplot()
ggplot(frt15, aes(x = as.factor(pttype), y=tot_summer_PPT)) +
  geom_boxplot()
ggplot(frt15, aes(x = as.factor(pttype), y=dem_ha_bc)) +
  geom_boxplot()

ggplot(frt15, aes(x = tot_summer_PPT)) +
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(pttype ~ .)

frt15 %>% drop_na(win_sum) %>% summarize(mean(win_sum))
frt15$win_sum[is.na(frt15$win_sum)]<-2.510413

table(is.na(frt15$win_sum))

frt15_2 <-frt15 %>% st_drop_geometry()

table(frt15_2$FWI_veg, frt15_2$pttype)
frt15_2$FWI_veg[frt15_2$FWI_veg=="M-3"]<-"O-1a/b"
frt15_2$FWI_veg[frt15_2$FWI_veg=="C-2"]<-"C-3"
frt15_2$FWI_veg[frt15_2$FWI_veg=="S-1"]<-"S-3"


frt15_2<-frt15_2 %>% 
  filter(FWI_veg !="W") # remove water from the model

frt15_2<-frt15_2 %>% 
  filter(!bclcs_level_5 %in% c("GL", "LA")) # remove glaciers or lakes. Sometimes these get put into the N veg category so I want to make sure there are not present
table(frt15_2$FWI_veg, frt15_2$pttype)

require (ggcorrplot)
dist.cut.corr <- (frt15_2 [, c("summer_Tave", "tot_summer_PPT", "dem_ha_bc", "slope_ha_bc", "win_sum", "dist_infr_m", "dist_roads_m")])
corr <- round (cor (dist.cut.corr), 3)
p.mat <- round (cor_pmat (dist.cut.corr), 2)
ggcorrplot (corr, type = "lower", lab = TRUE, tl.cex = 10,  lab_size = 3)
# Note climate 1 and dem, and win_spg and win_sum are correlated

model1 <- glm (pttype ~ summer_Tave + tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))
summary(model1) #7584.7
Anova(model1, type=3)

model2 <- glm (pttype ~ tot_summer_PPT + dem_ha_bc + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))
AIC(model2) #7583.825

model3 <- glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_roads_m + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))
AIC(model3) #7582.655
Anova(model3)

# remove  dist to roads
model4 <- glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))
summary(model4) #7584.4
Anova(model4, type=3)
visreg(model4)

# try logging dist to infrastructure. does not help
model5 <- glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + log(dist_infr_m+1) + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))


summary(model5) #7587
Anova(model5, type=3)
visreg(model5)

###Best model
model8 <- glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))


# model diagnostic plots
# below model looks way better with log road dist. It had some structure with just road dist
binnedplot (fitted(model8), 
            residuals(model8), 
            nclass = NULL, 
            xlab = "Expected Values", 
            ylab = "Average residual", 
            main = paste("Binned Residual Plot - glm"))


frt15_2$resids<-resid(model8)

binnedplot (frt15_2$slope_ha_bc, 
            frt15_2$resids)

binnedplot (frt15_2$summer_Tave, 
            frt15_2$resids, nclass = NULL)


binnedplot (frt15_2$tot_summer_PPT                     , 
            frt15_2$resids, 
            nclass = NULL)

binnedplot (frt15_2$dist_infr_m, 
            frt15_2$resids, 
            nclass = NULL)


```

# check some model assumptions
```{r}
#Here, we’ll check the linear relationship between continuous predictor variables and the logit of the outcome. This can be done by visually inspecting the scatter plot between each predictor and the logit values.

#Remove qualitative variables from the original data frame and bind the logit values to the data:

# Select only numeric predictors
str(frt15_2)

dat2_b<-frt15_2 %>% dplyr::select(pttype, climate2, dist_infr_m )
probabilities <- predict(model8, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")

mydata <- dat2_b %>%
  dplyr::select_if(is.numeric) 
predictors <- colnames(mydata)

# Bind the logit and tidying the data for plot
mydata <- mydata %>%
  mutate(logit = log(probabilities/(1-probabilities))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")

# all variables should be approximatly linear
```

#Checking assumption of influential values

see: (http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/)
```{r}
#Influential values are extreme individual data points that can alter the quality of the logistic regression model.
#The most extreme values in the data can be examined by visualizing the Cook’s distance values. Here we label the top 3 largest values:

plot(model8, which = 4, id.n = 3)

#Note that, not all outliers are influential observations. To check whether the data contains potential influential observations, the standardized residual error can be inspected. Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.

#The following R code computes the standardized residuals (.std.resid) and the Cook’s distance (.cooksd) using the R function augment() [broom package].

# Extract model results
library(broom)

model.data <- augment(model8) %>% 
  mutate(index = 1:n()) 

#The data for the top 3 largest values, according to the Cook’s distance, can be displayed as follow:
model.data %>% 
  dplyr::select(slope_ha_bc, tot_summer_PPT,.std.resid, .cooksd) %>%
  top_n(5, .cooksd) 

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = pttype), alpha = .5) +
  theme_bw()

```

# checking assumption of no multicollinearity

```{r}
#Multicollinearity corresponds to a situation where the data contain highly correlated predictor variables. Read more in Chapter @ref(multicollinearity).

#Multicollinearity is an important issue in regression analysis and should be fixed by removing the concerned variables. It can be assessed using the R function vif() [car package], which computes the variance inflation factors:

car::vif(model8)

#As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. 
```


```{r}
frt15_2$aspect_cardinal2<-as.factor(frt15_2$aspect_cardinal2)
frt15_2$FWI_veg<-as.factor(frt15_2$FWI_veg)

model1 <- glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m + win_sum,
               data=frt15_2,
               family = binomial (link = "logit"))

summary(model1)
table(frt15_2$FWI_veg)

#Create a new blank table and get AUC too
top_mod_table_frt15_All <- data.frame (matrix (ncol = 20, nrow = 0))
colnames (top_mod_table_frt15_All ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms",
                                    "intercept",
                                    "coef_summer_Tave",
                                    "coef_tot_summer_PPT", 
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-3",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

frt15_2$fire_veg<-paste(frt15_2$pttype, frt15_2$FWI_veg)
```

Let's run it 100 times to get good mean values.

```{r}

for (g in 1:100){

prop<-0.75
# Creating training and testing datasets so that I can get a measure of how well the model actually predicts the data e.g. AUG
  trainIndex <- createDataPartition(frt15_2$fire_veg, p = prop,
                                    list = FALSE,
                                    times = 1)
  
   dat1 <- frt15_2[ trainIndex,]
   Valid <- frt15_2[-trainIndex,]
   
#Model   
mod<-glm (pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + as.factor(FWI_veg) + dist_infr_m + win_sum, data=dat1, family=binomial(link="logit"))

mod.valid <- predict.glm(mod, newdata=Valid, type="response")
   roc_obj <- roc(Valid[,"pttype"], mod.valid, quiet=TRUE)
   mod.auc <- auc(roc_obj)

# create model table (only do this once) and add the relevant data
top_mod_table_frt15_person <- data.frame (matrix (ncol = 20, nrow = 0))
colnames (top_mod_table_frt15_person ) <- c ("CAUSE", 
                                    "FRT",  
                                    "Model_terms",
                                    "intercept",
                                    "coef_summer_Tave",
                                    "coef_tot_summer_PPT", 
                                    "coef_slope",
                                    "coef_aspect_N",
                                    "coef_aspect_S",
                                    "coef_aspect_W",
                                    "coef_FWI_veg_C-5",
                                    "coef_FWI_veg_C-7",
                                    "coef_FWI_veg_D-1/2",
                                    "coef_FWI_veg_M-1/2",
                                    "coef_FWI_veg_N",
                                    "coef_FWI_veg_O-1a/b",
                                    "coef_FWI_veg_S-3",
                                    "coef_log_dist_infra",
                                    "coef_wind_summer",
                                    "AUC")

##Add data for NDT1
top_mod_table_frt15_person[1,1]<-"spread"
top_mod_table_frt15_person[1,2]<-"frt15"
top_mod_table_frt15_person[1,3]<-"pttype ~ summer_Tave + tot_summer_PPT + slope_ha_bc + aspect_cardinal2 + FWI_veg + dist_infr_m + win_sum"
top_mod_table_frt15_person[1,4]<- coef(mod)[1] #Intercept
top_mod_table_frt15_person[1,5]<- coef(mod)[2] 
top_mod_table_frt15_person[1,6]<- coef(mod)[3] 
top_mod_table_frt15_person[1,7]<- coef(mod)[4] 
top_mod_table_frt15_person[1,8]<- coef(mod)[5] 
top_mod_table_frt15_person[1,9]<- coef(mod)[6] 
top_mod_table_frt15_person[1,10]<- coef(mod)[7] 
top_mod_table_frt15_person[1,11]<- coef(mod)[8] 
top_mod_table_frt15_person[1,12]<- coef(mod)[9] 
top_mod_table_frt15_person[1,13]<- coef(mod)[10] 
top_mod_table_frt15_person[1,14]<- coef(mod)[11] 
top_mod_table_frt15_person[1,15]<- coef(mod)[12] 
top_mod_table_frt15_person[1,16]<- coef(mod)[13] 
top_mod_table_frt15_person[1,17]<- coef(mod)[14] 
top_mod_table_frt15_person[1,18]<- coef(mod)[15] 
top_mod_table_frt15_person[1,19]<- coef(mod)[16] 
top_mod_table_frt15_person[1,20]<- mod.auc

top_mod_table_frt15_All<-rbind(top_mod_table_frt15_All, top_mod_table_frt15_person)

}

```

Check.
```{r}
head(top_mod_table_frt15_All)

```


Get mean values.

```{r}
names(top_mod_table_frt15_All)
str(top_mod_table_frt15_All)
stderror <- function(x) sd(x)/sqrt(length(x))

frt15_summary_table_mean<- top_mod_table_frt15_All %>% summarize_if(is.numeric,mean)


```

Save table.

```{r}
write.csv(frt15_summary_table_mean, file="C:\\Work\\caribou\\castor_data\\Fire\\Fire_sim_data\\data\\BC\\top_mod_table_frt15_spread.csv")
```


###############DATA PREP COMPLETE###################
