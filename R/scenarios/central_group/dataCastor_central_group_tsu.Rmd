<!--
Copyright 2020 Province of British Columbia
 
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
 
http://www.apache.org/licenses/LICENSE-2.0
 
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.-->

---
title: "Database creation for Caribou Central Group Scenario Analysis"
author: "Tyler Muhly"
date: "2 February 2023"
output: pdf_document
---

# Overview


# Usage
Set parameters for creating the database in the code chunk below.

```{r module_usage}
library (SpaDES)
library (SpaDES.core)
library (data.table)
library (keyring)
library (terra)

source (here::here("R/functions/R_Postgres.R"))

Sys.setenv(JAVA_HOME = 'C:\\Program Files\\Java\\jdk-14.0.1') #throws an error if pointing to different version of java (i.e., 32 vs 64 bit)

moduleDir <- file.path (paste0 (here::here (), "/R/SpaDES-modules"))
inputDir <- file.path (paste0 (here::here (), "/R/scenarios/revelstoke_complex/inputs")) %>% reproducible::checkPath (create = TRUE)
outputDir <- file.path (paste0 (here::here (), "/R/scenarios/revelstoke_complex/outputs")) %>% reproducible::checkPath (create = TRUE)
cacheDir <- file.path (paste0 (here::here (), "/R/scenarios/revelstoke_complex"))

times <- list (start = 0, end = 0)

parameters <-  list (
        .progress = list (type = NA, interval = NA),
        .globals = list (),
        dataCastor = list(dbName = 'castor',
                          saveCastorDB = TRUE,
                          sqlite_dbname = "central_group_tsu_march2023", 
                          nameBoundaryFile = "public.tsa_aac_bounds", 
                          nameBoundaryColumn = "tsa_name", 
                          nameBoundary = c ("Dawson_Creek_TSA", "TFL48"), 
                          nameBoundaryGeom = 'wkb_geometry',
                          nameCompartmentRaster = "rast.tsa_aac_boundary", 
                          nameCompartmentTable = "vat.tsa_aac_bounds_vat", 
                          nameMaskHarvestLandbaseRaster = 'rast.thlb_2020', 
                          nameZoneRasters = c ("rast.zone_cond_beo", 
                                               "rast.zone_cond_vqo", 
                                               "rast.zone_wha_2021", 
                                               "rast.zone_uwr_2021",  
                                               "rast.zone_cond_nharv", 
                                               "rast.zone_cond_fsw", 
                                               "rast.zone_cond_cw",
                                               "rast.zone_cond_pri_old_deferral", # TAP proposed old growth deferral areas
                                               "rast.zone_cond_bc_burnt_pine_crithab",
                                               "rast.zone_cond_bc_hart_ranges_crithab",
                                               "rast.zone_cond_bc_kennedy_siding_crithab",
                                               "rast.zone_cond_bc_moberly_crithab",
                                               "rast.zone_cond_bc_quintette_crithab",
                                               "rast.zone_cond_bc_narraway_crithab",
                                               "rast.central_grp_proposed_luo_feb2021",
                                               "rast.central_grp_habitat_072022",
                                               "rast.central_grp_deferral_072022",
                                               "rast.central_grp_partner_areas_072022",
                                               "rast.central_group_chra_032023", 
                                               "rast.central_group_chma_032023"
                                               ),
                          nameZoneTable = "zone.constraints", 
                          nameYieldsRaster = "rast.ycid_vdyp_2020_adj",
                          nameYieldTable = "yc_vdyp_2020_adj", 
                          nameYieldsCurrentRaster = "rast.ycid_tipsy_current_2020",
                          nameYieldCurrentTable = "tipsy_prov_current_2020",
                          nameYieldsTransitionRaster = "rast.ycid_tipsy_prov_2020", 
                          nameYieldTransitionTable = "tipsy_prov_2020",  
                          nameForestInventoryRaster = "rast.vri2020_id", 
                          nameForestInventoryKey = "feature_id", 
                          nameForestInventoryTable = "veg_comp_2020_adj",
                          nameForestInventoryAge = "proj_age_1",  
                          nameForestInventoryHeight = "proj_height_1",
                          nameForestInventoryCrownClosure = "crown_closure",                             
                          nameForestInventoryTreed = "bclcs_level_2",
                          nameForestInventoryBasalArea= "basal_area",
                          nameForestInventoryQMD = "quad_diam_125",
                          nameForestInventorySiteIndex = "site_index" 
                          ),
        growingStockCastor = list (periodLength = 10),
        blockingCastor = list(blockMethod = 'pre', 
                              patchZone = 'rast.zone_cond_beo',
                              patchVariation = 6,
                              nameCutblockRaster ="rast.cns_cut_bl",
                              useLandingsArea = FALSE),
        roadCastor = list (roadMethod = 'mst',
                           nameCostSurfaceRas = 'rast.rd_cost_surface',
                           nameRoads =  'rast.ce_road_2019'
                           ),
        survivalCastor = list (caribou_herd_density = 0.05, 
                               nameRasCaribouHerd = "rast.caribou_herd_20220725", 
                               tableCaribouHerd = "vat.caribou_herd_20220725"),
        smcpopCastor = list (nameRasSMCHerd = "rast.smc_herd_habitat", 
                             tableSMCCoeffs = "vat.smc_coeffs"),
        disturbanceCastor = list(calculateInterval =  1, 
                                 criticalHabitatTable = "vat.vat_bc_crithab_and_herd",
                                 criticalHabRaster = "rast.bc_crithab_and_herd",
                                 permDisturbanceRaster = "rast.mine_ag_wind_rail",
                                 recovery = 300), # no road recovery
        volumebyareaReportCastor = list (calculateInterval = 1,
                                         AreaofInterestRaster = "rast.bc_crithab_and_herd",
                                         AreaofInterestTable = "vat.vat_bc_crithab_and_herd"),
        uploadCastor = list(aoiName = 'central_group_caribou_tsu',
                              dbInfo  = list(keyring::key_get ("vmdbhost", keyring="postgreSQL"),
                                             keyring::key_get ("vmdbuser", keyring="postgreSQL"),
                                             keyring::key_get ("vmdbpass", keyring="postgreSQL"), 
                                             keyring::key_get ("vmdbname", keyring="postgreSQL")))
        )

scenario = data.table (name = "load_data", description = "dataCastor output")

modules <- list("dataCastor",
                "growingStockCastor",
                "blockingCastor", 
                "roadCastor",
                "survivalCastor",
                "smcpopCastor",
                "disturbanceCastor",
                "volumebyareaReportCastor",
                "uploadCastor")

objects <- list (scenario = scenario
                 )

paths <- list(cachePath = cacheDir,
              modulePath = moduleDir,
              inputPath = inputDir,
              outputPath = outputDir)

inputs <- list()
outputs <- list()

mySim <- simInit(times = times, 
                 params = parameters, 
                 modules = modules,
                 objects = objects,
                 paths = paths)

# outputs to keep; these are tables that get used in the uploader
outputs(mySim) <- data.frame (objectName = c("harvestReport",
                                             "growingStockReport",
                                             "tableSurvival",
                                             "disturbanceReport",
                                             #"volumebyareaReport",
                                             "tableAbundanceReport"))

system.time({
mysimout<-spades(mySim)
})

```

## Create 'Blocks' Tables
Use the script below to replicate the STSM approach of not creating 'blocks' (i.e., each pixel is a block) in the castor db.

```{r, create blocks}
castordb <- dbConnect(RSQLite::SQLite(), dbname = paste0(here::here(), "/R/scenarios/comparison_ft_nelson/ftnelson_stsmcompare_noroads_noblocks_castordb.sqlite"))
# update pixels table 
dbExecute (castordb, "ALTER TABLE pixels ADD COLUMN blockid integer DEFAULT 0")
dbBegin (castordb)
rs <- dbSendQuery (castordb, "UPDATE pixels SET blockid = pixelid;")
dbClearResult (rs)
dbCommit (castordb)

# create blocks table
dbExecute (castordb, "CREATE TABLE IF NOT EXISTS blocks ( blockid integer DEFAULT 0, age integer, height numeric, vol numeric, salvage_vol numeric, dist numeric DEFAULT 0, landing integer)")  
dbExecute (castordb, paste0("UPDATE blocks SET vol = 0 WHERE vol IS NULL")) 
dbExecute (castordb, paste0("UPDATE blocks SET dist = 0 WHERE dist is NULL"))
dbExecute (castordb, paste0("INSERT INTO blocks (blockid, age, height,  vol, salvage_vol, dist, landing)  
                    SELECT blockid, round(AVG(age),0) as age, AVG(height) as height, AVG(vol) as vol, AVG(salvage_vol) as salvage_vol, AVG(dist) as dist, (CASE WHEN min(dist) = dist THEN pixelid ELSE pixelid END) as landing
                                       FROM pixels WHERE blockid > 0 AND thlb > 0 GROUP BY blockid "))  
dbExecute (castordb, "CREATE INDEX index_blockid on blocks (blockid)")

# create adjacent blocks table
ras <- terra::rast (ncol = 5223, nrow = 2947, xmin = 830187.5, 
			              xmax = 1352488, ymin = 1388088, ymax = 1682788,)  
terra::crs(ras)  <- "+proj=aea +lat_0=45 +lon_0=-126 +lat_1=50 +lat_2=58.5 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs"  
edgesAdj <- data.table(SpaDES.tools::adj(returnDT= TRUE, 
                                         directions = 8, numCol = ncol(ras), numCell=ncol(ras)*nrow(ras),
                                         cells = 1:as.integer(ncol(ras)*nrow(ras)))) 
blockids <- data.table (dbGetQuery (castordb, "SELECT blockid, pixelid FROM pixels WHERE blockid > 0"))
setkey (blockids, pixelid)  
edgesAdj <- merge (edgesAdj, blockids, by.x = "to", by.y = "pixelid" )  
edgesAdj <- merge (edgesAdj, blockids, by.x = "from", by.y ="pixelid" )
edgesAdj <- data.table (edgesAdj[, c ("blockid.x", "blockid.y")])
edgesAdj <- edgesAdj[blockid.x  != blockid.y]
edgesAdj <- edgesAdj[blockid.x  > 0 & blockid.y  > 0]
edgesAdj <- unique (edgesAdj)
setnames (edgesAdj, c ("blockid", "adjblockid")) 
  
dbExecute(castordb, "CREATE TABLE IF NOT EXISTS adjacentBlocks (id integer PRIMARY KEY, adjblockid integer, blockid integer)")  
dbBegin(castordb)  
rs <- dbSendQuery (castordb, "INSERT INTO adjacentBlocks (blockid , adjblockid) VALUES (:blockid, :adjblockid)", edgesAdj)  
dbClearResult(rs)
dbCommit(castordb) 
dbExecute(castordb, "CREATE INDEX index_adjblockid on adjacentBlocks (adjblockid)")
```

