---
title: "Provincial Yield Curve Generation"
author: "Kyle"
date: "28/01/2021"
output: 
  html_document:
    keep_md: true
---

### Provincial Yield Curve Generation

The goal is to have a yield curve for each 1 ha pixel in the province. Yield curves generated by VDYP represent natural orgin stands; whereas yield curves from TIPSY represent human orgin stands.

### VDYP

#### Set up postgreSQL

The following steps outline the projection of the VRI using VDYP -- see [vdyp_curves.Rmd](https://github.com/bcgov/clus/blob/master/R/Params/vdyp_curves.Rmd).

1. Generate INPUT .csv files and parameter text file which are the inputs used to run Batch VDYP. These include:

* VEG_COMP_VDYP7_INPUT_LAYER_TBL_2019

* VEG_COMP_VDYP7_INPUT_POLY_TBL_2019

* ParameterFile.txt

2. Run Batch VDYP7. This step creates two files:

* output_125.csv

* error_125.txt

3. Upload the files from #1 and 2 into postgreSQL. The following is an example of how to achieve this -- since the datasets are large enough to render programs like excel or other obsolete. 


```r
#CREATE the TABLE(s) -- a cheat to do this is to make R write to the db.
#--------------------------------------------------------------------
#Import the first 500 rows into R
input_tbl<-read.table(paste0(here::here(),"/VDYP/VRI2018/VEG_COMP_VDYP7_INPUT_LAYER_TBL_2019.csv"), sep= ",", header = TRUE, nrows = 5000)

#Format the R object so that there are no uppper case column names
colnames(input_tbl)<-tolower(colnames(input_tbl))

#Connect to the postgreSQL db
conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

#Write the file in postgreSQL
DBI::dbWriteTable(conn, c("public", "vdyp_input_layer"), value= input_tbl, row.names = FALSE, overwrite = TRUE) 

#Remove all the observations
dbExecute(conn, "DELETE FROM vdyp_input_layer")

#Disconnect from the database
dbDisconnect(conn)
#--------------------------------------------------------------------

#Commit the .csv files to the postgreSQL database
cmd <- paste0("\\copy vdyp_input_layer from program 'cmd /c \"type E:\\Data\\VEG_COMP_VDYP7_INPUT_LAYER_TBL_2019.csv" , "\"' delimiter ',' csv header")
cmd <- shQuote(cmd)
system2("psql",args=c('-d clus -c',cmd),wait=TRUE,stderr=TRUE)
```

*Note that when committing the data to postgreSQL -- some of the fields might need be changed to a different type. For a template of the CREATE TABLE go [here](https://github.com/bcgov/clus/blob/master/SQL/develop_vdyp_table.sql)*

#### Generate yc_grp

Once the vdyp projection 'output' and 'input' .csv files have become table objects in postgreSQL, the next step is the generate the yield curves. This process can take many forms -at one extreme is to keep the yield curves specific to each polygon or the other extreme is to "roll them up" or aggregate them into yield curve groups (a.k.a., analysis units). The later process uses an sql script found [here](https://github.com/bcgov/clus/blob/master/SQL/develop_vdyp_table.sql) and the steps follow:

##### 1. Clean

* Remove NON-PRIMARY layer for now. Consider aggregating the layers?

* Remove those secondary layers that are not labeled with a Primary label

* Set "Back" projections to NULL -- these are unreliable

* Remove Projections that have serious errors as reported in the error table

##### 2. Merge

* Merge in VRI forest Attribute information for creating aggregated yield curve group. This involves species, site index, height and age . 

+ Create a simpfilfied VEG_COMP table with the necessary information for the yield curve group -- call it something like vdyp_vri2018

* Re-format the species calls/codes to match the species projected in VDYP.

+ Group the species 1 and species 2 call if they are the same after the grouping used by VDYP

+ The species grouping for the yield curve groups uses the following SQL:

`WHEN species_cd_2 IS NOT NULL AND species_pct_2 >= 20 THEN CONCAT(species_cd_1,species_cd_2)`

`WHEN species_cd_2 IS NOT NULL AND species_pct_2 < 20 THEN CONCAT(species_cd_1,'(',species_cd_2,')')`

* Round the site index to the nearest 2 m

* Build the yield curve group using:
`
yc_grp = CONCAT(bec_zone_code,'_',l3spp,'_', site_index,'_',crown_closure_class_cd,'_', proj_height_class_cd_1)`

* Join the vdyp_vri2018 table that includes yc_grp with the original vdyp output table

* Add the percent of the volume as deciduous

##### 3. Aggregate

* Get the total area for each yc_grp and merge back into the table

* Create a column called 'wt' which is the weight of ratio of each polygon area to the total area of the yc_grp estimated from the above

* Area weight each yield curve for each of the attributes

##### 4. Format

* Format the resulting table to match yc_vdyp table -- this may change as we add other attributes like QMD, basal area, etc.

#### TIPSY

*TODO: document the tipsy - RESULTS database process*
 

